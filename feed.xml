<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Booiris</title>
  <icon>https://booiris.space/src/icon-32x32.ico</icon>
  <subtitle>English by default🤖</subtitle>
  <link href="https://booiris.space/feed.xml" rel="self"/>
  
  <link href="https://booiris.space/"/>
  <updated>2024-09-01T08:38:18.000Z</updated>
  <id>https://booiris.space/</id>
  
  <author>
    <name>booiris</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sicp 章节2</title>
    <link href="https://booiris.space/pages/sicp/sicp%20%E7%AB%A0%E8%8A%822.html"/>
    <id>https://booiris.space/pages/sicp/sicp%20%E7%AB%A0%E8%8A%822.html</id>
    <published>2024-09-01T07:56:49.000Z</published>
    <updated>2024-09-01T08:38:18.000Z</updated>
    
    
    
    
    <category term="sicp" scheme="https://booiris.space/categories/sicp/"/>
    
    
  </entry>
  
  <entry>
    <title>金字塔原理</title>
    <link href="https://booiris.space/pages/read_notes/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86.html"/>
    <id>https://booiris.space/pages/read_notes/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86.html</id>
    <published>2024-06-15T08:13:55.000Z</published>
    <updated>2024-06-23T17:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>本书分为4个部分。</p><p><strong>第1篇　表达的逻辑</strong>　介绍了金字塔原理的基本概念，以及如何利用这一原理构建基本的金字塔结构。本篇的内容足以使你理解和应用简单的公文写作技巧。</p><p><strong>第2篇　思考的逻辑</strong>　介绍了如何深入细致地把握思维的细节，以保证你使用的语句真实、明确地呈现你希望表达的思想。本篇举了许多案例，突出了迫使自己进行“冷静思考”对明确阐述思想的重要性。</p><p><strong>第3篇　解决问题的逻辑</strong>　读者对象是需要写研究报告的人，以及需要分析复杂问题、提出结论以作出决策的人。本篇介绍了如何在解决问题过程的不同阶段，使用多种框架组织分析过程，使你的思路实际上进行了预先组织，从而可以更方便地应用金字塔原理。</p><p><s><strong>第4篇　演示的逻辑</strong>　介绍了设计 PowerPoint 演示幻灯片的技巧，可以帮助你在用演示文稿呈现具有金字塔结构的思想时，使读者或观众感受到金字塔结构。</s> (用不到先不看了)</p><h2 id="第一篇-表达的逻辑"><a class="markdownIt-Anchor" href="#第一篇-表达的逻辑"></a> 第一篇 表达的逻辑</h2><p>第一篇主要所写的是如何让文章更易理解的方法论。方法论的阐释往往需要辅以具体事例，文中也举例了一些事例进行说明。但本章既然是讲述写作的方法论，那么不如直接以原文章的行文顺序做例子，看看原文是否实现了自己提出的方法论的自举( 。</p><h3 id="核心观点"><a class="markdownIt-Anchor" href="#核心观点"></a> 核心观点</h3><blockquote><p>对受众（包括读者、听众、观众或学员）来说，最容易理解的顺序是：先了解主要的、抽象的思想，然后了解次要的、为主要思想提供支持的思想。因为主要思想总是从次要思想概括总结得出，文章中所有思想的理想组织结构也必定是一个金字塔结构——由一个总的思想统领多组思想。</p></blockquote><p>在本篇开头，一堆引言结束后作者提出了本篇的核心观点: 写作需要按照金字塔的结构，首先提出主要思想，然后介绍多组次要思想支持主要思想。每组思想间的联系可以是纵向的 (即上层思想是对下层的总结)，也可以是横向的 (即多个思想组成同一个逻辑推理过程，而被并列排在一起)。(怎么感觉在教高中议论文😂)</p><p>#todo 加个思维导图</p><h3 id="11-为什么要用金字塔结构"><a class="markdownIt-Anchor" href="#11-为什么要用金字塔结构"></a> 1.1 为什么要用金字塔结构</h3><h2 id="第二篇-思考的逻辑"><a class="markdownIt-Anchor" href="#第二篇-思考的逻辑"></a> 第二篇 思考的逻辑</h2><h2 id="第三篇-解决问题的逻辑"><a class="markdownIt-Anchor" href="#第三篇-解决问题的逻辑"></a> 第三篇 解决问题的逻辑</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;本书分为4个部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1篇　表达的逻辑&lt;/strong&gt;　介绍了金字塔原理的基本概念，以及如何利用这一原理构建基本</summary>
      
    
    
    
    <category term="read_notes" scheme="https://booiris.space/categories/read-notes/"/>
    
    
  </entry>
  
  <entry>
    <title>sicp 章节1</title>
    <link href="https://booiris.space/pages/sicp/sicp%20%E7%AB%A0%E8%8A%821.html"/>
    <id>https://booiris.space/pages/sicp/sicp%20%E7%AB%A0%E8%8A%821.html</id>
    <published>2024-06-15T05:46:41.000Z</published>
    <updated>2024-09-01T08:16:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题解: <a href="https://github.com/booiris/SICP-learning/tree/master/exercise_1">SICP-learning/exercise_1 at master · booiris/SICP-learning · GitHub</a></p></blockquote><h2 id="1-building-abstractions-with-procedures"><a class="markdownIt-Anchor" href="#1-building-abstractions-with-procedures"></a> 1. Building Abstractions With Procedures</h2><p>sicp 前面部分介绍的内容还是比较基础的，具体是在介绍程序是什么。</p><blockquote><p>We are about to study the idea of a <em>computational process</em>. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called <em>data</em>. The evolution of a process is directed by a pattern of rules called a <em>program</em>.</p><p>– <em>computational process</em> (即计算过程) 是操作数据的过程，这一过程的实现由一组定义的规则(程序)完成。</p></blockquote><p>从中可以看出编写的计算机程序有两个重要的元素:</p><ol><li>数据</li><li>操作数据的行为</li></ol><p>笔者认为我们编写的程序就是处理数据的过程，是对数据的各种加工变换(这就是为啥一个好的类型系统那么重要，土法炼钢不可取，此处@某一个大道至简的语言😚<a href="/pages/sicp/sicp%20%E7%AB%A0%E8%8A%821.html/../../blog/%E4%B8%BA%E5%95%A5%20go%20%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.html">为啥 go 不支持泛型方法</a>)。</p><h3 id="11-the-elements-of-programming"><a class="markdownIt-Anchor" href="#11-the-elements-of-programming"></a> 1.1 The elements of Programming</h3><p>本节开始又到了最喜欢的概念定义环节，一个成熟的语言需要以下三种结构：</p><ol><li><strong>primitive expressions</strong>, which represent the simplest entities the language is concerned with,</li><li><strong>means of combination</strong>, by which compound elements are built from simpler ones, and</li><li><strong>means of abstraction</strong>, by which compound elements can be named and manipulated as units.</li></ol><p>具体来说就是需要</p><ol><li>基本表达式，表示语言中的一些基础的实体，比如变量和基本类型等</li><li>组合算子，能够从简单的元素构建出复杂的运算，比如运算符和函数调用等</li><li>抽象方式，能够将一组过程或者数据类型封装合并为一个单元，比如变量定义、函数定义和抽象数据类型的定义</li></ol><p>之后，文中再次强调了程序中最重要的两个元素，过程和数据(但实际上过程也可以认为是一种数据(有没有函数是一等公民的即视感) )：</p><blockquote><p>In programming, we deal with two kinds of elements: procedures and data. (Later we will discover that they are really not so distinct.)</p></blockquote><h4 id="111-expressions"><a class="markdownIt-Anchor" href="#111-expressions"></a> 1.1.1 Expressions</h4><p>基本上是在通过介绍 lisp 中的一些语法来阐释 expressions 这一概念（不过 lisp 是前缀表达式还真是反直觉👾，当然把运算符当成函数调用看能好一点，也确实能更好表达函数复合等概念，但还是难受🤖）。</p><p>一些表达式例子:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line">(<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">(<span class="name">*</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>后面带运算符的表达式被称为组合式。</p><h4 id="112-naming-and-the-environment"><a class="markdownIt-Anchor" href="#112-naming-and-the-environment"></a> 1.1.2 Naming and the Environment</h4><p>介绍了 lisp 的变量定义方式，还捎带讲了下变量作用域的概念。</p><h4 id="113-evaluating-combinations"><a class="markdownIt-Anchor" href="#113-evaluating-combinations"></a> 1.1.3 Evaluating Combinations</h4><p>介绍了 lisp 计算组合式的方式：</p><ol><li>计算组合式需要首先计算所有子表达式，是一个递归计算的过程。</li><li>自左向右计算值。</li></ol><p>计算组合式的过程构成了一个多叉树，计算组合式的过程就是计算一个个基本表达式的过程，而构成基本表达式的规则为：</p><ol><li>数值的值就是它们所代表的数字本身 (有点怪怪的，应该指的是 数值是最基本的元素，参与运算的实际上是具体的数值。比如计算 x=2， + x 1 时，实际上是计算 + 2 1，在计算的过程中变量已经替换为具体的值了)。</li><li>表达式中有一些基本内置运算符，对应着完成相应操作的机器指令。</li><li>表达式中还存在着一些变量，这些变量指向当前作用域中的一个特定对象。所以变量不能脱离作用域，单纯的 (+ x 1) 是无意义的，无法计算出它的值。</li></ol><h4 id="114-compound-procedures"><a class="markdownIt-Anchor" href="#114-compound-procedures"></a> 1.1.4 Compound Procedures</h4><p>这一章介绍的是 lisp 中函数的定义方法，在文中被称为 “<em>compound procedure</em>”。</p><p>lisp 的函数定义语法形式为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( <span class="name">define</span> (<span class="name">&lt;name&gt;</span> &lt;formal parameters&gt;) &lt;body&gt; )</span><br></pre></td></tr></table></figure><h4 id="115-the-substitution-model-for-procedure-application"><a class="markdownIt-Anchor" href="#115-the-substitution-model-for-procedure-application"></a> 1.1.5 The Substitution Model for Procedure Application</h4><p>本章讲的是 lisp 计算自定函数的过程，和 <a href="/pages/sicp/sicp%20%E7%AB%A0%E8%8A%821.html/../sicp%20%E7%AB%A0%E8%8A%821.html#113-evaluating-combinations">1.1.3 Evaluating Combinations</a> 中计算组合式的过程类似。在本章中使用了 “<em>substitution model</em>” (替换)来解释运算过程。</p><p>例:</p><p>对于如下函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x) (<span class="name">*</span> x x) )</span><br><span class="line">(<span class="name">define</span> (<span class="name">sum-of-squares</span> x y)</span><br><span class="line">(<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y) ) )</span><br><span class="line">(<span class="name">define</span> (<span class="name">f</span> a)</span><br><span class="line">(<span class="name">sum-of-squares</span> (<span class="name">+</span> a <span class="number">1</span>) (<span class="name">*</span> a <span class="number">2</span>) ) )</span><br></pre></td></tr></table></figure><p>计算 <code>(f 5)</code> 的过程如下:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">f</span> <span class="number">5</span>) -&gt;</span><br><span class="line">(<span class="name">sum-of-squares</span> (<span class="name">+</span> <span class="number">5</span> <span class="number">1</span>) (<span class="name">*</span> <span class="number">5</span> <span class="number">2</span>) ) -&gt;</span><br><span class="line">(<span class="name">sum-of-squares</span> <span class="number">6</span> <span class="number">10</span>) -&gt;</span><br><span class="line">(<span class="name">+</span> (<span class="name">square</span> <span class="number">6</span>) (<span class="name">square</span> <span class="number">10</span>) ) -&gt;</span><br><span class="line">(<span class="name">+</span> (<span class="name">*</span> <span class="number">6</span> <span class="number">6</span>) (<span class="name">*</span> <span class="number">10</span> <span class="number">10</span>) ) -&gt;</span><br><span class="line">(<span class="name">+</span> <span class="number">36</span> <span class="number">100</span>) -&gt;</span><br><span class="line"><span class="number">136</span></span><br></pre></td></tr></table></figure><p><em>substitution model</em> 就是将实际的运算式替换函数名的过程。但这并不是lisp 的实际运算过程。在后续 3、4、5 章会更详细地讲述这一过程。</p><h5 id="计算表达式的顺序"><a class="markdownIt-Anchor" href="#计算表达式的顺序"></a> 计算表达式的顺序</h5><p>在上面举例计算 <code>(f 5)</code> 的过程中可以发现，我们是在遇到可计算的基本表达式时就直接计算出对应的值。然而还有另一种计算的方式，就是在计算表达式的过程中只展开表达式，而不计算值，当整个表达式被展开成只由基本表达式组成时，再计算出值。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">f</span> <span class="number">5</span>) -&gt;</span><br><span class="line">(<span class="name">sum-of-squares</span> (<span class="name">+</span> <span class="number">5</span> <span class="number">1</span>) (<span class="name">*</span> <span class="number">5</span> <span class="number">2</span>) ) -&gt;</span><br><span class="line">(<span class="name">+</span> (<span class="name">square</span> (<span class="name">+</span> <span class="number">5</span> <span class="number">1</span>)) (<span class="name">square</span> (<span class="name">*</span> <span class="number">5</span> <span class="number">2</span>) ) ) -&gt;</span><br><span class="line">(<span class="name">+</span> (<span class="name">*</span> (<span class="name">+</span> <span class="number">5</span> <span class="number">1</span>) (<span class="name">+</span> <span class="number">5</span> <span class="number">1</span>) ) (<span class="name">*</span> (<span class="name">*</span> <span class="number">5</span> <span class="number">2</span>) (<span class="name">*</span> <span class="number">5</span> <span class="number">2</span>) ) ) -&gt;</span><br><span class="line"><span class="number">136</span></span><br></pre></td></tr></table></figure><p>这种完全展开的计算过程被称为 <em>normal-order evaluation</em> (正则序求值)，先求值再代入函数调用的被称为 <em>applicative-order evaluation</em> (应用序求值)。</p><p>lisp 中采用的是后面一种计算方式，部分原因在于其能够避免对表达式的重复求值。对于人类来说，完全展开然后计算从直觉上感觉就十分麻烦，但其也有特殊用处，可以用于处理无法求值的表达式，第三章讨论了使用正则式定义的流式过程，用于处理无限数据结构。</p><h4 id="116-conditional-expressions-and-predicates"><a class="markdownIt-Anchor" href="#116-conditional-expressions-and-predicates"></a> 1.1.6 Conditional Expressions and Predicates</h4><p>这一章介绍了 lisp 中的分支语法，语法形式为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cond</span> (⟨p₁⟩ ⟨e₁⟩)</span><br><span class="line">      (⟨p₂⟩ ⟨e₂⟩)</span><br><span class="line">      …</span><br><span class="line">      (⟨pₙ⟩ ⟨eₙ⟩))</span><br></pre></td></tr></table></figure><p>还有个 <code>if</code> 语法糖，语法形式为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">if</span> ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩)</span><br></pre></td></tr></table></figure><p>分支语法关联的逻辑运算符为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">and</span> ⟨e₁⟩ … ⟨eₙ⟩)</span><br><span class="line">(<span class="name">or</span> ⟨e₁⟩ … ⟨eₙ⟩)</span><br><span class="line">(<span class="name">not</span> ⟨e⟩)</span><br></pre></td></tr></table></figure><h4 id="117-example-square-roots-by-newtons-method"><a class="markdownIt-Anchor" href="#117-example-square-roots-by-newtons-method"></a> 1.1.7 Example: Square Roots by Newton’s Method</h4><p>首先，如 <a href="/pages/sicp/sicp%20%E7%AB%A0%E8%8A%821.html/../sicp%20%E7%AB%A0%E8%8A%821.html#1-building-abstractions-with-procedures">1. Building Abstractions With Procedures</a> 中所言，<em>procedures</em> 是操作数据的过程，这很像常规的数学函数，通过输出一些值，经过一些运算然后得到一些值。但和数学上的函数不一样的点在于，程序中的函数必须是可行的。</p><p>以计算平方根为例，在数学上定义平方根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><msqrt><mi>x</mi></msqrt><mo separator="true">,</mo><mspace width="1em"/><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mspace width="1em"/><mi>y</mi><mo>≥</mo><mn>0</mn><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y = \sqrt{x}  , \quad where \quad  y \geq 0 \quad and \quad y^2 = x  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043595em;vertical-align:-0.19444em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491550000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">x</span></span></span><span style="top:-2.809155em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.190845em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span></span></p><p>非常的清晰，但也非常的抽象，这个函数只给出了什么是平方根函数(平方的逆函数)，但并没有给出怎么计算一个值的平方根。在书中提到这反映了说明性描述和过程性描述的区别，即使给出了一个函数的定义，但推出它的具体实现也是很困难的。</p><p>最常用的计算平方根的方法为牛顿迭代法，其过程用如下代码表示：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">sqrt-iter</span> guess x)</span><br><span class="line">(<span class="name">if</span> (<span class="name">good-enough</span>? guess x)</span><br><span class="line">guess</span><br><span class="line">(<span class="name">sqrt-iter</span> (<span class="name">improve</span> guess x) x)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">improve</span> guess x)</span><br><span class="line">(<span class="name">average</span> guess (<span class="name">/</span> x guess)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">average</span> x y)</span><br><span class="line">(<span class="name">/</span> (<span class="name">+</span> x y) <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">good-enough</span>? guess x)</span><br><span class="line">(<span class="name">&lt;</span> (<span class="name">abs</span> (<span class="name">-</span> (<span class="name">*</span> guess guess) x)) <span class="number">0.001</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sqrt</span> x)</span><br><span class="line">(<span class="name">sqrt-iter</span> <span class="number">1.0</span> x))</span><br></pre></td></tr></table></figure><p>文字描述为不断使用一种方法猜测一个数，计算它的平方，使得平方值不断逼近给定的被开方数。</p><h4 id="118-procedures-as-black-box-abstractions"><a class="markdownIt-Anchor" href="#118-procedures-as-black-box-abstractions"></a> 1.1.8 Procedures as Black-Box Abstractions</h4><p>这一章讲述了将程序作为黑箱抽象的重要性。这个没啥好说的，好是很好，但不恰当地执行就容易变得更加抽象🤣。</p><ul><li><strong>接口和实现分离</strong>：程序的接口（输入输出）和实现（内部细节）是分离的。用户通过接口使用程序，而不需要了解实现细节。</li><li><strong>信息隐藏</strong>：通过隐藏不必要的实现细节，可以减少认知负担，使程序更易于理解和使用。</li><li><strong>模块化设计</strong>：通过将程序分解为独立的模块，每个模块实现特定的功能，可以提高程序的可维护性和可扩展性。</li></ul><h3 id="12-procedures-and-the-processes-they-generate"><a class="markdownIt-Anchor" href="#12-procedures-and-the-processes-they-generate"></a> 1.2 Procedures and the Processes They Generate</h3><p>在第一节讲述了什么是程序，但并没有讲该怎么写程序。这就相当于我们了解了下棋的规则，但还是不知道下棋的策略。这一节就是通过一些算法介绍一些常见的程序结构。(说实在的 sicp 的精华都在后几章，前面的太基础有点想跳过了…)</p><h4 id="121-linear-recursion-and-iteration"><a class="markdownIt-Anchor" href="#121-linear-recursion-and-iteration"></a> 1.2.1 Linear Recursion and Iteration</h4><p>这一小节通过计算阶乘介绍什么是递归和迭代结构。</p><p>定义阶乘:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mo>⋯</mo><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n! = n \times (n-1) \times (n-2) \times \dots \times 2 \times 1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><h5 id="递归结构"><a class="markdownIt-Anchor" href="#递归结构"></a> 递归结构</h5><p>根据数学定义，能够很容易地写出计算程序为:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name">if</span> ( <span class="name">=</span> n <span class="number">1</span>) <span class="number">1</span> ( <span class="name">*</span> n (<span class="name">factorial</span> (<span class="name">-</span> n <span class="number">1</span>))) )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>根据 <a href="/pages/sicp/sicp%20%E7%AB%A0%E8%8A%821.html/../sicp%20%E7%AB%A0%E8%8A%821.html#115-the-substitution-model-for-procedure-application">1.1.5 The Substitution Model for Procedure Application</a> 中所讲的，上述程序展开的计算过程为如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/%E6%88%AA%E5%B1%8F2024-08-11%2015.12.37.png" alt="" /></p><h5 id="迭代结构"><a class="markdownIt-Anchor" href="#迭代结构"></a> 迭代结构</h5><p>我们可以换个顺序计算阶乘, 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始乘，直到乘到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> ，计算的程序为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name">factorial-iter</span> <span class="number">1</span> <span class="number">1</span> n)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">factorial-iter</span> res now max-iter-count)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">=</span> now max-iter-count) (<span class="name">*</span> res now) ( <span class="name">factorial-iter</span> (<span class="name">*</span> res now) (<span class="name">+</span> now <span class="number">1</span>) max-iter-count ) )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>这个程序的展开计算过程为:</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240811152242.png" alt="" /></p><p>可以看出，计算同一个数学公式，上面两种的计算过程完全不同。</p><p>对于递归结构，它的表现是一种展开又收缩的过程，展开表现为程序构建了一系列的 “deferred operations”，收缩表现为在完全展开后这些运算的实际计算过程，解释器在计算的时候需要存储这些运算过程。在计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> 的时候，存储的表达式随着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 线性增长，这被称为线性递归结构。</p><p>与之相对应的，第二种计算过程为迭代计算结构，可看出，解释器并不需要保存运算的过程，需要保存的是变量 <code>res now max-iter-count</code> 。一般来说，<strong>迭代计算过程就是那种可以使用固定变量表达计算状态的过程，同时它还有一个从当前状态转移到下一个状态的过程，还有一个表达式表达这个计算过程何时终止</strong>。在计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> 的时候，计算的表达式随着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 线性增长，这种被称为线性迭代结构。</p><p>tips: 本章练习可以使用 <a href="https://docs.racket-lang.org/reference/debugging.html#(part._.Tracing)">trace</a> 打印计算过程。</p><h4 id="122-tree-recursion"><a class="markdownIt-Anchor" href="#122-tree-recursion"></a> 1.2.2 Tree Recursion</h4><p>本小节通过计算斐波那契数列介绍树形递归结构，斐波那契数列为如下数列:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">0,1,1,2,3,5,8,\dots </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span></p><p>满足如下定义:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>F</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>F</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>F</mi><mi>n</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo>≥</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{aligned}F_0 &amp;= 0 \\ F_1 &amp;= 1 \\ F_n &amp;= F_{n-1} + F_{n-2} (n \ge 2 )\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>它的对应程序为</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">fib</span> n)</span><br><span class="line">  (<span class="name">cond</span></span><br><span class="line">    [(<span class="name">=</span> n <span class="number">0</span>) <span class="number">0</span>]</span><br><span class="line">    [(<span class="name">=</span> n <span class="number">1</span>) <span class="number">1</span>]</span><br><span class="line">    [else (<span class="name">+</span> (<span class="name">fib</span> (<span class="name">-</span> n <span class="number">1</span>)) (<span class="name">fib</span> (<span class="name">-</span> n <span class="number">2</span>)))]))</span><br></pre></td></tr></table></figure><p>它的对应计算过程为:</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240811164246.png" alt="" /></p><p>从计算图中可以看出，树形递归结构有许多冗余的计算，像 fib 2 就计算了三次。为了减少这种计算，我们可以使用一些变量存储当前计算的状态，下面的计算斐波那契数列的迭代结构:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">fib</span> n)</span><br><span class="line">  (<span class="name">fib-iter</span> <span class="number">0</span> <span class="number">1</span> n))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">fib-iter</span> now next count)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">=</span> count <span class="number">0</span>) now (<span class="name">fib-iter</span> next (<span class="name">+</span> now next) (<span class="name">-</span> count <span class="number">1</span>))))</span><br></pre></td></tr></table></figure><p>显然，这种方式计算 fib n 的时间复杂度是 O(n) 的。尽管后一种结构相较于第一种结构速度更优，但第一种是最直观的，迭代法 (动态规划) 的关键在于找到能够代表当前状态的一组变量，这往往是比较难想到的，书中之后就给了个分钱币的例子，使用树形递归能够很容易写出问题的递归形式，但迭代形式却相对困难，书中作为思考题。<a href="https://github.com/tianyicui/pack/blob/master/V2.pdf">背包问题</a>太基础了就不说了，跳过。</p><h4 id="123-orders-of-growth"><a class="markdownIt-Anchor" href="#123-orders-of-growth"></a> 1.2.3 Orders of Growth</h4><p>这章讲的是什么是时间复杂度，跳过吧</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240818152308.png" alt="" /></p><p>后面几节基本是在介绍一些基础的算法。</p><h4 id="124-exponentiation"><a class="markdownIt-Anchor" href="#124-exponentiation"></a> 1.2.4 Exponentiation</h4><p>介绍快速幂，跳了</p><h4 id="125-greatest-common-divisors"><a class="markdownIt-Anchor" href="#125-greatest-common-divisors"></a> 1,2.5 Greatest Common Divisors</h4><p>介绍计算最大公约数的方法，经典的 Euclid’s Algorithm，其中简略地提到了时间复杂度的证明方法：</p><h4 id="126-example-testing-for-primality"><a class="markdownIt-Anchor" href="#126-example-testing-for-primality"></a> 1.2.6 Example: Testing for Primality</h4><p>介绍素数检测的方法，根号下遍历 和 费马测试(这玩意写不写呢…)，</p><h3 id="13-formulating-abstractions-with-higher-order-procedures"><a class="markdownIt-Anchor" href="#13-formulating-abstractions-with-higher-order-procedures"></a> 1.3 Formulating Abstractions with Higher-Order Procedures</h3><p>在经过了一系列算法的洗礼后，我们需要换换口味，来了解一些更加偏向 <a href="https://en.wikipedia.org/wiki/Programming_language_theory">pl</a> 的知识。本节介绍的是对过程使用高阶函数进行抽象。(高阶函数本质就是能够接受函数作为参数的函数)</p><h4 id="131-procedures-as-arguments"><a class="markdownIt-Anchor" href="#131-procedures-as-arguments"></a> 1.3.1 Procedures as Arguments</h4><p>本节首先提出了一个场景: 计算 从 a 到 b 的和、平方和、指定序列和。常规来说可以写出如下代码:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">sum-integers</span> a b)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> a b) </span><br><span class="line">      <span class="number">0</span> </span><br><span class="line">      (<span class="name">+</span> a (<span class="name">sum-integers</span> (<span class="name">+</span> a <span class="number">1</span>) b))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum-cubes</span> a b)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> a b) </span><br><span class="line">      <span class="number">0</span> </span><br><span class="line">      (<span class="name">+</span> (<span class="name">cube</span> a) </span><br><span class="line">         (<span class="name">sum-cubes</span> (<span class="name">+</span> a <span class="number">1</span>) b))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">pi-sum</span> a b)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> a b)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name">+</span> (<span class="name">/</span> <span class="number">1.0</span> (<span class="name">*</span> a (<span class="name">+</span> a <span class="number">2</span>))) </span><br><span class="line">         (<span class="name">pi-sum</span> (<span class="name">+</span> a <span class="number">4</span>) b))))</span><br></pre></td></tr></table></figure><p>显然，这些代码除了函数名和内部计算函数不同之外，其余的几乎没有区别，我们可以从数学的角度上看待这些过程: 数学上，对于 a 到 b 的求和可以表示为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mi>a</mi></mrow><mi>b</mi></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{n=a}^{b} f(n) = f(a) + \dots + f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.086118em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.836113em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span></p><p>其中 f(n) 就是可以替换的函数。</p><p>对与如上的过程，我们可以写出如下的函数:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">sum</span> term a next b)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> a b)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name">+</span> (<span class="name">term</span> a)</span><br><span class="line">         (<span class="name">sum</span> term (<span class="name">next</span> a) next b))))</span><br></pre></td></tr></table></figure><p>于是如上的过程可以被写成:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">inc</span> n) (<span class="name">+</span> n <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">identity</span> x) x)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum-integers</span> a b)</span><br><span class="line">  (<span class="name">sum</span> identity a inc b))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum-cubes</span> a b)</span><br><span class="line">  (<span class="name">sum</span> cube a inc b))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="132-constructing-procedures-using-lambda"><a class="markdownIt-Anchor" href="#132-constructing-procedures-using-lambda"></a> 1.3.2 Constructing Procedures Using <code>Lambda</code></h4><p>介绍 lisp 匿名函数还有使用 let 创建局部变量，用于简化高阶函数的输入。</p><h4 id="133-procedures-as-general-methods"><a class="markdownIt-Anchor" href="#133-procedures-as-general-methods"></a> 1.3.3 Procedures as General Methods</h4><h4 id="134-procedures-as-returned-values"><a class="markdownIt-Anchor" href="#134-procedures-as-returned-values"></a> 1.3.4 Procedures as Returned Values</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;题解: &lt;a href=&quot;https://github.com/booiris/SICP-learning/tree/master/exercise_1&quot;&gt;SICP-learning/exercise_1 at master · booiris/S</summary>
      
    
    
    
    <category term="sicp" scheme="https://booiris.space/categories/sicp/"/>
    
    
    <category term="sicp" scheme="https://booiris.space/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>rust 反序列化时的 zero copy</title>
    <link href="https://booiris.space/pages/blog/rust%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E7%9A%84%20zero%20copy.html"/>
    <id>https://booiris.space/pages/blog/rust%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E7%9A%84%20zero%20copy.html</id>
    <published>2024-05-27T04:43:45.000Z</published>
    <updated>2024-05-28T05:22:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240528130113.png" alt="" /></p><p><a href="https://manishearth.github.io/blog/2022/08/03/zero-copy-1-not-a-yoking-matter/">Not a Yoking Matter (Zero-Copy #1) - In Pursuit of Laziness</a></p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240528125002.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240528130113.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://manishearth.github.io/bl</summary>
      
    
    
    
    <category term="blog" scheme="https://booiris.space/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 rust 游玩 cf 的姿势</title>
    <link href="https://booiris.space/pages/blog/%E4%BD%BF%E7%94%A8%20rust%20%E6%B8%B8%E7%8E%A9%20cf%20%E7%9A%84%E5%A7%BF%E5%8A%BF.html"/>
    <id>https://booiris.space/pages/blog/%E4%BD%BF%E7%94%A8%20rust%20%E6%B8%B8%E7%8E%A9%20cf%20%E7%9A%84%E5%A7%BF%E5%8A%BF.html</id>
    <published>2024-03-15T13:36:47.000Z</published>
    <updated>2024-03-24T10:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cf-是什么"><a class="markdownIt-Anchor" href="#cf-是什么"></a> cf 是什么</h2><p>具体来说就是</p><blockquote><p><s>穿越火线是一款非常受欢迎的第一人称射击网络游戏，它也被称作&quot;CrossFire&quot;。它最早由韩国SmileGate公司开发，后来在中国由腾讯公司运营。这个游戏在中国有着庞大的玩家基础，在亚洲其他地区以及全球也有相当多的粉丝。</s></p><p><s>游戏提供了多种模式，包括经典的团队对战、爆破模式、生化模式等。玩家能选择成为全球反恐精英的一员，或者加入恐怖分子阵营。在游戏中，玩家可以购买和升级各种武器装备，与队友协同作战，完成不同的任务和挑战。</s></p></blockquote><blockquote><p>Codeforces 是一个在线编程和算法竞赛平台，广受全球程序员和算法爱好者的欢迎。它提供了一个平台，用户可以通过参加定期举办的编程比赛来提高自己的编程技能和算法知识。这些比赛通常分为几个不同的难度等级，适合从初学者到高级程序员的各个水平。</p><p>在Codeforces上，参赛者需要在限定时间内解决一系列编程问题。这些问题覆盖了数据结构、算法、数学、字符串处理、图论等众多领域。参赛者的表现根据解决问题的速度和正确性来评分，并在全球范围内进行排名。 – chatgpt 生成</p></blockquote><p>网站: <a href="https://codeforces.com/">Codeforces</a></p><h2 id="rust-是什么"><a class="markdownIt-Anchor" href="#rust-是什么"></a> rust 是什么</h2><p>具体来说就是</p><blockquote><p><s>《Rust》是一款多人生存游戏，玩家需收集资源，建造庇护所，与环境和其他玩家互动以求生存。游戏以其开放世界、真实的生存挑战和玩家之间的复杂互动闻名。</s></p></blockquote><blockquote><p>Rust是一种开源的系统编程语言，以安全性、速度和并发性为设计目标。它旨在帮助开发者构建高效、可靠的软件，同时避免常见的内存安全错误，如缓冲区溢出。Rust通过一套严格的编译时检查机制实现这些目标，而无需依赖于传统的垃圾回收机制或大量的运行时检查。</p><p>Rust的设计充分考虑了现代硬件的特性，提供了零成本抽象、安全的并发编程模型，以及对内存布局的精细控制。这些特性使Rust成为开发操作系统、游戏引擎、浏览器组件以及需要高性能和高可靠性的应用程序的理想选择。 – chatgpt 生成</p></blockquote><p>网站: <a href="https://www.rust-lang.org/">Rust Programming Language</a></p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>rust 标准库只提供了一些基本和常用的数据结构和一套&quot;抽象特性&quot;(或者说规范)，所以可能需要手动造一些轮子，比如处理输入和随机数生成等等，下面将介绍对应的实现代码。</p><h3 id="处理输入"><a class="markdownIt-Anchor" href="#处理输入"></a> 处理输入</h3><p>相较于 c++ 的 <code>scanf</code> 、<code>cin</code> ，rust 的标准库中缺少一种方便地从标准输入中读取并构造数据的方法，网上也存在一些讨论:</p><ol><li><a href="https://users.rust-lang.org/t/why-is-it-so-difficult-to-get-user-input-in-rust/27444/11">Why is it so difficult to get user input in Rust? - help - The Rust Programming Language Forum</a></li><li><a href="https://www.reddit.com/r/rust/comments/ifpi8p/why_is_it_so_painful_to_read_user_inputs_in_rust/">Why is it so painful to read user inputs in Rust</a></li></ol><p>所以使用 rust 解决 codeforces 中的问题所遇到的第一个困难就是如何处理输入，所幸的是这个问题在<a href="https://codeforces.com/blog/entry/67391">这里</a>有所讨论，具体的解决方法参考这个<a href="https://codeforces.com/blog/entry/67391?#comment-516341">回复</a>。根据讨论中的代码修改，笔者使用的模板代码如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Scanner</span>&lt;B&gt; &#123;</span><br><span class="line">    reader: B,</span><br><span class="line">    buf_str: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    buf_iter: std::<span class="type">str</span>::SplitWhitespace&lt;<span class="symbol">&#x27;static</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;B: BufRead&gt; Scanner&lt;B&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(reader: B) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            reader,</span><br><span class="line">            buf_str: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            buf_iter: <span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">split_whitespace</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sc</span>&lt;T: std::<span class="type">str</span>::FromStr&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(token) = <span class="keyword">self</span>.buf_iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> token.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">ok</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed parse&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.buf_str.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">            <span class="keyword">self</span>.reader</span><br><span class="line">                .<span class="title function_ invoke__">read_until</span>(<span class="string">b&#x27;\n&#x27;</span>, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.buf_str)</span><br><span class="line">                .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed read&quot;</span>);</span><br><span class="line">            <span class="keyword">self</span>.buf_iter = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">slice</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8_unchecked</span>(&amp;<span class="keyword">self</span>.buf_str);</span><br><span class="line">                std::mem::<span class="title function_ invoke__">transmute</span>(slice.<span class="title function_ invoke__">split_whitespace</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> IN: *<span class="keyword">mut</span> Scanner&lt;StdinLock&lt;<span class="symbol">&#x27;static</span>&gt;&gt; = std::ptr::<span class="title function_ invoke__">null_mut</span>();</span><br><span class="line"><span class="meta">#[allow(unused_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> i &#123;</span><br><span class="line">    () =&gt; &#123;&#123;</span><br><span class="line">        i!(<span class="type">i32</span>)</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    ($t:ty) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*IN).sc::&lt;$t&gt;() &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="comment">// 需要首先初始化全局的读入器。</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        IN = <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Scanner::<span class="title function_ invoke__">new</span>(io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">lock</span>()))) <span class="keyword">as</span> *<span class="keyword">mut</span> Scanner&lt;StdinLock&lt;<span class="symbol">&#x27;_</span>&gt;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = i!(<span class="type">String</span>); <span class="comment">// 从标准输入中读入一个 string。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = i!();    <span class="comment">//  默认读入的类型为 i32。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面大致解释一下代码的实现，首先核心的是一个名为 <code>Scanner</code> 的结构体，其中的 <code>Reader</code> 保存了数据的来源，它是一个 trait ，可以认为是任意实现了 <code>std::io::BufRead</code> 这一&quot;规范&quot;的结构体。具体到本代码则为标准输入流。<code>buf_str</code> 则是用于储存从 reader 中获取的数据(每次以行为单位读取数据)。<code>buf_iter</code> 用于解析和迭代遍历行内的数据。</p><p>一个读入的过程为: 从 <code>Reader</code> 中根据换行符为分隔读取数据，保存到 <code>buf_str</code> 中，然后根据空白符做切分保存到 <code>buf_iter</code> 中，然后对每一块做解析转换成需要的格式。</p><p>在之后是一个宏，用于优化使用体验。然而一定会使用到全局变量，rust 中对于全局变量的使用较为繁琐，这里采用两种方法:</p><ol><li>使用全局裸指针，使用 <code>box::leak</code> 将读取器内存泄漏，然后将裸指针指向这块内存进行调用，不过这个需要用到 unsafe ，由于 codeforces 算法都为单线程，所以不用考虑并发问题，所以这个 unsafe 是可控的。</li><li>使用 <code>RefCell</code> 获取内部可变性。</li></ol><p>通常来说，应该是使用全局裸指针性能更好，因为 <code>RefCell</code> 会在运行期进行借用检测。但经测试两者的性能差距不明显，所以读者自行选择。</p><p><a href="https://gist.github.com/booiris/68b0def25da4d820b52a65bebe3017eb">全局读取器使用裸指针和 refcell 性能测试 · GitHub</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RefCell 方式的全局变量</span></span><br><span class="line">thread_local! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> STDIN: std::cell::RefCell&lt;Scanner&lt;StdinLock&lt;<span class="symbol">&#x27;static</span>&gt;&gt;&gt; =</span><br><span class="line">    std::cell::RefCell::<span class="title function_ invoke__">new</span>(Scanner::<span class="title function_ invoke__">new</span>(io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">lock</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> safe_i &#123;</span><br><span class="line">    () =&gt; &#123;&#123;</span><br><span class="line">        safe_i!(<span class="type">i32</span>)</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    ($t:ty) =&gt; &#123;</span><br><span class="line">        STDIN.<span class="title function_ invoke__">with</span>(|r| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = r.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">            r.sc::&lt;$t&gt;()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>除了上面的解决方式之外，讨论中还出现了一种<a href="https://codeforces.com/blog/entry/67391?#comment-515870">解决方式</a>，具体实现原理基本上和 c++ 的<a href="https://oi-wiki.org/contest/io/#%E8%AF%BB%E5%85%A5%E4%BC%98%E5%8C%96">快读方式</a>相似，然后通过把快读封装成 trait，给基本类型使用宏实现快读的 trait 实现数据的读入。理论上这种读取方式应该更快，请读者自行取用。</p><h3 id="处理输出"><a class="markdownIt-Anchor" href="#处理输出"></a> 处理输出</h3><p>对于输出也需要特殊处理一下，使用普通的 <code>println!</code> 宏可能会导致输出时间过长导致超时。原因是<a href="https://doc.rust-lang.org/std/macro.println.html">每次调用 <code>println!</code> 的时候都会给标准输出上锁</a>。遇到需要许多输出的题目可能会因为频繁上锁解锁导致输出时间过长。</p><p><code>println!</code> 的注释中也提到可以使用 <code>writeln!</code> 宏进行输出。对于输出加锁导致变慢的问题可以使用缓冲区解决。将输出保存到缓冲区中，最后调用 <code>flush!</code> 将缓冲区的内容写入输出流，这样就减少了加锁解锁的时间，实现了快速输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> OUT: *<span class="keyword">mut</span> std::io::BufWriter&lt;std::io::StdoutLock&lt;<span class="symbol">&#x27;_</span>&gt;&gt; = std::ptr::<span class="title function_ invoke__">null_mut</span>();</span><br><span class="line"><span class="meta">#[allow(unused_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> w &#123;</span><br><span class="line">    ($fmt:expr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123; <span class="built_in">write!</span>(*OUT, <span class="string">&quot;&#123;&#125;&quot;</span>, $fmt);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ($fmt:expr, $($args:tt)*) =&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;  <span class="built_in">write!</span>(*OUT, $fmt, $($args)*);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> wln &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123; <span class="built_in">writeln!</span>(*OUT);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ($fmt:expr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123; <span class="built_in">writeln!</span>(*OUT, <span class="string">&quot;&#123;&#125;&quot;</span>, $fmt);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ($fmt:expr, $($args:tt)*) =&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;  <span class="built_in">writeln!</span>(*OUT, $fmt, $($args)*);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> flush &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            (*OUT).<span class="title function_ invoke__">flush</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    OUT = <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(io::BufWriter::<span class="title function_ invoke__">new</span>(io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">lock</span>())))</span><br><span class="line">            <span class="keyword">as</span> *<span class="keyword">mut</span> std::io::BufWriter&lt;std::io::StdoutLock&lt;<span class="symbol">&#x27;_</span>&gt;&gt;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">    wln!();    <span class="comment">// 输出 \n</span></span><br><span class="line">    wln!(a);  <span class="comment">// 输出 1\n</span></span><br><span class="line">    w!(a);    <span class="comment">//  输出 1</span></span><br><span class="line">    wln!(<span class="string">&quot;test: &#123;&#125;&quot;</span>,a); <span class="comment">// 输出 test: 1\n </span></span><br><span class="line">    flush!(); <span class="comment">// 因为全局变量已经主动泄露，所以最后不会自动 drop ，最后需要手动调用 flush 将数据由缓冲区输入到标准输出流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对应输出器的全局变量也有两种写法，一种 <code>static mut</code> 的全局变量，一种是 <code>Refcell</code> ，这里作为思考题请读者自行实现。</p><h3 id="处理随机数"><a class="markdownIt-Anchor" href="#处理随机数"></a> 处理随机数</h3><p>同样的，rust 的 std 中没有随机数库，需要自己手动造一下轮子。代码来源不可考了，贴一下原始的论文吧：</p><p><a href="http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf">vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rand</span> &#123;</span><br><span class="line">    s: [<span class="type">u64</span>; <span class="number">4</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rand</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(<span class="keyword">mut</span> state: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> PHI: <span class="type">u64</span> = <span class="number">0x9e3779b97f4a7c15</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">seed</span> = &lt;[<span class="type">u64</span>; <span class="number">4</span>]&gt;::<span class="title function_ invoke__">default</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">chunk</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> seed &#123;</span><br><span class="line">            state = state.<span class="title function_ invoke__">wrapping_add</span>(PHI);</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span> = state;</span><br><span class="line">            z = (z ^ (z &gt;&gt; <span class="number">30</span>)).<span class="title function_ invoke__">wrapping_mul</span>(<span class="number">0xbf58476d1ce4e5b9</span>);</span><br><span class="line">            z = (z ^ (z &gt;&gt; <span class="number">27</span>)).<span class="title function_ invoke__">wrapping_mul</span>(<span class="number">0x94d049bb133111eb</span>);</span><br><span class="line">            z = z ^ (z &gt;&gt; <span class="number">31</span>);</span><br><span class="line">            *chunk = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; s: seed &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">next_u32</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.<span class="title function_ invoke__">next_u64</span>() &gt;&gt; <span class="number">32</span>) <span class="keyword">as</span> <span class="type">u32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">next_u64</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result_plusplus</span> = <span class="keyword">self</span>.s[<span class="number">0</span>]</span><br><span class="line">            .<span class="title function_ invoke__">wrapping_add</span>(<span class="keyword">self</span>.s[<span class="number">3</span>])</span><br><span class="line">            .<span class="title function_ invoke__">rotate_left</span>(<span class="number">23</span>)</span><br><span class="line">            .<span class="title function_ invoke__">wrapping_add</span>(<span class="keyword">self</span>.s[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t</span> = <span class="keyword">self</span>.s[<span class="number">1</span>] &lt;&lt; <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">self</span>.s[<span class="number">2</span>] ^= <span class="keyword">self</span>.s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">self</span>.s[<span class="number">3</span>] ^= <span class="keyword">self</span>.s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">self</span>.s[<span class="number">1</span>] ^= <span class="keyword">self</span>.s[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">self</span>.s[<span class="number">0</span>] ^= <span class="keyword">self</span>.s[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">self</span>.s[<span class="number">2</span>] ^= t;</span><br><span class="line">        <span class="keyword">self</span>.s[<span class="number">3</span>] = <span class="keyword">self</span>.s[<span class="number">3</span>].<span class="title function_ invoke__">rotate_left</span>(<span class="number">45</span>);</span><br><span class="line">        result_plusplus</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用随机化算法的题目不是特别多，具体使用方法请看如下示例:</p><p><a href="https://codeforces.com/contest/1310/submission/252682933">Submission #252682933 - Codeforces</a></p><h3 id="图模板"><a class="markdownIt-Anchor" href="#图模板"></a> 图模板</h3><p>图的表示一般为邻接表和邻接矩阵。对于邻接矩阵注意如果能用定长数组就用定长数组。而对于邻接表的数据存储可以有两种方式，一种是放在 struct 中，每次创建的时候都分配一次内存，或者将数据存储再全局变量中，动态地扩展长度。从性能测试的结果也能看出后面一种方式是更快的，由于算法题中不涉及到并发问题，所以操作全局变量是安全的，所以请尽情地使用 unsafe 吧(</p><p><a href="https://gist.github.com/booiris/cf5cc7dbec64051e62244ca9143e8a5d">图结构性能测试 · GitHub</a></p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/rust_cf_2.svg" alt="" /></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PathType</span> &#123;</span><br><span class="line">    from: <span class="type">usize</span>,</span><br><span class="line">    to: <span class="type">usize</span>,</span><br><span class="line">    v: <span class="type">i64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">PathType</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.from, <span class="keyword">self</span>.to, <span class="keyword">self</span>.v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> PATHS: <span class="type">Vec</span>&lt;PathType&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> POINT: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> start_from: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(p_size: <span class="type">usize</span>, start_from: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Graph &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            PATHS.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">            POINT.<span class="title function_ invoke__">reserve</span>((p_size + start_from).<span class="title function_ invoke__">saturating_sub</span>(POINT.<span class="title function_ invoke__">capacity</span>()));</span><br><span class="line">            POINT.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">            POINT.<span class="title function_ invoke__">resize_with</span>(p_size + start_from, || <span class="built_in">vec!</span>[]);</span><br><span class="line">        &#125;</span><br><span class="line">        Graph &#123; start_from &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_path</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, from: <span class="type">usize</span>, to: <span class="type">usize</span>, v: <span class="type">i64</span>) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            POINT[from].<span class="title function_ invoke__">push</span>(PATHS.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            PATHS.<span class="title function_ invoke__">push</span>(PathType &#123; from, to, v &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_bi_path</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, from: <span class="type">usize</span>, to: <span class="type">usize</span>, v: <span class="type">i64</span>) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            POINT[from].<span class="title function_ invoke__">push</span>(PATHS.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            PATHS.<span class="title function_ invoke__">push</span>(PathType &#123; from, to, v &#125;);</span><br><span class="line">            POINT[to].<span class="title function_ invoke__">push</span>(PATHS.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            PATHS.<span class="title function_ invoke__">push</span>(PathType &#123;</span><br><span class="line">                from: to,</span><br><span class="line">                to: from,</span><br><span class="line">                v,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>, now_p: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = &amp;<span class="symbol">&#x27;_</span> PathType&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; POINT[now_p].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(<span class="keyword">move</span> |x| PATHS.<span class="title function_ invoke__">get_unchecked</span>(*x)) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">now_p</span> <span class="keyword">in</span> <span class="keyword">self</span>.start_from..POINT.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125; -- &quot;</span>, now_p);</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">path</span> <span class="keyword">in</span> <span class="keyword">self</span>.<span class="title function_ invoke__">get</span>(now_p) &#123;</span><br><span class="line">                    <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125; &quot;</span>, path)?</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">writeln!</span>(f)?</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法参见:</p><p><a href="https://codeforces.com/contest/1929/submission/252942104">Submission #252942104 - Codeforces</a></p><h3 id="柯里化"><a class="markdownIt-Anchor" href="#柯里化"></a> 柯里化</h3><p>柯里化在算法题中使用不多，大部分作用都是为了保存局部变量，用于传递给函数(由于 rust 不鼓励使用全局变量，所以容易导致传递较多的变量)。当然这种功能也能使用闭包实现，就请读者自行取用吧。使用方法参见:</p><p><a href="https://codeforces.com/contest/1933/submission/252806831">Submission #252806831 - Codeforces</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> <span class="title function_ invoke__">curry2</span> (</span><br><span class="line">    ($f:expr) =&gt; &#123;</span><br><span class="line">        |a| <span class="keyword">move</span> |b|  $<span class="title function_ invoke__">f</span>(a, b)</span><br><span class="line">    &#125;;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> <span class="title function_ invoke__">curry3</span> (</span><br><span class="line">    ($f:expr) =&gt; &#123;</span><br><span class="line">        |a| <span class="keyword">move</span> |b| <span class="keyword">move</span> |c| $<span class="title function_ invoke__">f</span>(a, b, c)</span><br><span class="line">    &#125;;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 源自 Rust 如何实现柯里化？ - Spore的回答 - 知乎</span></span><br><span class="line"><span class="comment">// https://www.zhihu.com/question/437123518/answer/1655807344</span></span><br></pre></td></tr></table></figure><p>至此，请愉快地使用 rust <s>受苦</s>玩耍吧(</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cf-是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cf-是什么&quot;&gt;&lt;/a&gt; cf 是什么&lt;/h2&gt;
&lt;p&gt;具体来说就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;s&gt;穿越火线是一款非常受欢迎的第一人称射击网络游戏，它也被称作&amp;</summary>
      
    
    
    
    <category term="blog" scheme="https://booiris.space/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>为啥 go 不支持泛型方法</title>
    <link href="https://booiris.space/pages/blog/%E4%B8%BA%E5%95%A5%20go%20%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.html"/>
    <id>https://booiris.space/pages/blog/%E4%B8%BA%E5%95%A5%20go%20%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.html</id>
    <published>2024-02-20T14:10:20.000Z</published>
    <updated>2024-06-23T16:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>众所周知， go 的泛型并不完善，由于其不支持 <code>parameterized methods</code> (泛型方法)，导致其无法实现 monad、流式调用等等操作。在这个 issue 中 <a href="https://github.com/golang/go/issues/49085">proposal: spec: allow parameterized methods in methods · Issue #49085 · golang/go · GitHub</a> 有着充分的讨论，本文旨在对其中的讨论进行总结(加一点<s>指指点点</s>)，找出 go 是 xx 的原因，如有错误恳请斧正。</p><h2 id="有点长的前置知识"><a class="markdownIt-Anchor" href="#有点长的前置知识"></a> 有点长的前置知识…</h2><p>在看 issue 之前，首先介绍一下泛型的通常实现方式，一般有如下几种方式</p><ol><li><strong>类型擦除+虚函数表</strong>: 这是 Java 泛型的实现方式。在编译时，泛型类型信息会被擦除，所有的泛型被转换为基类 Object (在 go 中相当于将所有的类型变成 interface{} )，编译器同时会在必要时插入类型转换代码来确保类型安全。</li><li><strong>模板实例化</strong>: C++ 使用模板来实现泛型。在编译时，模板会生成对应于每种具体类型的实例化代码。如 <code>T add(T a, T b) </code> 的泛型方法，对于 <code>add(1,2)</code> 和 <code>add(1.0,2.0)</code> 会生成两个函数 <code>int add(int a, int b)</code> 和 <code>double add( double a, double b)</code> 。</li><li><strong>即时编译</strong>: <a href="https://hackernoon.com/how-generics-differ-in-java-and-c">How Generics Differ in Java and C# | HackerNoon</a>, <a href="https://zhuanlan.zhihu.com/p/348761322">C#泛型详解 - 知乎</a>, <a href="https://stackoverflow.com/questions/31876372/what-is-reification">c# - What is reification? - Stack Overflow</a>，从这些链接可以大致看出，c# 的泛型实现是编译时使用占位符表示泛型类型，然后在运行时动态实例化各种类型。</li></ol><p>回到 go 的泛型，实际上 go 的泛型实现方式有三种提案，下面分别介绍这三种提案，有助于后续对 issue 中的讨论进行分析。(本来想简单写写的，写着写着太长了，不想看的请跳至 <a href="/pages/blog/%E4%B8%BA%E5%95%A5%20go%20%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.html/../%E4%B8%BA%E5%95%A5%20go%20%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.html#%E6%AD%A3%E6%96%87">正文</a> 部分)</p><h3 id="stenciling"><a class="markdownIt-Anchor" href="#stenciling"></a> Stenciling</h3><p><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-stenciling.md">Generics implementation - Stenciling</a></p><p>首先是被称为蜡印(Stenciling) 的实现，实际上这个 c++、rust 的泛型实现方法很相似，都是在编译实例化所有的类型，生成多个对应类型的函数。</p><p>对于如下泛型函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1)</span></span> T2 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在如下两个调用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">float64</span> = f[<span class="type">int</span>, <span class="type">float64</span>](<span class="number">7</span>, <span class="number">8.0</span>)</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">struct</span>&#123;f <span class="type">int</span>&#125; = f[<span class="type">complex128</span>, <span class="keyword">struct</span>&#123;f <span class="type">int</span>&#125;](<span class="number">3</span>, <span class="number">1</span>+<span class="number">1i</span>)</span><br></pre></td></tr></table></figure><p>使用 Stenciling 方法会实例化两个类型函数用于调用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    ... identical bodies ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(x <span class="type">int</span>, y <span class="type">complex128</span>)</span></span> <span class="keyword">struct</span>&#123;f <span class="type">int</span>&#125; &#123;</span><br><span class="line">    ... identical bodies ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于不是 go 泛型的实际实现，所以其中所提到的命名实现、实例化方法、类型约束和重复实例化代码处理就不细说了。具体提一下其中的问题部分。</p><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4><p>对于 Stenciling 方法，提案提出两个问题:</p><ol><li>编译期实例化泛型导致编译时间变长</li><li>编译期实例化泛型导致生成的代码变多，生成的二进制文件变大，有可能导致 instruction cache miss 和 分支预测失效(为啥?)等问题。</li></ol><p>提案末尾中大致提出了使用增量编译减少编译时间、多次调用编译器来去除重复的实例化代码(因为 go 是以包维度进行编译的)等方案。不过这些都不重要，重要的是提案中的一段话:</p><blockquote><p>I suspect there will be lots of cases where sharing is possible, if the underlying types are indistinguishable w.r.t. the garbage collector (same size and ptr/nonptr layout)</p></blockquote><p>提案认为尽管类型可以有很多个(如 <code>int</code> 、<code>type IntAlias = int</code> )，但实际上内存布局都是相同的，相同内存布局的值类型可以共享代码，这就减少了生成的代码大小同时也加快了编译时间。实际上这就是 go 实际的泛型实现(GC Shape Stenciling) 。</p><h3 id="dictionaries"><a class="markdownIt-Anchor" href="#dictionaries"></a> Dictionaries</h3><p><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-dictionaries.md">Generics implementation - Dictionaries</a></p><p>字典(Dictionaries)方式的实现方式正如其名，对于如下泛型函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1)</span></span> T2 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在如下两个调用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">float64</span> = f[<span class="type">int</span>, <span class="type">float64</span>](<span class="number">7</span>, <span class="number">8.0</span>)</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">struct</span>&#123;f <span class="type">int</span>&#125; = f[<span class="type">complex128</span>, <span class="keyword">struct</span>&#123;f <span class="type">int</span>&#125;](<span class="number">3</span>, <span class="number">1</span>+<span class="number">1i</span>)</span><br></pre></td></tr></table></figure><p>那么编译其会实例化<strong>一个</strong>函数，这个函数的第一个参数是一个字典。同时会有多个字典，每个字典包含一些运行时需要的信息，传入的字典内容由调用点生成和传入:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pos1CallSiteDictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">... runtime._type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pos2CallSiteDictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">... runtime._type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span> <span class="params">(type_info dictionary, x <span class="type">int</span>, y T1)</span></span> T2 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dictionary-包含的信息"><a class="markdownIt-Anchor" href="#dictionary-包含的信息"></a> dictionary 包含的信息</h4><p>对于形如 <code>f [T1, T2]</code> 的泛型函数，所需要的信息如下:</p><h5 id="instantiated-types"><a class="markdownIt-Anchor" href="#instantiated-types"></a> Instantiated types</h5><p>首先需要包含函数签名上的类型，可能以如下形式进行存储</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    T1 *runtime._type</span><br><span class="line">    T2 *runtime._type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于打印栈的目的，字典中需要包含未被使用的类型，即即使 T2 没有在函数中用到也需要保存 T2 的类型 (为啥不禁止未使用的泛型类型呢…)。</p><h5 id="derived-types"><a class="markdownIt-Anchor" href="#derived-types"></a> Derived types</h5><p>除了函数签名上的类型，字典中还需要保存函数中派生出的类型，比如泛型函数中如果定义了如下类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123; x <span class="type">int</span>; y T1 &#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>] T1&#123;&#125;</span><br></pre></td></tr></table></figure><p>那么需要保存派生出来的类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    D1 *runtime._type <span class="comment">// struct &#123; x int; y T1 &#125;</span></span><br><span class="line">    D2 *runtime._type <span class="comment">// map[string] T1</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="subdictionaries"><a class="markdownIt-Anchor" href="#subdictionaries"></a> Subdictionaries</h5><p>如果泛型中函数调用了其他的泛型函数，还需要保存对应泛型函数的字典。这样才能接着传递 dictionary 参数，调用对应的泛型函数，提案中称之为子字典:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  func g[T](g T) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">//  in f[T1]: g[T1] (y)</span></span><br><span class="line"><span class="keyword">type</span> dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    S1 *dictionary <span class="comment">// SubDictionary for call to g</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="helper-methods"><a class="markdownIt-Anchor" href="#helper-methods"></a> Helper methods</h5><p>字典中还需要保存泛型类型的操作符，比如对于如下运算:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y2 := y + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> y2 &gt; y &#123; … &#125;</span><br></pre></td></tr></table></figure><p>为了表达泛型操作，需要将其中的 <code>+</code> 和 <code>&gt;</code> 抽象出来变成一种方法保存到字典中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    plus <span class="function"><span class="keyword">func</span><span class="params">(z, x, y *T1)</span></span>      <span class="comment">// does *z = *x+*y</span></span><br><span class="line">    greater <span class="function"><span class="keyword">func</span><span class="params">(x, y *T1)</span></span> <span class="type">bool</span> <span class="comment">// computes *x&gt;*y</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stack-layout"><a class="markdownIt-Anchor" href="#stack-layout"></a> Stack layout</h5><p>因为类型不确定，字典中还需要保存函数中所有非指针类型临时变量的占用空间，用于分配栈空间。而之前提到过，字典是由调用点传入的，因为只有调用点才知道所有的类型，所以在调用点需要计算所需要的栈空间。然后字典中还需要保存每个临时对象在栈内的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    frameSize <span class="type">uintptr</span></span><br><span class="line">    stackObjects []stackObject</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> stackObject <span class="keyword">struct</span> &#123;</span><br><span class="line">    offset <span class="type">uintptr</span></span><br><span class="line">    typ *runtime._type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于泛型函数的嵌套调用也需要特殊处理。对于如下函数调用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1, h <span class="keyword">func</span>(x T1, y <span class="type">int</span>, z T2)</span></span> <span class="type">int</span>) T2 &#123;</span><br><span class="line">    <span class="keyword">var</span> z T2</span><br><span class="line">    ....</span><br><span class="line">    r := h(y, x, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提案中提出了两种方法:</p><ol><li>逐个参数处理</li></ol><p>逐个处理参数，将参数复制到栈上正确的位置:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">argPtr = SP</span><br><span class="line">memmove(argPtr, &amp;y, dictionary.T1.size)</span><br><span class="line">argPtr += T1.size</span><br><span class="line">argPtr = roundUp(argPtr, alignof(<span class="type">int</span>))</span><br><span class="line">*(*<span class="type">int</span>)argPtr = x</span><br><span class="line">argPtr += sizeof(<span class="type">int</span>)</span><br><span class="line">memmove(argPtr, &amp;z, dictionary.T2.size)</span><br><span class="line">argPtr += T2.size</span><br><span class="line">call h</span><br><span class="line">argPtr = roundUp(argPtr, <span class="number">8</span>) <span class="comment">// alignment of return value start</span></span><br><span class="line">r = *(*<span class="type">int</span>)argPtr</span><br></pre></td></tr></table></figure><ol start="2"><li>使用字典存储偏移量</li></ol><p>或者提前计算出调用函数的入参出参在栈上的偏移量，然后保存到字典中，使用的时候根据偏移量复制参数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memmove(SP + dictionary.callsite1.arg1offset, &amp;y, dictionary.T1.size)</span><br><span class="line">*(*<span class="type">int</span>)(SP + dictionary.callsite1.arg2offset) = x</span><br><span class="line">memmove(SP + dictionary.callsite1.arg3offset, &amp;z, dictionary.T2.size)</span><br><span class="line">call h</span><br><span class="line">r = *(*<span class="type">int</span>)(SP + dictionary.callsite1.ret1offset)</span><br></pre></td></tr></table></figure><h5 id="pointer-maps"><a class="markdownIt-Anchor" href="#pointer-maps"></a> Pointer maps</h5><p>需要一个 bitMap 存储入参出参的空间大小和是否是指针类型。用于调用者分配空间入参和出参空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    argPointerMap bitMap <span class="comment">// arg size and ptr/nonptr bitmap</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题-2"><a class="markdownIt-Anchor" href="#问题-2"></a> 问题</h4><p>提案中提到了虽然采用字典方法减少了代码的生成，但是占用的内存变多了（从上面也可以看出一个泛型示例要存储多少信息）。这也出现了 data cache misses 和 instruction cache misses 的替换。需要找一种折中的方法。</p><p>还有提案中提到使用字典方法也有可能导致性能的下降，比如当泛型方法中具体类型为 int 的情况，<code>x=y</code> 的操作在使用蜡印方法可以优化成一次寄存器复制的操作，而使用字典的方法，由于需要处理不同类型的数据，只能使用 <code>memmove</code> 操作复制数据，这无疑是一种额外的开销。</p><h3 id="gc-shape-stenciling"><a class="markdownIt-Anchor" href="#gc-shape-stenciling"></a> GC Shape Stenciling</h3><p><strong>！本节的分析基于提案和 go 1.18，部分信息可能和高版本的 go 有所不同，请注意区分。</strong></p><p><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-gcshape.md">Generics implementation - GC Shape Stenciling</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">proposal/design/generics-implementation-dictionaries-go1.18.md at master · golang/proposal · GitHub</a></p><p>GC Shape Stenciling 是 go 的真正泛型实现。它是 Stenciling 和 Dictionaries 的折中实现。GC Shape 在提案中的解释是:</p><blockquote><p>The <em>GC shape</em> of a type means how that type appears to the allocator / garbage collector.</p></blockquote><p>举例来说 <code>int</code> 和 <code>type IntAlias = int</code> 是属于一个 GC Shape，比较特别的是对于所有的指针类型属于一个 GC Shape，使用虚表进行方法的调用。</p><p>对于每一个 GC Shape，go 会实例化一个具体的代码，具体来说，对于如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T</span> <span class="title">any</span>] <span class="params">(t T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">var</span> x T</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> IntAlias = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f[<span class="type">int</span>](<span class="number">5</span>)</span><br><span class="line">f[MyInt](<span class="number">5</span>)</span><br><span class="line">f[IntAlias](<span class="number">5</span>)</span><br><span class="line">f[*<span class="type">int</span>](<span class="literal">nil</span>)</span><br><span class="line">f[*MyInt](<span class="literal">nil</span>)</span><br><span class="line">f[<span class="keyword">interface</span>&#123;&#125;](<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>下面终于来到 <a href="https://github.com/golang/go/issues/49085">issue</a> 分析环节。</p><p>首先是有人提出由于 go 的泛型不支持 <code>parameterized methods</code>，所以如下代码无法编译:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si *stream[IN])</span></span> Map[OUT any](f <span class="function"><span class="keyword">func</span><span class="params">(IN)</span></span> OUT) stream[OUT]</span><br></pre></td></tr></table></figure><p>这就导致了在 go 中无法实现常规的流式处理方法。提问人也提出如果 go 能支持 <code>parameterized methods</code>，那么某些领域在构造代码的时候会更加简便，例如(举的例子奇奇怪怪的，看着也没用到 <code>parameterized methods</code>):</p><ol><li>testing (?): <code>Assert(actual).ToBe(expected)</code></li><li>mocking (?): <code>On(obj.Sum).WithArgs(7, 8).ThenReturn(15)</code></li></ol><h3 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h3><p>之后有人贴出 go 不支持 <code>parameterized methods</code> 的原因: <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#No-parameterized-methods">parameterized methods Proposal</a>。考虑如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> p1</span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S)</span></span> Identity[T any] (v T) T &#123; <span class="keyword">return</span> v &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p2</span><br><span class="line"><span class="keyword">type</span> HasIdentity <span class="keyword">interface</span> &#123;</span><br><span class="line">Identity[T any] (T) T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p3</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;p2&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckIdentity</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> vi, ok := v.(p2.HasIdentity); ok &#123;</span><br><span class="line"><span class="keyword">if</span> got := vi.Identity[<span class="type">int</span>] (<span class="number">0</span>); got != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p4</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;p1&quot;</span></span><br><span class="line"><span class="string">&quot;p3&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSIdentity</span><span class="params">()</span></span> &#123;</span><br><span class="line">p3.CheckIdentity(p1.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，p1 中的 S 实现了 p2 中的 <code>HasIdentity</code> 接口，在 p3 中有一个函数实现了将入参断言为 <code>HasIdentity</code> 并调用其中的函数的功能。在 p4 中调用了 p3 中的函数并传入了 p1 中定义的 S。</p><p>看着还挺合理，但是问题来了，在 p3 中的 <code>CheckIdentity</code> 在断言完入参后，调用了一个类型为 <code>int</code> 的 <code>Identity</code> 函数。根据上面函数的调用链我们可以知道，它其实是在调用 <code>p1.S.Identity[int]</code>，只需要实例化一个 <code>p1.S.Identity[int]</code> 代码块即可。然而，由于 go 的<strong>大道至简</strong>，类型只有通过 import 才可见，也就是说 p3 是无法感知到 p1.S 这个类型的，所以实例化 <code>p1.S.Identity[int]</code> 也就无从说起了。</p><p>之后提案中给出了三个方案:</p><ol><li>编译器努努力，根据函数的调用链实例化对应的函数。然而由于 go 中的<strong>反射</strong>的存在，在编译期实际上无法确定所有的函数调用链 。(<strong>这个也是我感觉 go 支持 <code>parameterized methods</code> 里最难受的地方</strong>)</li><li>学习 java or C#，运行时实例化，这就导致了 go 需要支持某种 JIT，或者使用基于反射的方法，这些实现起来都十分复杂，而且会导致运行时速度变慢。</li><li>约束 interface 中禁用 <code>parameterized methods</code> ，因为无法感知类型的原因就是 interface 将实际类型信息隐藏了，不过还是存在反射的问题(直接禁止反射调用泛型函数?)：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S)</span></span> Identity[T any] (v T) T &#123; <span class="keyword">return</span> v &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := reflect.TypeOf(S&#123;&#125;).MethodByName(<span class="string">&quot;Identity&quot;</span>)</span><br><span class="line">f.Func.Call([]reflect.Value&#123;reflect.ValueOf(S&#123;&#125;), reflect.ValueOf(<span class="number">0</span>)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我想讲一讲第三点，提案给出的原文是:</p><blockquote><p>Or, we could decide that parameterized methods do not, in fact, implement interfaces, <em>but then it’s much less clear why we need methods at all. If we disregard interfaces, any parameterized method can be implemented as a parameterized function.</em></p></blockquote><p>后面这一段真的是迷惑发言(issue 里有些人也对这段提出疑问)，提案作者认为如果 <code>parameterized methods</code> 不参与 interface 的实现（相当于在 interface 中禁用 <code>parameterized methods</code> 了）, 那为啥还需要 <code>parameterized method</code>，因为所有的 <code>parameterized method</code> 都可以用 <code>parameterized function</code> 实现？？？？</p><p>难不成作者认为 <code>func (S[T]) F[ M, U] ( M ) U</code> 可以简单等效为 <code>func F[T, M, U] (T, M) U</code> ，所以调用方式 <code>x.f(y).g(z)</code> 和 <code>g(f(x,y),z)</code> 没区别 🤔？那 go 语言写起来那么啰嗦的原因找到了(。 具体来说请看这个<a href="https://github.com/golang/go/issues/49085#issuecomment-995993517">评论</a> 和这个<a href="https://github.com/golang/go/issues/49085#issuecomment-1144311517">评论</a>。</p><p>后面作者的补充也很迷惑: <a href="https://github.com/golang/go/issues/49085#issuecomment-1291237249">proposal: spec: allow parameterized methods in methods · Issue #49085 · golang/go · GitHub</a>，不予置评了。</p><h3 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h3><p>由于之后的关于解决泛型方法的问题讨论太长，所以接下来省略部分评论(有些不是关于泛型的讨论)并且根据 issue 里提出的不同解决方案进行分类。</p><h4 id="gava派"><a class="markdownIt-Anchor" href="#gava派"></a> gava派</h4><blockquote><p>I think that the example issue can be approached the same way as Java does: using <code>interface&#123;&#125;</code> behind the scenes and panic if the customer did a bad assignment (also the compiler could warn about the unsafe operation). –<a href="https://github.com/golang/go/issues/49085#issuecomment-986056824">link</a></p></blockquote><blockquote><p>How about using type erasure to handle the generic method issue? –<a href="https://github.com/golang/go/issues/49085#issuecomment-1857277699">link</a></p></blockquote><p>interface 代表一切！不过显然 gava 和 anygo 是不行滴。</p><h4 id="语法糖派投降派"><a class="markdownIt-Anchor" href="#语法糖派投降派"></a> 语法糖派(投降派)</h4><blockquote><p>Maybe add some syntactic sugar like extension methods in C#. –<a href="https://github.com/golang/go/issues/49085#issuecomment-1064889791">link</a></p></blockquote><blockquote><p>Something similar that’s been proposed before and is more explicit and thus feels, at least to me, more Go-like is to add a new operator, such as <code>-&gt;</code> or <code>|&gt;</code>, that chains functions such that <code>a -&gt; f(b, c)</code> is equivalent to <code>f(a, b, c)</code>. That would allow the benefit of a method-like ordering to the execution without needing to actually support methods with extra types or method implementations for interface types. –<a href="https://github.com/golang/go/issues/49085#issuecomment-1278630794">link</a></p></blockquote><blockquote><p>For the solution <a href="https://github.com/golang/go/issues/49085#issuecomment-1464887534">#49085 (comment)</a>, the problem is that functions with <code>infix</code> are different from normal functions, and it may requires to write a function twice to provide both forms. I’d like to have a new way to call a function at the right position of a value, like <a href="https://pkg.go.dev/text/template#hdr-Examples">using <code>|</code></a> in <code>template</code>. So I propose following: –<a href="https://github.com/golang/go/issues/49085#issuecomment-1600571377">link</a></p></blockquote><p>这一派对 go 语言的泛型彻底的妥协，不要求改变目前的泛型现状，只要求添加一个中缀调用的语法糖(不过这个也老早被 go 团队打了回去)。</p><p>在之前提到过，虽然不支持泛型方法 ， <code>func (S[T]) F[ M, U] ( M ) U</code> 也可以由 <code>func F[T, M, U] (T, M) U</code> 替换，但是随之而来的是深层次的调用嵌套，由原本的 <code>x.f(y).g(z)</code> 变成了 <code>g(f(x, y), z)</code> 。如果有一种中缀语法糖 <code>x -&gt; f(y)</code> 表达 <code>f(x,y)</code>，那么 <code>g(f(x, y), z)</code> 就能变成 <code>x -&gt; f(y) -&gt; g(z)</code>，调用嵌套就没有了，流式调用看起来也能写了。(这很难评，加这种晦涩的函数式语法糖不如改进一下泛型)</p><h4 id="xx派想不出名字了"><a class="markdownIt-Anchor" href="#xx派想不出名字了"></a> xx派(想不出名字了)</h4><p>首先因为 go 团队的 less is more 理念，让编译器做分析调用链这么重的活也不太现实（这里也辩解一下，即使调用链分析也无法覆盖反射、传 interface 调用、<a href="https://pkg.go.dev/plugin">插件模式</a>等场景，所以调用链分析是不现实的）。</p><p>但是禁用整个泛型方法也太过极端了，如果只禁用 interface 中的 <code>parameterized methods</code> ，而放过成员方法的 <code>parameterized methods</code> ，我认为有几点好处吧:</p><ol><li>最重要的一点是向下兼容，这种修改没有对 go 的语义有重大改变，同时是大范围约束到小范围约束的过程，不会影响以前的代码运行。</li><li><strong>可以用上 monad and stream call</strong> 。众所周知，合理地使用函数式能够减少临时变量和冗长的代码。有较大概率能减少下图中的代码(什么时候才能看到这张图不吐槽呢。。。)<br /><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/20231224210233.png" alt="" /></li><li>实现起来相对的不是特别复杂(相较于分析调用链来说)，因为泛型结构本身是可以具有方法的，也许可能再支持一个泛型方法相对来说没那么困难?</li></ol><p>以上为笔者个人观点。实际上，这一派为 issue 中大多数人的观点，其中有几位有较深入的讨论，下面对他们的讨论做下分析:</p><h6 id="一"><a class="markdownIt-Anchor" href="#一"></a> 一</h6><blockquote><p>I think this solution makes the most sense. They could then (under the hood) be treated a regular function. The reason why this would be useful is that methods do not only serve the purpose of implementing interfaces; methods also serve as a means of organization for functions that operate on particular structures.<br />It may be a bit of a challenge about how type-parameterized methods would appear in <code>&quot;reflect&quot;</code>, though. – <a href="https://github.com/golang/go/issues/49085#issuecomment-948108705">link</a></p></blockquote><p>把这段话放到第一个的原因是这是第一个提出这一派观点的人，还顺便吐槽了下提案中的 &quot;any parameterized method can be implemented as a parameterized function&quot;😚。</p><h5 id="二"><a class="markdownIt-Anchor" href="#二"></a> 二</h5><blockquote><p>I propose two constraints:</p><ol><li>Generic interfaces must be made “concrete” when used in a type assertion, within a type switch, and when invoking associated methods. By concrete, I mean that all type parameters on the generic interface are specified.</li><li>Types having generic method(s) cannot be typecast to <code>interface&#123;&#125;</code> or a generic interface unless it is an “instantiated generic type”. By instantiated generic type, I mean a type that has one or more generic method instantiations. – <a href="https://github.com/golang/go/issues/49085#issuecomment-1186380446">link</a></li></ol></blockquote><p>对于提案中提出的问题，这位提出了两个约束:</p><ol><li>泛型 interface 断言的时候必须指定具体类型。</li><li>具有泛型方法的类型除非</li></ol><p>在这段讨论中还对反射处理有所补充:</p><blockquote><p>On the reflect package, I propose we simply add a new “<a href="https://go.dev/blog/laws-of-reflection">law of reflection</a>” that says that any compile-time uninstantiated type realizations are unavailable at run-time. –<a href="https://github.com/golang/go/issues/49085#issuecomment-1186380446">link</a></p></blockquote><p>非常简单，就是检查泛型函数是否实例化，没有实例化的函数就是一调一个不吱声(panic 就完事了)。</p><h4 id="反对派"><a class="markdownIt-Anchor" href="#反对派"></a> 反对派</h4><p><a href="https://github.com/golang/go/issues/49085#issuecomment-948191212">proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p><a href="https://github.com/golang/go/issues/49085#issuecomment-952701440">proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p><a href="https://github.com/golang/go/issues/49085#issuecomment-1280087495">proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p><a href="https://github.com/golang/go/issues/49085#issuecomment-1281552328">proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p><a href="https://github.com/golang/go/issues/49085#issuecomment-1290043476">proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>考虑到 go 语言团队已经在泛型实现上已经<a href="https://github.com/golang/go/issues/49085#issuecomment-1290106303">考虑了 10 年</a>达到如今的成就，那么希望 go 团队能在不违反&quot;<a href="https://github.com/golang/go/issues/49085#issuecomment-1291237249">泛型方法在 interface 中的正交性</a>🤗&quot;的约束下在下个 10 年实现泛型方法吧。在此之前，如果各位看官想使用泛型方法，请看下面评论(</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20240228131110.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt; 引言&lt;/h2&gt;
&lt;p&gt;众所周知， go 的泛型并不完善，由于其不支持 &lt;code&gt;parameterized methods&lt;/code&gt; (泛型方法)，导致其无法实</summary>
      
    
    
    
    <category term="blog" scheme="https://booiris.space/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>rust 无栈协程介绍</title>
    <link href="https://booiris.space/pages/blog/rust%20%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B%E4%BB%8B%E7%BB%8D.html"/>
    <id>https://booiris.space/pages/blog/rust%20%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B%E4%BB%8B%E7%BB%8D.html</id>
    <published>2024-01-23T14:59:58.000Z</published>
    <updated>2024-04-27T10:03:46.000Z</updated>
    
    
    
    
    <category term="blog" scheme="https://booiris.space/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>monad 粗浅介绍</title>
    <link href="https://booiris.space/pages/blog/monad%20%E7%B2%97%E6%B5%85%E4%BB%8B%E7%BB%8D.html"/>
    <id>https://booiris.space/pages/blog/monad%20%E7%B2%97%E6%B5%85%E4%BB%8B%E7%BB%8D.html</id>
    <published>2023-12-12T13:20:47.000Z</published>
    <updated>2024-06-18T05:08:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-monad"><a class="markdownIt-Anchor" href="#什么是-monad"></a> 什么是 monad?</h2><p>monad(单子) 是函数式编程中的一种抽象，本文旨在对 monad 的粗浅介绍，所以跳过其数学上的定义和结构性证明(其实是目前笔者也不太懂🤫)，通过一些具体的例子说明它的概念和作用。</p><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p>尽管没有太复杂的数学概念，但还是需要一个定义说明什么样的东西才能称之为 monad。在接下来的说明中，除了列举出数学定义以外，还有其在 go 语言中的具体表现形式。在 wiki 的定义中:</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)#Definition">Monad (functional programming) - Wikipedia</a></p></blockquote><p>一个 monad 包含三个部分:</p><ol><li><p>类型构造子 <code>M</code> 。</p><ul><li>在 go 中可以理解为一种名为 <code>M</code> 包裹着 <code>T</code> 的泛型结构体 <code>M&lt;T&gt;&#123; val: T &#125;</code></li></ul></li><li><p>类型转换子 <code>Unit :: T -&gt; M T</code>。</p><ul><li>在 go 中可以理解为由值 <code>T</code> 构造 <code>M</code> 的函数 <code>func Unit[T any] (val T) -&gt; M&lt;T&gt;</code></li></ul></li><li><p>组合子 <code>&gt;&gt;= or FlatMap :: M T -&gt; ( T -&gt; M U) -&gt; M U</code> 。</p><ul><li>在 go 中可以理解为 <code>M&lt;T&gt;&#123; val: T &#125;</code> 这个结构体具有一个成员方法 <code>func flatMap[T, U any] (func(T) -&gt; M&lt;U&gt;) -&gt; M&lt;U&gt;</code> ，能够接受一个函数参数实现从 <code>M&lt;T&gt;</code> 到 <code>M&lt;U&gt;</code> 的变换。</li></ul></li></ol><p>那么我们可以称这个具有 <code>FlatMap</code> 方法的 <strong>M</strong> 为一个 Monad (请注意不是 M&lt;\T&gt; )。</p><h4 id="更严格的定义"><a class="markdownIt-Anchor" href="#更严格的定义"></a> 更严格的定义</h4><p>一个 monad 还必须含有以下三个约束:</p><ol><li><p>转换子 <code>Unit</code> 是组合子 <code>&gt;&gt;=</code> 的左<a href="https://en.wikipedia.org/wiki/Identity_element">单位元</a>: <code>Unit &gt;&gt;= f &lt;-&gt; f</code> 。</p><ul><li>在 go 中可以理解为：如果有一个函数为 <code>F[ T, U any] (T) M U</code>, 那么 <code>Unit(x).FlatMap(f)</code> 的执行结果和执行 <code>f(x)</code> 结果相同</li></ul></li><li><p>转换子 <code>Unit</code> 是组合子 <code>&gt;&gt;=</code> 的右<a href="https://en.wikipedia.org/wiki/Identity_element">单位元</a>: <code>f &gt;&gt;= Unit &lt;-&gt; f</code></p><ul><li>在 go 中可以理解为：如果有一个函数为 <code>F[ T, U any] (T) M U</code>, <code>F(x).FlatMap(Unit)</code> 的执行结果等于 <code>F(x)</code></li></ul></li><li><p>组合子 <code>&gt;&gt;=</code> 满足结合律: <code>ma &gt;&gt;= λx -&gt; (f(x) &gt;&gt;= λy -&gt; g(y)) &lt;-&gt; (ma &gt;&gt;= λx -&gt; f(x)) &gt;&gt;= λy -&gt; g(y)</code></p><ul><li>在 go 中可以理解为以下两个过程执行结果相等</li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span>[<span class="title">T</span>, <span class="title">U</span> <span class="title">any</span>]<span class="params">(x T)</span></span> M&lt;U&gt;  &#123; f(x) &#125; <span class="comment">// f(x) 是对 x 的一些行为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G</span>[<span class="title">U</span>, <span class="title">P</span> <span class="title">any</span>]<span class="params">(y U)</span></span> M&lt;P&gt; &#123; g(y) &#125; <span class="comment">// g(y) 是对 y 的一些行为</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">H</span>[<span class="title">T</span>, <span class="title">P</span> <span class="title">any</span>]<span class="params">(x T)</span></span> M&lt;P&gt; &#123; F(x).FlatMap(G) &#125; <span class="comment">// g(f(x))</span></span><br><span class="line"></span><br><span class="line">res1 := M&#123;val: x&#125;.FlatMap(H)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span>[<span class="title">T</span>, <span class="title">U</span> <span class="title">any</span>]<span class="params">(x T)</span></span> M&lt;U&gt;  &#123; f(x) &#125; <span class="comment">// f(x) 是对 x 的一些行为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G</span>[<span class="title">U</span>, <span class="title">P</span> <span class="title">any</span>]<span class="params">(y U)</span></span> M&lt;P&gt; &#123; g(y) &#125; <span class="comment">// g(y) 是对 y 的一些行为</span></span><br><span class="line"></span><br><span class="line">res2 := M&#123; val: x &#125;.FlatMap(F).FlatMap(G)</span><br></pre></td></tr></table></figure><h2 id="monad-有什么用"><a class="markdownIt-Anchor" href="#monad-有什么用"></a> monad 有什么用?</h2><p>在列举完 monad 的定义后，为了避免陷在抽象的世界里无法自拔，笔者在接下来会具体列举一些例子说明 monad 的作用 。以笔者的观点来说，monad 的作用就是提供了一种隐藏副作用的形式，使得在编写处理函数的时候只用考虑预期的输入，将副作用延续到最后处理。</p><h3 id="另一个宇宙的-go-error-monad"><a class="markdownIt-Anchor" href="#另一个宇宙的-go-error-monad"></a> 另一个宇宙的 go error monad</h3><h4 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h4><p>在 go 编程中，可能常见如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取要查询的ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetID</span> <span class="params">(<span class="type">int64</span>)</span></span> (<span class="type">int64</span>,<span class="type">error</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 获取 ID 对应的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInfo</span> <span class="params">(id <span class="type">int64</span>)</span></span> (Info,<span class="type">error</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 获取上一个 Info 中 uid 对应的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span> <span class="params">(Info)</span></span> (UserInfo,<span class="type">error</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">rawID := <span class="number">0</span></span><br><span class="line">id, err := GetID(rawID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">info, err := GetInfo(id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line">userInfo, err := GetUserInfo(info)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use userInfo ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 go 的灵魂出现了🤗</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/20231224210233.png" alt="" /></p><p>当然笔者并不反对 go 这种严格处理每个函数返回的错误值的思想，不过本文既然是有关 monad 的介绍，自然是想着怎么将 monad 套用到 go 的错误处理中。</p><h4 id="go-版-monad-式错误处理"><a class="markdownIt-Anchor" href="#go-版-monad-式错误处理"></a> go 版 monad 式错误处理</h4><p>回顾 monad 的定义:</p><ul><li>首先 monad 是一个结构体:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ErrMonad[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">Result T</span><br><span class="line">Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结构体包含了返回值和错误。</p><ul><li>然后需要一个由 <code>T</code> 构造成 <code>M T</code> 的函数:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unit</span>[<span class="title">T</span> <span class="title">any</span>] <span class="params">(result T)</span></span> ErrMonad[T] &#123;</span><br><span class="line"><span class="keyword">return</span> ErrMonad[T]&#123;</span><br><span class="line">Result: result,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>有组合子 <code>FlatMap</code> 成员方法:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h ErrMonad[T])</span></span> FlatMap[U] (mapFunc <span class="function"><span class="keyword">func</span><span class="params">(T)</span></span> ErrMonad[U] ) ErrMonad[U] &#123;</span><br><span class="line"><span class="keyword">if</span> h.err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapFunc(h.result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上述实现后，之前的流程就可以改写为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取要查询的ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetID</span> <span class="params">(<span class="type">int64</span>)</span></span> ErrMonad[<span class="type">int64</span>] &#123;&#125;</span><br><span class="line"><span class="comment">// 获取 ID 对应的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInfo</span> <span class="params">(id <span class="type">int64</span>)</span></span> ErrMonad[Info] &#123;&#125;</span><br><span class="line"><span class="comment">// 获取上一个 Info 中 uid 对应的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span> <span class="params">(Info)</span></span> ErrMonad[UserInfo] &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">rawID := Unit(<span class="type">int64</span>(<span class="number">0</span>))</span><br><span class="line">res := rawID.</span><br><span class="line">FlatMap(GetID).</span><br><span class="line">FlatMap(GetInfo).</span><br><span class="line">FlatMap(GetUserInfo)</span><br><span class="line"><span class="keyword">if</span> res.Err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> res.Err</span><br><span class="line">&#125;</span><br><span class="line">userInfo = res.Result</span><br><span class="line"><span class="comment">// use userInfo ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出相较于之前的版本，代码更简洁了一些 (至少少了 <code>if err != nil &#123; return err &#125;</code>)。</p><p>然而理想是美好的，看着 monad 实现这么简单，为啥群友总说 go 不支持 monad 呢。回看本节标题 “<strong>另一个宇宙</strong>的 go error monad”，非常遗憾的是，目前的 go 不支持<strong>泛型方法参数</strong> <a href="https://go.googlesource.com/proposal/+/master/design/43651-type-parameters.md#no-parameterized-methods">Type Parameters Proposal</a>，<a href="/pages/blog/monad%20%E7%B2%97%E6%B5%85%E4%BB%8B%E7%BB%8D.html/../%E4%B8%BA%E5%95%A5%20go%20%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.html">为啥 go 不支持泛型方法</a>。具体来说就是不支持入参是一个带泛型的方法，即以下函数都是无法实现的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goIsBest</span><span class="params">( <span class="keyword">func</span>[T any] ()</span></span> ) <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GGGGGG[T any] <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(GGGGGG[T])</span></span> gggggggggggg( <span class="function"><span class="keyword">func</span>[<span class="title">U</span> <span class="title">any</span>] <span class="params">()</span></span> ) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(GGGGGG[T])</span></span> gggggggggggg[U any] () &#123;&#125;</span><br></pre></td></tr></table></figure><p>摆个 issue 做参考(希望未来会有解决方法吧):</p><p><a href="https://github.com/golang/go/issues/49085">proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub</a></p><p>这就导致了 <code>FlatMap</code> 方法是不可行的。至此，go 的 monad 之旅到此结束。</p><p>附一篇经典的错误处理方法 blog ( 感觉就像一种青春版的 monad，在所举的例子中存在类型只有 io.Writer，所以只用在单个类型里打转，省略了由 T 类型到 U 类型的转换，所以这种形式可以在 go 中实现:</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/20240118232621.png" alt="" /></p><p><a href="https://go.dev/blog/errors-are-values">Errors are values - Thttps://go.dev/blog/errors-are-valueshe Go Programming Language</a></p><p><a href="https://zhuanlan.zhihu.com/p/548515367">if err != nil 太烦？Go 创始人教你如何对错误进行编程！ - 知乎</a> (<s>评论区</s>)</p><h3 id="monad-如何解决回调地狱"><a class="markdownIt-Anchor" href="#monad-如何解决回调地狱"></a> monad 如何解决回调地狱</h3><p>现在让我们来看看一点<s>老</s>(不新又不老)的东西。</p><h4 id="引言-2"><a class="markdownIt-Anchor" href="#引言-2"></a> 引言</h4><p>各位即使没写过 javascript，也可能听说过<a href="http://callbackhell.com/">回调地狱</a>这个概念，具体来讲这是一种 javascript 异步编程中出现的一种现象。拿<a href="http://callbackhell.com/">Callback Hell</a>中的例子举例吧:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readdir</span>(source, <span class="keyword">function</span> (<span class="params">err, files</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error finding files: &#x27;</span> + err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    files.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">filename, fileIndex</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(filename)</span><br><span class="line">      <span class="title function_">gm</span>(source + filename).<span class="title function_">size</span>(<span class="keyword">function</span> (<span class="params">err, values</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error identifying file size: &#x27;</span> + err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(filename + <span class="string">&#x27; : &#x27;</span> + values)</span><br><span class="line">          aspect = (values.<span class="property">width</span> / values.<span class="property">height</span>)</span><br><span class="line">          widths.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">width, widthIndex</span>) &#123;</span><br><span class="line">            height = <span class="title class_">Math</span>.<span class="title function_">round</span>(width / aspect)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resizing &#x27;</span> + filename + <span class="string">&#x27;to &#x27;</span> + height + <span class="string">&#x27;x&#x27;</span> + height)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resize</span>(width, height).<span class="title function_">write</span>(dest + <span class="string">&#x27;w&#x27;</span> + width + <span class="string">&#x27;_&#x27;</span> + filename, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error writing file: &#x27;</span> + err)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码具体作用就是异步执行如下操作: 通过传入的 <code>srouce</code> 读取指定目录下的文件列表，然后使用 <code>gm</code> 函数进行图像处理，保存处理后的图像到目标目录。</p><p>可以看到代码的嵌套层级非常深，这就是早期 javascript 异步编程的问题。对于异步函数，需要传入一个回调函数表明在当前状态结束后 (如读取文件结束后) 应该继续执行的动作。可以想象一旦异步处理过程多了，如果没有合适的方法，必然会导致深层次的函数嵌套。一般的做法就是将嵌套的函数抽出来，将异步调用拆解到每个函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">a</span>(value, <span class="title function_">b</span>(value, c (value)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">a</span>(value, B)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">B</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="title function_">b</span>(value, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">c</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上述做法带来的一个小问题是如果需要了解整个运行的流程，需要不断跳转函数才能知道整个运行逻辑，而不能直接在一个 main 函数中知晓。</p><h4 id="异步和-monad"><a class="markdownIt-Anchor" href="#异步和-monad"></a> 异步和 monad</h4><p>上述问题的根本原因在于异步过</p><h4 id="promise-介绍"><a class="markdownIt-Anchor" href="#promise-介绍"></a> promise 介绍</h4><p>在 2015 年后，promise 的出现缓解了 javascript 在异步编程中的问题，首先介绍一下什么是 promise:</p><ul><li>promise 是 javascript 中的一个对象，通过 <code>Promise.resolve</code> 方法可以构造出一个 promise 对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">123</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// Promise &#123; 123 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>promise 内部有三种状态 <code>pending</code> 、<code>fulfilled</code> 和 <code>rejected</code> 。他们的作用在这里不深究，只要粗略地了解： <code>fulfilled</code> 可以认为是方法执行成功的状态，<code>rejected</code> 可以认为是方法返回 error 的状态。</p></li><li><p>promise 有三个成员方法 <code>then</code> ，<code>catch</code> 和 <code>finally</code>。这里只介绍 <code>then</code> 和 <code>catch</code> 方法。</p></li></ul><p><code>then</code> 方法接受两个类型为函数的参数，一个是当状态为 <code>fulfilled</code> 的时候调用，另一个为 <code>rejected</code> 的时候调用。一般来说，笔者喜欢只传前一个参数，第二个参数使用缺省值，即只有在状态为成功的时候才执行传入的函数。具体代码例子如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;now&quot;</span>)</span><br><span class="line">x.<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pre: &quot;</span>, x, <span class="string">&quot;running 1&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;run1&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和 <code>then</code> 类似，<code>catch</code> 方法接受一个类型为函数的参数，当状态为 <code>rejected</code> 会调用，具体代码例子如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;now&quot;</span>)</span><br><span class="line">x.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;break at &quot;</span> + reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="promise-和-monad"><a class="markdownIt-Anchor" href="#promise-和-monad"></a> promise 和 monad</h4><p>在了解了 promise 的概念后，可以看出 promise 非常像一个 monad。下面来点证明：</p><ul><li><p>类型构造子：Promise &lt; T &gt;</p></li><li><p>类型转换子：Promise.resolve</p></li><li><p>组合子：Promise&lt; T &gt;.then( (value: T) =&gt; U )</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;now&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">x.<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pre: &quot;</span>, x, <span class="string">&quot;run1&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;run1&quot;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pre: &quot;</span>, x, <span class="string">&quot;run2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;run2&quot;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pre: &quot;</span>, x, <span class="string">&quot;run3&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;run3&quot;</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;break at &quot;</span> + reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Promise &#123; &#x27;now&#x27; &#125;</span></span><br><span class="line"><span class="comment">pre:  now run1</span></span><br><span class="line"><span class="comment">pre:  run1 run2</span></span><br><span class="line"><span class="comment">break at run2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><h2 id="相关阅读"><a class="markdownIt-Anchor" href="#相关阅读"></a> 相关阅读</h2><ul><li><p><a href="https://www.bilibili.com/video/BV17E411F7cH/">Haskell Monad_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://www.adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures - adit.io</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/579141325">如何自底向上地建立起对 Monad 的理解 - 知乎</a></p></li><li><p><a href="https://www.zhihu.com/question/19635359/answer/62415213">什么是 Monad (Functional Programming)？ - Belleve的回答 - 知乎 🤣</a></p></li><li><p><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">深入理解函数式编程（上） - 美团技术团队</a></p></li><li><p><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-02.html">深入理解函数式编程（下） - 美团技术团队</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/Future%E4%B8%8Epromise">Future与promise - 维基百科，自由的百科全书</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-monad&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是-monad&quot;&gt;&lt;/a&gt; 什么是 monad?&lt;/h2&gt;
&lt;p&gt;monad(单子) 是函数式编程中的一种抽象，本文旨在对 monad 的粗浅介绍，所以跳过其数学上的</summary>
      
    
    
    
    <category term="blog" scheme="https://booiris.space/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>SipHash</title>
    <link href="https://booiris.space/pages/blog/SipHash.html"/>
    <id>https://booiris.space/pages/blog/SipHash.html</id>
    <published>2023-10-13T05:36:05.000Z</published>
    <updated>2023-10-26T15:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>论文 <a href="https://eprint.iacr.org/2012/351.pdf">eprint.iacr.org/2012/351.pdf</a></p></blockquote><blockquote><p>代码位置 <a href="https://github.com/rust-lang/rust/blob/1.72.0/library/core/src/hash/sip.rs">library/core/src/hash/sip.rs</a></p></blockquote><p>SipHash 是一类针对短消息设计的伪随机函数族，相较于其他的哈希函数有在短消息上性能高、由于随机输入的存在难以构造<a href="/pages/blog/SipHash.html/../../todo/todo.html">哈希 dos 攻击</a>的优点，是 rust 、python 的内置哈希函数实现。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>对于 SipHash-c-d 函数族，输入为一个 128 bit 的 <code>k</code> 和 可为空的输入 <code>m</code>，输出为一个 64 位长度的 <code>SipHash-c-d(k,m)</code>。其中 <code>c</code> 为 “compression rounds” 的次数， <code>d</code> 为 “finalization rounds” 的次数，“compression rounds” 和 “finalization rounds” 在之后中有说明具体的实现步骤。</p><h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3><p>首先使用 <code>k0</code>、<code>k1</code> 初始化四个值 <code>v0</code> 、<code>v1</code> 、<code>v2</code> 、<code>v3</code>，其中 <code>k0</code>、<code>k1</code> 为 输入 <code>k</code> 的 64 位的小端编码 (也就是两个 u64 值 <code>k0</code> 、<code>k1</code> 组成了 <code>k</code> )。</p><p>对于其中的常量，论文的选取解释为:</p><blockquote><p>The initial state constant corresponds to the ASCII string “somepseudorandomlygeneratedbytes”, big-endian encoded.</p></blockquote><p>论文中提出只需要满足 <code>v0</code> 和 <code>v1</code> 不同于 <code>v2</code> 和 <code>v3</code> 即可(也没分析为啥。。。)。</p><blockquote><p>the only requirement was some asymmetry so that the initial v0 and v1 differ from v2 and v3.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/spihash1.png" alt="" /></p><h3 id="compression-round"><a class="markdownIt-Anchor" href="#compression-round"></a> Compression Round</h3><p>在初始化状态后，将输入的字符串进行编码，将输入的字符串以每 8 字节作为一组以小端序编码成 64 位的数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，最后不够的用 0 做填充，最后一个字节的值为输入的字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>256</mn></mrow><annotation encoding="application/x-tex">len \bmod 256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span>。具体来说，编码的过程如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/siphash_encode.png" alt="" /></p><p>在将输入 <code>s</code> 编码成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>1</mn></msub><mo>…</mo><msub><mi>m</mi><mrow><mo stretchy="false">⌈</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>8</mn></mfrac><mo stretchy="false">⌉</mo></mrow></msub></mrow><annotation encoding="application/x-tex">m_0,m_1 \dots m_{\lceil \frac{(len+1)}{8} \rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05301em;vertical-align:-0.62245em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.6183500000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0377857142857143em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.5020714285714285em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose mtight">⌉</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.62245em;"><span></span></span></span></span></span></span></span></span></span> 后，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 执行以下步骤，迭代执行完所有的输入后，<code>Compression Round</code> 完成。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>v</mi><mn>3</mn></msub><mtext> </mtext><mo>⊕</mo><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>S</mi><mi>i</mi><mi>p</mi><mi>R</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>f</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>c</mi><mtext> </mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>v</mi><mn>0</mn></msub><mtext> </mtext><mo>⊕</mo><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}v_3 \ \oplus = m_i \\SipRound(v_0,v_1,v_2,v_3)\ for\   c \ times \\v_0 \ \oplus = m_i \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">⊕</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathnormal">c</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">⊕</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>PS: 巨💩🤡的是论文中的 “For example, the one-byte input string m = ab is parsed as m0 = 01000000000000ab”。开始我还以为输入的是字符串 “ab”，没看到 “one-byte input”，导致编码输入 m 这块卡了一会。感觉写成 “0xab” 和 “0x01000000000000ab” 会好一点🤡。</p><h3 id="finalization-round"><a class="markdownIt-Anchor" href="#finalization-round"></a> Finalization Round</h3><p>在所有的输入字节处理在 <code>Compression Round</code> 处理完成后，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和常量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mrow><mi mathvariant="normal">x</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow></mrow><annotation encoding="application/x-tex">0\mathrm{xff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord"><span class="mord mathrm">x</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span></span></span></span></span> (也是一个随机的非零值即可) 进行异或，再进行 <code>d</code> 轮 <code>SipRound</code> 之后，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">v_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行异或和后得到最终的 64 位哈希值。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>v</mi><mn>2</mn></msub><mtext> </mtext><mo>⊕</mo><mo>=</mo><mn>0</mn><mrow><mi mathvariant="normal">x</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>S</mi><mi>i</mi><mi>p</mi><mi>R</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>f</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>d</mi><mtext> </mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mo>=</mo><msub><mi>v</mi><mn>0</mn></msub><mo>⊕</mo><msub><mi>v</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>v</mi><mn>2</mn></msub><mo>⊕</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}v_2 \ \oplus = 0\mathrm{xff} \\SipRound(v_0,v_1,v_2,v_3)\ for\   d \ times \\res = v_0 \oplus v_1 \oplus v_2 \oplus v_3\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">⊕</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord"><span class="mord mathrm">x</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h3 id="sipround"><a class="markdownIt-Anchor" href="#sipround"></a> SipRound</h3><p>SipRound 的运算过程如下:</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/siphash_sipround1.png" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/spihash2.png" alt="" /></p><h2 id="安全性分析"><a class="markdownIt-Anchor" href="#安全性分析"></a> 安全性分析</h2><p>#todo</p><ul><li>[ ] SipHash 安全性分析</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;论文 &lt;a href=&quot;https://eprint.iacr.org/2012/351.pdf&quot;&gt;eprint.iacr.org/2012/351.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;代码位置 &lt;a</summary>
      
    
    
    
    <category term="blog" scheme="https://booiris.space/categories/blog/"/>
    
    
    <category term="hash" scheme="https://booiris.space/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>摄影学习</title>
    <link href="https://booiris.space/pages/blog/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://booiris.space/pages/blog/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0.html</id>
    <published>2023-10-09T05:34:26.000Z</published>
    <updated>2023-10-19T15:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考+图片来源 <a href="https://www.bilibili.com/video/BV1pv411H78e">从零开始手把手教你学摄影，20节课带你从小白到大师 | 摄影前期拍摄入门教程_哔哩哔哩_bilibili</a></p></blockquote><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><h3 id="传感器大小分类"><a class="markdownIt-Anchor" href="#传感器大小分类"></a> 传感器大小分类</h3><p>下图来自于</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/camera1.png" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/camara2.png" alt="" /></p><h3 id="焦距"><a class="markdownIt-Anchor" href="#焦距"></a> 焦距</h3><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/camera3.png" alt="" /></p><h3 id="曝光"><a class="markdownIt-Anchor" href="#曝光"></a> 曝光</h3><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/camera4.png" alt="" /></p><h3 id="光圈"><a class="markdownIt-Anchor" href="#光圈"></a> 光圈</h3><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/camera5.png" alt="" /></p><h3 id="快门时间"><a class="markdownIt-Anchor" href="#快门时间"></a> 快门时间</h3><h3 id="感光度-iso"><a class="markdownIt-Anchor" href="#感光度-iso"></a> 感光度 (ISO)</h3><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img/camera6.png" alt="" /></p><h3 id="拍摄模式"><a class="markdownIt-Anchor" href="#拍摄模式"></a> 拍摄模式</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考+图片来源 &lt;a href=&quot;https://www.bilibili.com/video/BV1pv411H78e&quot;&gt;从零开始手把手教你学摄影，20节课带你从小白到大师 | 摄影前期拍摄入门教程_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="blog" scheme="https://booiris.space/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>rust源码阅读</title>
    <link href="https://booiris.space/pages/blog/rust%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"/>
    <id>https://booiris.space/pages/blog/rust%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</id>
    <published>2023-10-05T15:06:41.000Z</published>
    <updated>2024-06-15T16:15:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新中…</p><h2 id="wiki链接"><a class="markdownIt-Anchor" href="#wiki链接"></a> <strong><a href="/wiki/rust_code/index.html#%E7%9B%AE%E5%BD%95">wiki链接</a></strong></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;更新中…&lt;/p&gt;
&lt;h2 id=&quot;wiki链接&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#wiki链接&quot;&gt;&lt;/a&gt; &lt;strong&gt;&lt;a href=&quot;/wiki/rust_code/index.html#%E7%9B%AE%E5%BD%95&quot;</summary>
      
    
    
    
    <category term="blog" scheme="https://booiris.space/categories/blog/"/>
    
    
    <category term="rust" scheme="https://booiris.space/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust For Screeps (3): 系统监控和 panic 处理</title>
    <link href="https://booiris.space/pages/blog/Rust%20For%20Screeps%20(3)%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%92%8C%20panic%20%E5%A4%84%E7%90%86.html"/>
    <id>https://booiris.space/pages/blog/Rust%20For%20Screeps%20(3)%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%92%8C%20panic%20%E5%A4%84%E7%90%86.html</id>
    <published>2023-07-22T15:35:45.000Z</published>
    <updated>2023-07-22T16:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>#todo</p><ul><li>[ ] TODO: 系统监控和 panic 处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#todo&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] TODO: 系统监控和 panic 处理&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="screeps" scheme="https://booiris.space/categories/screeps/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust For Screeps (3): 系统监控</title>
    <link href="https://booiris.space/pages/blog/Rust%20For%20Screeps%20(3)%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7.html"/>
    <id>https://booiris.space/pages/blog/Rust%20For%20Screeps%20(3)%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7.html</id>
    <published>2023-07-22T15:35:45.000Z</published>
    <updated>2023-11-02T05:32:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考 <a href="https://www.jianshu.com/p/de74baf6fb48">Screeps 制作统计图表 - 简书</a></p></blockquote><p>首先说明: 本文使用 docker 将监控系统部署在自有服务器上，所以先决条件是一台能公网访问的服务器(</p><h2 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h2><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img@main/20231102131635.png" alt="image.png" /></p><h2 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h2><h3 id="记录当前状态存入内存"><a class="markdownIt-Anchor" href="#记录当前状态存入内存"></a> 记录当前状态存入内存</h3><p>在 <a href="https://www.jianshu.com/p/de74baf6fb48">Screeps 制作统计图表 - 简书</a> 中使用的是 <a href="/pages/blog/Rust%20For%20Screeps%20(3)%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7.html/../Rust%20For%20Screeps%20(2)%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.html#memory-object">memory object</a> 存储系统信息。遗憾的是在 rust 中无法使用 <code>memory</code> 对象，但是 screeps 还有另一个存储信息的地方，那就是 <a href="/pages/blog/Rust%20For%20Screeps%20(3)%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7.html/../Rust%20For%20Screeps%20(2)%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.html#raw-memory">raw memory</a> 。</p><p><code>raw memory</code> 可以存储 10 MB 的序列化后的内容，它由一个个 <code>segment</code> 组成，每个<code>segment</code> 最多存储 100 KB 内容。所以可以指定一段 <code>segment</code> 用于存储当前系统的状态。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">log</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">status_segement</span> = raw_memory::<span class="title function_ invoke__">segments</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">status</span> = Status::<span class="title function_ invoke__">get_status</span>();</span><br><span class="line">status_segement.<span class="title function_ invoke__">set</span>(STATUS_INDEX, status.<span class="title function_ invoke__">into</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问内存并解析内存内容"><a class="markdownIt-Anchor" href="#访问内存并解析内存内容"></a> 访问内存并解析内存内容</h3><p><a href="https://github.com/booiris/rust-learning/tree/screep_log">GitHub - booiris/rust-learning at screep_log</a></p><h3 id="将信息存储到时序数据库中"><a class="markdownIt-Anchor" href="#将信息存储到时序数据库中"></a> 将信息存储到时序数据库中</h3><h3 id="使用-grafana-制作图表"><a class="markdownIt-Anchor" href="#使用-grafana-制作图表"></a> 使用 Grafana 制作图表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  <span class="built_in">sync</span>:</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    build:</span><br><span class="line">      context: ./sync</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    image: <span class="built_in">sync</span>:1</span><br><span class="line">    volumes:</span><br><span class="line">      - ./sync/log:/log</span><br><span class="line">    depends_on:</span><br><span class="line">      - influxdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://hub.docker.com/_/influxdb 查看参数含义</span></span><br><span class="line">  influxdb:</span><br><span class="line">    image: influxdb:latest</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    volumes:</span><br><span class="line">      - ./influxdb-data:/var/lib/influxdb2</span><br><span class="line">      - ./influxdb-config:/etc/influxdb2</span><br><span class="line">    environment:</span><br><span class="line">      - DOCKER_INFLUXDB_INIT_MODE=setup</span><br><span class="line">      - DOCKER_INFLUXDB_INIT_USERNAME=<span class="variable">$&#123;username&#125;</span></span><br><span class="line">      - DOCKER_INFLUXDB_INIT_PASSWORD=<span class="variable">$&#123;pwd&#125;</span></span><br><span class="line">      - DOCKER_INFLUXDB_INIT_ORG=<span class="variable">$&#123;org&#125;</span></span><br><span class="line">      - DOCKER_INFLUXDB_INIT_BUCKET=<span class="variable">$&#123;bucket&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://grafana.com/docs/grafana/latest/setup-grafana/installation/docker/ 查看参数含义</span></span><br><span class="line">  grafana:</span><br><span class="line">    image: grafana/grafana:latest</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&#x27;12002:3000&#x27;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./grafana-data:/var/lib/grafana</span><br><span class="line">      - ./grafana-provisioning/:/etc/grafana/provisioning</span><br><span class="line">    depends_on:</span><br><span class="line">      - influxdb</span><br><span class="line">    user: <span class="string">&quot;<span class="variable">$UID</span>:<span class="variable">$GID</span>&quot;</span></span><br><span class="line">    environment:</span><br><span class="line">      - GF_SECURITY_ADMIN_USER=<span class="variable">$&#123;GRAFANA_USERNAME&#125;</span></span><br><span class="line">      - GF_SECURITY_ADMIN_PASSWORD=<span class="variable">$&#123;GRAFANA_PASSWORD&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://www.jianshu.com/p/de74baf6fb48&quot;&gt;Screeps 制作统计图表 - 简书&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先说明: 本文使用 docker 将监控系统部署在自</summary>
      
    
    
    
    <category term="screeps" scheme="https://booiris.space/categories/screeps/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust For Screeps (2): 自定义存储模型</title>
    <link href="https://booiris.space/pages/blog/Rust%20For%20Screeps%20(2)%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.html"/>
    <id>https://booiris.space/pages/blog/Rust%20For%20Screeps%20(2)%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.html</id>
    <published>2023-07-22T13:05:20.000Z</published>
    <updated>2023-10-13T14:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="screeps-存储模型"><a class="markdownIt-Anchor" href="#screeps-存储模型"></a> Screeps 存储模型</h2><p>screeps 的存储模型基本如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img//20230722224904.png" alt="image.png" /></p><p>其中存在两种类型的 memory，一个是 <code>memory object</code> ，另一个是 <code>raw memory</code> 。</p><h3 id="memory-object"><a class="markdownIt-Anchor" href="#memory-object"></a> memory object</h3><p><code>memory object</code> 的具体介绍在 <a href="https://docs.screeps.com/global-objects.html#Memory-object">Global Objects | Screeps Documentation</a>。</p><blockquote><p>Each player has access to the global object <code>Memory</code> in which he/she may store any information in the JSON format.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Memory</span>.<span class="property">someData</span> = &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>可以看出 screeps 本身内置了一个 <code>Memory</code> 的对象实例。可以往其中添加各种属性来达到存储信息的目的。</p><h3 id="raw-memory"><a class="markdownIt-Anchor" href="#raw-memory"></a> raw memory</h3><p><code>raw memory</code> 在这里被提到 <a href="https://docs.screeps.com/global-objects.html#Serialization">Global Objects | Screeps Documentation</a></p><blockquote><p>The Memory object is stored in the stringified form and is parsed each time upon the first in the tick access from your script with the help of the <code>JSON.parse</code> method.</p></blockquote><p>可以看出 <code>Memory</code> 的对象实例最终会被序列化为字符串存储到 <code>raw memory</code> 中，在游戏的每个 tick 进行传递。</p><h3 id="存储传递过程"><a class="markdownIt-Anchor" href="#存储传递过程"></a> 存储传递过程</h3><p>在游戏的进行每个 tick ，screeps 系统会反序列化 <code>raw memory</code> 到 <code>Memory Object</code> (代码见 <a href="https://github.com/screeps/engine/blob/c6c4fc9e656f160e0e0174b0dd9a817d2dd18976/src/game/game.js#L470">game.js</a>、<a href="https://github.com/screeps/engine/blob/c6c4fc9e656f160e0e0174b0dd9a817d2dd18976/src/game/game.js#L478C13-L478C76">game.js</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.<span class="title function_">extend</span>(runCodeCache[userId].<span class="property">globals</span>, &#123;</span><br><span class="line"><span class="title class_">RawMemory</span>: runCodeCache[userId].<span class="property">memory</span>,</span><br><span class="line"><span class="attr">console</span>: runCodeCache[userId].<span class="property">fakeConsole</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(runCodeCache[userId].<span class="property">globals</span>, <span class="string">&#x27;Memory&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">runCodeCache[userId].<span class="property">memory</span>.<span class="property">_parsed</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(runCodeCache[userId].<span class="property">memory</span>.<span class="title function_">get</span>() || <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">runCodeCache[userId].<span class="property">memory</span>.<span class="property">_parsed</span>.<span class="property">__proto__</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">runCodeCache[userId].<span class="property">memory</span>.<span class="property">_parsed</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(runCodeCache[userId].<span class="property">globals</span>, <span class="string">&#x27;Memory&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">value</span>: runCodeCache[userId].<span class="property">memory</span>.<span class="property">_parsed</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> runCodeCache[userId].<span class="property">memory</span>.<span class="property">_parsed</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在每个 tick 最后，再将 <code>Memory</code> 序列化到 <code>raw memory</code> 里。所以，<strong>在每个 tick 间，真正传递的是 <code>raw memory</code></strong>。</p><h2 id="rust-存储模型"><a class="markdownIt-Anchor" href="#rust-存储模型"></a> Rust 存储模型</h2><p>从上面可以知道，Screeps 有一个 JavaScript 对象 <code>Memory</code> 保存需要的信息。但是要从 rust 中访问 JavaScript 里的对象十分麻烦。同时 <a href="https://github.com/rustyscreeps/screeps-game-api/">screeps-game-api</a> 里似乎只有 <code>raw memory</code> 的获取方法，而没有 <code>memory</code> 对象的获取方法。</p><p>所以显然易见，我们的存储信息需要放到 rust 里。在上一章的示例代码中，有这样一个变量:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is one way to persist data between ticks within Rust&#x27;s memory, as opposed to</span></span><br><span class="line"><span class="comment">// keeping state in memory on game objects - but will be lost on global resets!</span></span><br><span class="line">thread_local! &#123;</span><br><span class="line">    <span class="keyword">static</span> CREEP_TARGETS: RefCell&lt;HashMap&lt;<span class="type">String</span>, CreepTarget&gt;&gt; = RefCell::<span class="title function_ invoke__">new</span>(HashMap::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>RefCell</code> 创建一个全局变量 (类似 javaScript 里的 <code>Memory</code> 对象) 存储到 wasm 的线性内存里。只要 wasm 的实例没有被销毁，那么这个全局变量就可以随着 wasm 实例在每个 tick 传递。</p><h2 id="自定义存储实现"><a class="markdownIt-Anchor" href="#自定义存储实现"></a> 自定义存储实现</h2><p>通过 rust 的全局变量我们实现了信息跨 tick 存储，但注意到注释中存在着一句话。</p><blockquote><p>keeping state in memory on game objects - but will be lost on global resets!</p></blockquote><p>Screeps 系统存在着一个机制，就是 <code>global reset</code> ，会定时销毁 javaScript 里的对象并且重建，这就导致了这会销毁 wasm 的实例，进而导致存储的信息丢失。</p><h3 id="raw-memory-使用"><a class="markdownIt-Anchor" href="#raw-memory-使用"></a> raw memory 使用</h3><p>从第一部分可以知道 <code>raw memory</code> 可以认为是 Screeps 中的持久性存储。所以如果可以在每个 tick 最后把 rust 里的全局变量序列化到 <code>raw memory</code> 里，然后在 wasm 实例初始化时再从 <code>raw memory</code> 里反序列化回 rust 的全局变量，这就实现了信息的跨 tick 保存而又不会受到 <code>global reset</code> 的影响。</p><h3 id="rust-部分实现"><a class="markdownIt-Anchor" href="#rust-部分实现"></a> rust 部分实现</h3><p>Screeps 的 api 存在对 <code>raw memory</code> 的操作方法 <a href="https://docs.screeps.com/api/#RawMemory">Screeps Documentation</a>。</p><img src="https://cdn.jsdelivr.net/gh/booiris-cdn/img//20230722234254.png" width=65% ><p>储存全局变量参考代码:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread_local! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> GLOBAL_LONG_MEMORY: RefCell&lt;GlobalMemory&gt; = RefCell::<span class="title function_ invoke__">new</span>(GlobalMemory::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLOBAL_LONG_MEMORY.<span class="title function_ invoke__">with</span>(|mem| &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mem</span> = &amp;*mem.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mem</span>: <span class="type">String</span> = mem.<span class="title function_ invoke__">into</span>();</span><br><span class="line">raw_memory::<span class="title function_ invoke__">set</span>(&amp;JsString::<span class="title function_ invoke__">from_str</span>(&amp;mem).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;can conver global mem to string&quot;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中 <code>GlobalMemory</code> 是一个结构体，并且实现了 <code>into String</code> 的方法，所以可以使用 <code>mem.into()</code> 转换为 <code>String</code> 类型，最后通过 api 的 <code>raw_memory::set</code> 方法将全局变量保存到 <code>raw memory</code> 中。</p><p>初始化全局变量参考代码:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL_LONG_MEMORY.<span class="title function_ invoke__">with</span>(|mem| &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">raw_memory</span>: <span class="type">String</span> = raw_memory::<span class="title function_ invoke__">get</span>()</span><br><span class="line">.<span class="title function_ invoke__">try_into</span>()</span><br><span class="line">.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;can not get raw memory&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(raw_mem) = GlobalMemory::<span class="title function_ invoke__">try_from</span>(raw_memory) &#123;</span><br><span class="line">*mem.<span class="title function_ invoke__">borrow_mut</span>() = raw_mem;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log::error!(<span class="string">&quot;old mem can not match new struct!&quot;</span>);</span><br><span class="line">*mem.<span class="title function_ invoke__">borrow_mut</span>() = GlobalMemory::<span class="title function_ invoke__">new</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看出，<strong>存在无法从 <code>raw memory</code> 还原回全局变量的情况</strong> ( <code>GlobalMemory</code> 的结构出现了破坏性的更改导致无法从之前的结构反序列化回去)。这时候需要考虑构建一个在空的全局变量下还能继续运行并且还原的系统。</p><h3 id="javascript-部分实现"><a class="markdownIt-Anchor" href="#javascript-部分实现"></a> javaScript 部分实现</h3><p>本来存储 <code>raw memory</code> 的过程在 rust 中实现即可。但是存在一个问题，Screeps 系统运行中，某些动作 (比如 creep_move) 会使用的 <code>memory object</code> 实例，所以会对 <code>raw memory</code> 进行反序列化。为了不必要的消耗，我们可以持有一个 <code>mem_proxy</code> 对象实例，每个 tick 开始，就对 <code>memory object</code> 进行赋值，这样就不会触发反序列化，减少 cpu 消耗。</p><blockquote><p>参考 <a href="https://www.jianshu.com/p/c6413d67893b">Screeps游戏 Memory仙术 - 简书</a></p></blockquote><p>实现代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> wasm_module;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MODULE_NAME</span> = <span class="string">&quot;rust-screep-world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">console_error</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(...args);</span><br><span class="line">    <span class="title class_">Game</span>.<span class="title function_">notify</span>(args.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mem_proxy = &#123; <span class="attr">creeps</span>: &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">loop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">global</span>.<span class="property">Memory</span>;</span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">Memory</span> = mem_proxy</span><br><span class="line">    <span class="title class_">RawMemory</span>.<span class="property">_parsed</span> = mem_proxy</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wasm_module) &#123;</span><br><span class="line">            wasm_module.<span class="title function_">loop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// attempt to load the wasm only if there&#x27;s enough bucket to do a bunch of work this tick</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Game</span>.<span class="property">cpu</span>.<span class="property">bucket</span> &lt; <span class="number">500</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;we are running out of time, pausing compile!!!&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Game</span>.<span class="property">cpu</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// delect the module from the cache, so we can reload it</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable constant_">MODULE_NAME</span> <span class="keyword">in</span> <span class="built_in">require</span>.<span class="property">cache</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">require</span>.<span class="property">cache</span>[<span class="variable constant_">MODULE_NAME</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// replace this initialize function on the module</span></span><br><span class="line">            wasm_module = <span class="built_in">require</span>(<span class="variable constant_">MODULE_NAME</span>);</span><br><span class="line">            <span class="comment">// load the wasm instance!</span></span><br><span class="line">            wasm_module.<span class="title function_">initialize_instance</span>();</span><br><span class="line">            <span class="comment">// run the setup function, which configures logging</span></span><br><span class="line">            wasm_module.<span class="title function_">setup</span>();</span><br><span class="line">            <span class="comment">// go ahead and run the loop for its first tick</span></span><br><span class="line">            wasm_module.<span class="title function_">loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">console_error</span>(<span class="string">&quot;caught exception err:&quot;</span>, error);</span><br><span class="line">        <span class="keyword">if</span> (error.<span class="property">stack</span>) &#123;</span><br><span class="line">            <span class="title function_">console_error</span>(<span class="string">&quot;stack trace:&quot;</span>, error.<span class="property">stack</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">console_error</span>(<span class="string">&quot;resetting VM next tick.&quot;</span>);</span><br><span class="line">        wasm_module = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_proxy = <span class="variable language_">global</span>.<span class="property">Memory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;screeps-存储模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#screeps-存储模型&quot;&gt;&lt;/a&gt; Screeps 存储模型&lt;/h2&gt;
&lt;p&gt;screeps 的存储模型基本如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http</summary>
      
    
    
    
    <category term="screeps" scheme="https://booiris.space/categories/screeps/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust For Screeps (1): 初始环境搭建</title>
    <link href="https://booiris.space/pages/blog/Rust%20For%20Screeps%20(1)%20%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://booiris.space/pages/blog/Rust%20For%20Screeps%20(1)%20%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</id>
    <published>2023-07-22T11:29:29.000Z</published>
    <updated>2023-07-22T15:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考 <a href="https://github.com/rustyscreeps/screeps-starter-rust/">GitHub - rustyscreeps/screeps-starter-rust: Starter Rust AI for Screeps, the JavaScript-based MMO game</a></p></blockquote><h3 id="安装相关cli"><a class="markdownIt-Anchor" href="#安装相关cli"></a> 安装相关cli</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-screeps</span><br></pre></td></tr></table></figure><p>命令包含了构建代码、上传代码等操作。</p><h3 id="下载模板文件"><a class="markdownIt-Anchor" href="#下载模板文件"></a> 下载模板文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/rustyscreeps/screeps-starter-rust.git</span><br><span class="line"><span class="built_in">cd</span> screeps-starter-rust</span><br></pre></td></tr></table></figure><p>模板 (版本:<a href="https://github.com/rustyscreeps/cargo-screeps/tree/d91b60f9a13eb0bd763b094acb6a1d749bb1b12f">d91b60f9a13eb0bd763b094acb6a1d749bb1b12f</a>) 中包含的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── example-screeps.toml</span><br><span class="line">├── javascript</span><br><span class="line">│   └── main.js</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">    ├── lib.rs</span><br><span class="line">    └── logging.rs</span><br></pre></td></tr></table></figure><h3 id="模板文件说明"><a class="markdownIt-Anchor" href="#模板文件说明"></a> 模板文件说明</h3><p><code>example-screeps.toml</code> 用于 <code>cargo-screeps</code> 的配置。</p><p><code>javascript/main.js</code> 为游戏主入口，其中内容如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> wasm_module;</span><br><span class="line"></span><br><span class="line"><span class="comment">// replace this with the name of your module</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MODULE_NAME</span> = <span class="string">&quot;screeps-starter-rust&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">console_error</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(...args);</span><br><span class="line">    <span class="title class_">Game</span>.<span class="title function_">notify</span>(args.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">loop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wasm_module) &#123;</span><br><span class="line">            wasm_module.<span class="title function_">loop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// attempt to load the wasm only if there&#x27;s enough bucket to do a bunch of work this tick</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Game</span>.<span class="property">cpu</span>.<span class="property">bucket</span> &lt; <span class="number">500</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;we are running out of time, pausing compile!&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Game</span>.<span class="property">cpu</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// delect the module from the cache, so we can reload it</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable constant_">MODULE_NAME</span> <span class="keyword">in</span> <span class="built_in">require</span>.<span class="property">cache</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">require</span>.<span class="property">cache</span>[<span class="variable constant_">MODULE_NAME</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// load the wasm module</span></span><br><span class="line">            wasm_module = <span class="built_in">require</span>(<span class="variable constant_">MODULE_NAME</span>);</span><br><span class="line">            <span class="comment">// load the wasm instance!</span></span><br><span class="line">            wasm_module.<span class="title function_">initialize_instance</span>();</span><br><span class="line">            <span class="comment">// run the setup function, which configures logging</span></span><br><span class="line">            wasm_module.<span class="title function_">setup</span>();</span><br><span class="line">            <span class="comment">// go ahead and run the loop for its first tick</span></span><br><span class="line">            wasm_module.<span class="title function_">loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">console_error</span>(<span class="string">&quot;caught exception:&quot;</span>, error);</span><br><span class="line">        <span class="keyword">if</span> (error.<span class="property">stack</span>) &#123;</span><br><span class="line">            <span class="title function_">console_error</span>(<span class="string">&quot;stack trace:&quot;</span>, error.<span class="property">stack</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">console_error</span>(<span class="string">&quot;resetting VM next tick.&quot;</span>);</span><br><span class="line">        wasm_module = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件中 <code>wasm_module</code> 保存了 wasm 的实例。如果 wasm 的实例存在，就调用 loop 函数运行游戏逻辑。如果 wasm 的实例不存在 (由于更新代码或 screeps 进行了内存回收等原因导致实列被销毁)，<strong>重新载入 wasm 并且调用 setup 函数进行初始化，然后再运行游戏逻辑</strong>。</p><p><code>src/logging.rs</code> 为辅助文件，用于日志的实现。基本上就是进行 log 格式的创建，不做过多说明。在 setup 阶段调用一下 <code>setup_logging</code> 函数就行。</p><p><code>src/lib.rs</code> 为 rust 的实现逻辑入口。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::collections::&#123;hash_map::Entry, HashMap&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> log::*;</span><br><span class="line"><span class="keyword">use</span> screeps::&#123;</span><br><span class="line">    constants::&#123;ErrorCode, Part, ResourceType&#125;,</span><br><span class="line">    enums::StructureObject,</span><br><span class="line">    find, game,</span><br><span class="line">    local::ObjectId,</span><br><span class="line">    objects::&#123;Creep, Source, StructureController&#125;,</span><br><span class="line">    prelude::*,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> wasm_bindgen::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> logging;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add wasm_bindgen to any function you would like to expose for call from js</span></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup</span>() &#123;</span><br><span class="line">    logging::<span class="title function_ invoke__">setup_logging</span>(logging::Info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is one way to persist data between ticks within Rust&#x27;s memory, as opposed to</span></span><br><span class="line"><span class="comment">// keeping state in memory on game objects - but will be lost on global resets!</span></span><br><span class="line">thread_local! &#123;</span><br><span class="line">    <span class="keyword">static</span> CREEP_TARGETS: RefCell&lt;HashMap&lt;<span class="type">String</span>, CreepTarget&gt;&gt; = RefCell::<span class="title function_ invoke__">new</span>(HashMap::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this enum will represent a creep&#x27;s lock on a specific target object, storing a js reference</span></span><br><span class="line"><span class="comment">// to the object id so that we can grab a fresh reference to the object each successive tick,</span></span><br><span class="line"><span class="comment">// since screeps game objects become &#x27;stale&#x27; and shouldn&#x27;t be used beyond the tick they were fetched</span></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CreepTarget</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Upgrade</span>(ObjectId&lt;StructureController&gt;),</span><br><span class="line">    <span class="title function_ invoke__">Harvest</span>(ObjectId&lt;Source&gt;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to use a reserved name as a function name, use `js_name`:</span></span><br><span class="line"><span class="meta">#[wasm_bindgen(js_name = loop)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">game_loop</span>() &#123;</span><br><span class="line">    debug!(<span class="string">&quot;loop starting! CPU: &#123;&#125;&quot;</span>, game::cpu::<span class="title function_ invoke__">get_used</span>());</span><br><span class="line">    <span class="comment">// mutably borrow the creep_targets refcell, which is holding our creep target locks</span></span><br><span class="line">    <span class="comment">// in the wasm heap</span></span><br><span class="line">    CREEP_TARGETS.<span class="title function_ invoke__">with</span>(|creep_targets_refcell| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">creep_targets</span> = creep_targets_refcell.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">        debug!(<span class="string">&quot;running creeps&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">creep</span> <span class="keyword">in</span> game::<span class="title function_ invoke__">creeps</span>().<span class="title function_ invoke__">values</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">run_creep</span>(&amp;creep, &amp;<span class="keyword">mut</span> creep_targets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    debug!(<span class="string">&quot;running spawns&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">additional</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">spawn</span> <span class="keyword">in</span> game::<span class="title function_ invoke__">spawns</span>().<span class="title function_ invoke__">values</span>() &#123;</span><br><span class="line">        debug!(<span class="string">&quot;running spawn &#123;&#125;&quot;</span>, <span class="type">String</span>::<span class="title function_ invoke__">from</span>(spawn.<span class="title function_ invoke__">name</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">body</span> = [Part::Move, Part::Move, Part::Carry, Part::Work];</span><br><span class="line">        <span class="keyword">if</span> spawn.<span class="title function_ invoke__">room</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">energy_available</span>() &gt;= body.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|p| p.<span class="title function_ invoke__">cost</span>()).<span class="title function_ invoke__">sum</span>() &#123;</span><br><span class="line">            <span class="comment">// create a unique name, spawn.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">name_base</span> = game::<span class="title function_ invoke__">time</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">name</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;&quot;</span>, name_base, additional);</span><br><span class="line">            <span class="comment">// note that this bot has a fatal flaw; spawning a creep</span></span><br><span class="line">            <span class="comment">// creates Memory.creeps[creep_name] which will build up forever;</span></span><br><span class="line">            <span class="comment">// these memory entries should be prevented (todo doc link on how) or cleaned up</span></span><br><span class="line">            <span class="keyword">match</span> spawn.<span class="title function_ invoke__">spawn_creep</span>(&amp;body, &amp;name) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(()) =&gt; additional += <span class="number">1</span>,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; warn!(<span class="string">&quot;couldn&#x27;t spawn: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">&quot;done! cpu: &#123;&#125;&quot;</span>, game::cpu::<span class="title function_ invoke__">get_used</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要关注两个函数 <code>setup</code> 和 <code>game_loop</code> 。</p><p><code>setup</code> 为 wasm 实例创建的时候调用的函数，在其中可以实现日志初始化、数据初始化的逻辑。</p><p><code>game_loop</code> 通过 <code>#[wasm_bindgen(js_name = loop)]</code> 的标注 (rust 中称为过程宏) 将其改名为wasm 里运行的 loop 函数，这也是游戏中每 tick 运行的主逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://github.com/rustyscreeps/screeps-starter-rust/&quot;&gt;GitHub - rustyscreeps/screeps-starter-rust: Starter Rust </summary>
      
    
    
    
    <category term="screeps" scheme="https://booiris.space/categories/screeps/"/>
    
    
  </entry>
  
  <entry>
    <title>杂记</title>
    <link href="https://booiris.space/pages/linux/%E6%9D%82%E8%AE%B0.html"/>
    <id>https://booiris.space/pages/linux/%E6%9D%82%E8%AE%B0.html</id>
    <published>2022-08-20T07:12:49.000Z</published>
    <updated>2022-12-25T15:56:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2022-08-20"><a class="markdownIt-Anchor" href="#2022-08-20"></a> [[2022-08-20]]</h2><p>我们建立ssh隧道的时候，往往是想通过一台公网的主机或者是大家都可以访问的主机做跳转机，来访问内部或者外部不能直接访问的机器。所以一般像这种情况下，请将跳转机中的ssh服务器中的<code>GatewayPorts</code>设为yes。</p><p>端口转发时参数为 <code>-NfR</code></p><h2 id="2022-08-30"><a class="markdownIt-Anchor" href="#2022-08-30"></a> [[2022-08-30]]</h2><p>docker运行systemctl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name desk -p 2222:22 -v /home/booiris:/home/booiris --hostname vm-host --<span class="built_in">env</span> container=docker   --privileged archlinux /sbin/init</span><br></pre></td></tr></table></figure><h2 id="2022-10-08"><a class="markdownIt-Anchor" href="#2022-10-08"></a> [[2022-10-08]]</h2><p>@ + 时间 == today</p><p>rust partition_point(|x| x &lt; &amp;s) 函数 lower_bound upper_bound 在位置左边的为满足表达式的值，右边为不满足表达式的值。</p><p>[[2022-12-25]]</p><p>灵感：</p><ol><li>卡牌拓印场景中的元素</li><li>控制人物会有影响</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2022-08-20&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2022-08-20&quot;&gt;&lt;/a&gt; [[2022-08-20]]&lt;/h2&gt;
&lt;p&gt;我们建立ssh隧道的时候，往往是想通过一台公网的主机或者是大家都可以访问的主机做跳转机，</summary>
      
    
    
    
    <category term="linux" scheme="https://booiris.space/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux自启动服务</title>
    <link href="https://booiris.space/pages/linux/linux%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.html"/>
    <id>https://booiris.space/pages/linux/linux%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.html</id>
    <published>2022-08-20T06:29:28.000Z</published>
    <updated>2022-08-20T06:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>自启动文件放在 <code>/usr/lib/systemd/system</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=code-server</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/code-server</span><br><span class="line">User=your user name</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload  #刷新</span><br><span class="line">sudo systemctl start code-server</span><br><span class="line">sudo systemctl enable code-server</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自启动文件放在 &lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/</summary>
      
    
    
    
    <category term="linux" scheme="https://booiris.space/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>arch虚拟机安装</title>
    <link href="https://booiris.space/pages/linux/arch%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85.html"/>
    <id>https://booiris.space/pages/linux/arch%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85.html</id>
    <published>2022-08-03T16:02:01.000Z</published>
    <updated>2022-08-20T06:50:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看ip地址"><a class="markdownIt-Anchor" href="#查看ip地址"></a> 查看ip地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><h3 id="时间同步"><a class="markdownIt-Anchor" href="#时间同步"></a> 时间同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="准备磁盘分区"><a class="markdownIt-Anchor" href="#准备磁盘分区"></a> 准备磁盘分区</h2><h3 id="显示所有分区"><a class="markdownIt-Anchor" href="#显示所有分区"></a> 显示所有分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><h3 id="开始分区"><a class="markdownIt-Anchor" href="#开始分区"></a> 开始分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure><p>分区过程参考<a href="https://ericclose.github.io/Installing-Arch-as-a-guest-with-UEFI-and-GPT.html#arch-chroot">网址</a></p><h3 id="确认是否生效"><a class="markdownIt-Anchor" href="#确认是否生效"></a> 确认是否生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l /dev/sda</span><br></pre></td></tr></table></figure><h3 id="格式化分区和设置swap分区"><a class="markdownIt-Anchor" href="#格式化分区和设置swap分区"></a> 格式化分区和设置swap分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1</span><br><span class="line">mkswap /dev/sda2</span><br><span class="line">mkfs.ext4 /dev/sda3 </span><br></pre></td></tr></table></figure><h3 id="启用交换分区"><a class="markdownIt-Anchor" href="#启用交换分区"></a> 启用交换分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure><h3 id="挂载根目录"><a class="markdownIt-Anchor" href="#挂载根目录"></a> 挂载根目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda3 /mnt</span><br></pre></td></tr></table></figure><h3 id="挂载boot目录"><a class="markdownIt-Anchor" href="#挂载boot目录"></a> 挂载boot目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mnt/boot</span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br></pre></td></tr></table></figure><h2 id="安装系统"><a class="markdownIt-Anchor" href="#安装系统"></a> 安装系统</h2><h3 id="修改镜像源"><a class="markdownIt-Anchor" href="#修改镜像源"></a> 修改镜像源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>添加 <code>Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch</code> 镜像</p><p>如果安装时报错 <code>ERROR: 5984EA8F3C could not be locally signed</code> 解决办法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -fr /etc/pacman.d/gnupg</span><br><span class="line">umount /etc/pacman.d/gnupg</span><br><span class="line"><span class="built_in">rm</span> -fr /etc/pacman.d/gnupg</span><br><span class="line">pacman-key --init</span><br><span class="line">pacman-key --populate archlinux</span><br><span class="line">pacman -Sy archlinux-keyring</span><br></pre></td></tr></table></figure><h3 id="安装系统和网络插件"><a class="markdownIt-Anchor" href="#安装系统和网络插件"></a> 安装系统和网络插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base linux networkmanager</span><br></pre></td></tr></table></figure><h2 id="配置系统"><a class="markdownIt-Anchor" href="#配置系统"></a> 配置系统</h2><h3 id="生成fstab文件"><a class="markdownIt-Anchor" href="#生成fstab文件"></a> 生成fstab文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h3 id="进入chroot"><a class="markdownIt-Anchor" href="#进入chroot"></a> 进入chroot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><h3 id="设置时区"><a class="markdownIt-Anchor" href="#设置时区"></a> 设置时区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h3 id="设置硬件时间同步"><a class="markdownIt-Anchor" href="#设置硬件时间同步"></a> 设置硬件时间同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h3 id="安装vim"><a class="markdownIt-Anchor" href="#安装vim"></a> 安装vim</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S vim</span><br></pre></td></tr></table></figure><h3 id="语言设置"><a class="markdownIt-Anchor" href="#语言设置"></a> 语言设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br><span class="line">en_US</span><br><span class="line">zh_CN</span><br></pre></td></tr></table></figure><h3 id="生成语言"><a class="markdownIt-Anchor" href="#生成语言"></a> 生成语言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure><h3 id="设置默认语言"><a class="markdownIt-Anchor" href="#设置默认语言"></a> 设置默认语言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><h3 id="创建host文件"><a class="markdownIt-Anchor" href="#创建host文件"></a> 创建host文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> YourNewHostname &gt; /etc/hostname</span><br></pre></td></tr></table></figure><h3 id="添加host"><a class="markdownIt-Anchor" href="#添加host"></a> 添加host</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"># Static table lookup for hostnames.  </span><br><span class="line"># See hosts(5) for details.  </span><br><span class="line">127.0.0.1   localhost  </span><br><span class="line">::1         localhost  </span><br><span class="line">127.0.1.1   YourNewHostname.localdomain    YourNewHostname</span><br></pre></td></tr></table></figure><h3 id="开启网络服务"><a class="markdownIt-Anchor" href="#开启网络服务"></a> 开启网络服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> NetworkManager</span><br></pre></td></tr></table></figure><h3 id="设置-root-用户密码"><a class="markdownIt-Anchor" href="#设置-root-用户密码"></a> 设置 root 用户密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><h2 id="安装引导程序"><a class="markdownIt-Anchor" href="#安装引导程序"></a> 安装引导程序</h2><p>UEFI 系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=<span class="string">&quot;Arch Linux&quot;</span> --recheck</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg </span><br></pre></td></tr></table></figure><h2 id="完成安装"><a class="markdownIt-Anchor" href="#完成安装"></a> 完成安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">umount -R /mnt</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h3><p>实体机安装类似，关闭显示屏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setterm -blank 1 # 待机一分钟关闭显示屏</span><br></pre></td></tr></table></figure><p>在进入fakeroot后安装 intel-ucode,电源管理tlp</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;查看ip地址&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#查看ip地址&quot;&gt;&lt;/a&gt; 查看ip地址&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    <category term="linux" scheme="https://booiris.space/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx反向代理自签名</title>
    <link href="https://booiris.space/pages/linux/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%87%AA%E7%AD%BE%E5%90%8D.html"/>
    <id>https://booiris.space/pages/linux/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%87%AA%E7%AD%BE%E5%90%8D.html</id>
    <published>2022-07-02T08:49:11.000Z</published>
    <updated>2022-08-20T06:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自签名ca证书"><a class="markdownIt-Anchor" href="#自签名ca证书"></a> 自签名ca证书</h2><p>首先创建cert文件夹保存证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> cert</span><br><span class="line"><span class="built_in">cd</span> cert</span><br></pre></td></tr></table></figure><p>然后创建配置文件cert.cnf，注意如果时ip自签名就在your_IP填写自己的ip，如果是自签名域名就是在your_domain写自己的域名。</p><p>[dn]下CN字段是ca根服务器地址，alt_names下是ca验证的ip和域名地址，一般情况下这两个是一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[req] </span><br><span class="line">prompt = no </span><br><span class="line">default_bits = 4096</span><br><span class="line">default_md = sha256</span><br><span class="line">distinguished_name = dn </span><br><span class="line">x509_extensions = v3_req</span><br><span class="line"></span><br><span class="line">[dn] </span><br><span class="line">C=CN</span><br><span class="line">ST=Shanghai</span><br><span class="line">L=Shanghai</span><br><span class="line">O=TEST</span><br><span class="line">OU=Testing Domain</span><br><span class="line">CN=$your_IP or $your_domain</span><br><span class="line">emailAddress=admin@localhost</span><br><span class="line"></span><br><span class="line">[v3_req]</span><br><span class="line">basicConstraints=CA:TRUE</span><br><span class="line">keyUsage=digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">extendedKeyUsage=serverAuth</span><br><span class="line">subjectAltName=@alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">IP.1=$your_IP</span><br><span class="line">DNS.1=$your_domain</span><br></pre></td></tr></table></figure><p>根据配置文件生成证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout cert.key -out cert.crt  -config cert.cnf</span><br></pre></td></tr></table></figure><p>当前目录下生成两个文件cert.crt和cert.key，至此自签名步骤完成。</p><h2 id="nginx反向代理"><a class="markdownIt-Anchor" href="#nginx反向代理"></a> nginx反向代理</h2><p>docker拉取nginx镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>新建一个容器获取config文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  --name nginx nginx</span><br><span class="line">docker <span class="built_in">cp</span> nginx:/etc/nginx/nginx.conf ./nginx.conf</span><br><span class="line">docker stop nginx</span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br></pre></td></tr></table></figure><p>在config文件的http内加入如下内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server<span class="punctuation">&#123;</span></span><br><span class="line">listen  <span class="number">443</span> ssl;</span><br><span class="line">server_name $your_ip or website;</span><br><span class="line"></span><br><span class="line">ssl_certificate      /cert/cert.crt;</span><br><span class="line">ssl_certificate_key  /cert/cert.key;</span><br><span class="line"></span><br><span class="line">ssl_session_cache    shared<span class="punctuation">:</span>SSL<span class="punctuation">:</span><span class="number">1</span>m;</span><br><span class="line">ssl_session_timeout  <span class="number">5</span>m;</span><br><span class="line">ssl_ciphers          ECDHE-RSA-AES128-GCM-SHA256<span class="punctuation">:</span>ECDHE<span class="punctuation">:</span>ECDH<span class="punctuation">:</span>AES<span class="punctuation">:</span>HIGH<span class="punctuation">:</span>!NULL<span class="punctuation">:</span>!aNULL<span class="punctuation">:</span>!MD5<span class="punctuation">:</span>!ADH<span class="punctuation">:</span>!RC4;    #加密算法</span><br><span class="line">ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>;    #安全链接可选的加密协议</span><br><span class="line">ssl_prefer_server_ciphers on;   #使用服务器端的首选算法</span><br><span class="line"></span><br><span class="line">location / <span class="punctuation">&#123;</span></span><br><span class="line">proxy_pass http<span class="punctuation">:</span><span class="comment">//$your_proxy_ip:$your_proxy_port;</span></span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">            proxy_set_header Accept-Encoding gzip;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用nginx反向代理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always -p <span class="variable">$your_port</span>:443 --name nginx -v <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span>/nginx.conf:/etc/nginx/nginx.conf -v <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span>/cert:/cert nginx</span><br></pre></td></tr></table></figure><p>更新nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试配置文件</span></span><br><span class="line">docker <span class="built_in">exec</span> nginx nginx -t </span><br><span class="line"><span class="comment">#更新nginx配置</span></span><br><span class="line">docker <span class="built_in">exec</span> nginx nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自签名ca证书&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#自签名ca证书&quot;&gt;&lt;/a&gt; 自签名ca证书&lt;/h2&gt;
&lt;p&gt;首先创建cert文件夹保存证书。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="linux" scheme="https://booiris.space/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Data Lab</title>
    <link href="https://booiris.space/pages/csapp/Data%20Lab.html"/>
    <id>https://booiris.space/pages/csapp/Data%20Lab.html</id>
    <published>2022-05-03T15:24:12.000Z</published>
    <updated>2022-06-10T00:20:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="csapp-data-lab"><a class="markdownIt-Anchor" href="#csapp-data-lab"></a> CS:APP Data Lab</h1><h2 id="restriction"><a class="markdownIt-Anchor" href="#restriction"></a> restriction</h2><ol><li>Integer constants 0 through 255 (0xFF), inclusive. You are<br />not allowed to use big constants such as 0xffffffff.</li><li>Function arguments and local variables (no global variables).</li><li>Unary integer operations ! ~</li><li>Binary integer operations &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>NOT ALLOW<ol><li>Use any control constructs such as if, do, while, for, switch, etc.</li><li>Define or use any macros.</li><li>Define any additional functions in this file.</li><li>Call any functions.</li><li>Use any other operations, such as &amp;&amp;, ||, -, or ?:</li><li>Use any form of casting.</li><li>Use any data type other than int.  This implies that you<br />cannot use arrays, structs, or unions.</li></ol></li></ol><h2 id="question"><a class="markdownIt-Anchor" href="#question"></a> Question</h2><h3 id="q1"><a class="markdownIt-Anchor" href="#q1"></a> q1</h3><h4 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h4><p>bitXor - x^y using only ~ and &amp;.</p><h4 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h4><p>bitXor(4, 5) = 1</p><h4 id="answer"><a class="markdownIt-Anchor" href="#answer"></a> Answer</h4><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>x</mi><mo>⊕</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mo>∼</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mo>∼</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∼</mo><mo stretchy="false">(</mo><mo>∼</mo><mo stretchy="false">(</mo><mo>∼</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∧</mo><mo>∼</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mo>∼</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>x</mi><mo>⊕</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∨</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mo>∼</mo><mi>x</mi><mo>∨</mo><mo>∼</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∼</mo><mo stretchy="false">(</mo><mo>∼</mo><mi>x</mi><mo>∧</mo><mo>∼</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∧</mo><mo>∼</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}x \oplus y &amp;= (\sim x \wedge y) \vee (x \wedge \sim y) = \sim(\sim(\sim x \wedge y) \wedge \sim(x \wedge \sim y)) \\x \oplus y &amp;= (x \vee y) \wedge (\sim x \vee \sim y) = \sim(\sim x \wedge \sim y) \wedge \sim (x \wedge y)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∧</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">∧</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∧</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mord">∨</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mord">∧</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">∧</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Compare eq1 and eq2, eq1 uses five NOT operations and three AND operations, eq2 uses four NOT operations and three AND operations. Therefore eq2 is better.</p><h4 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ~(x &amp; y) &amp; ~(~x &amp; ~y);</span><br><span class="line">    <span class="comment">// return ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="q2"><a class="markdownIt-Anchor" href="#q2"></a> q2</h3><h4 id="description-2"><a class="markdownIt-Anchor" href="#description-2"></a> Description</h4><p>tmin - return minimum two’s complement integer.</p><p>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;.</p><h4 id="answer-2"><a class="markdownIt-Anchor" href="#answer-2"></a> Answer</h4><p>For data of type int, the minimum value is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> which is expressed in binary as 1|0x31.</p><h4 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> Code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="q3"><a class="markdownIt-Anchor" href="#q3"></a> q3</h3><h4 id="description-3"><a class="markdownIt-Anchor" href="#description-3"></a> Description</h4><p>IsTmax - returns 1 if x is the maximum, two’s complement number, and 0 otherwise.</p><p>Legal ops: ! ~ &amp; ^ | +.</p><h4 id="answer-3"><a class="markdownIt-Anchor" href="#answer-3"></a> Answer</h4><p>Notice that only when x = -1 or x = INT_MAX, x^(x+1) = 0xffffffff.</p><p>Therefore, we can use a = ~(x ^ (x+1)) to find INT_MAX and -1. when a = 0, x = INT_MAX or -1.</p><p>Next step we need to distinguish INT_MAX and -1. Notice that -1 + 1 = 0. So we can use b = !(x+1) to find -1. when b = 0, x = INT_MAX; b = 1, x = -1.</p><p>At Last, we can use res = !(a | b) to check whether x is INT_MAX.</p><h4 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> Code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = x + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a = ~(x ^ temp);</span><br><span class="line">    <span class="keyword">return</span> !((!temp) | a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="q4"><a class="markdownIt-Anchor" href="#q4"></a> q4</h3><h4 id="description-4"><a class="markdownIt-Anchor" href="#description-4"></a> Description</h4><p>allOddBits - return 1 if all odd-numbered bits in word set to 1 where bits are numbered from 0 (least significant) to 31 (most significant).</p><h4 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> Example</h4><p>Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1.</p><h4 id="answer-4"><a class="markdownIt-Anchor" href="#answer-4"></a> Answer</h4><p>We can use (x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA to check if all odd-numbered bits in word set to 1.</p><p>Therefore it’s important to get a constant 0xAAAAAAAA.</p><p>Since we can only use 0 ~ 0xff, we can simply repeate flowing code four times to get 0xAAAAAAAA.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key |= <span class="number">0xaa</span>;</span><br><span class="line">key &lt;&lt;= <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>However, it will cost 2 * 4 = 8 operations. We can use a better way to get constant.</p><ol><li>get a = 0xAA.</li><li>get b = 0xAAAA.</li><li>get c = 0xAAAAAAAA.</li></ol><p>It’s a bit like binary serach. Every time we can construct double length number. Therefore to build a 32 bits number, we just use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mfrac><mn>32</mn><mn>4</mn></mfrac><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">log(\frac{32}{4}) = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> operations to get the number.</p><h4 id="code-4"><a class="markdownIt-Anchor" href="#code-4"></a> Code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0xaa</span>;</span><br><span class="line">    <span class="type">int</span> b = a | a &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> c = b | b &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !((x &amp; c) ^ c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="q5"><a class="markdownIt-Anchor" href="#q5"></a> q5</h3><h4 id="description-5"><a class="markdownIt-Anchor" href="#description-5"></a> Description</h4><p>negate - return -x</p><h4 id="example-3"><a class="markdownIt-Anchor" href="#example-3"></a> Example</h4><p>Example: negate(1) = -1.</p><h4 id="answer-5"><a class="markdownIt-Anchor" href="#answer-5"></a> Answer</h4><p>Since x + ~x = -1, we can change it to -x = ~x + 1.</p><h4 id="code-5"><a class="markdownIt-Anchor" href="#code-5"></a> Code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="q6"><a class="markdownIt-Anchor" href="#q6"></a> q6</h3><h4 id="description-6"><a class="markdownIt-Anchor" href="#description-6"></a> Description</h4><p>isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)</p><h4 id="example-4"><a class="markdownIt-Anchor" href="#example-4"></a> Example</h4><p>isAsciiDigit(0x35) = 1.</p><p>isAsciiDigit(0x3a) = 0.</p><p>isAsciiDigit(0x05) = 0.</p><h4 id="answer-6"><a class="markdownIt-Anchor" href="#answer-6"></a> Answer</h4><p>%TODO</p><h4 id="code-6"><a class="markdownIt-Anchor" href="#code-6"></a> Code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> key = <span class="number">0x3</span>;</span><br><span class="line">    <span class="type">int</span> check1 = !(key ^ a);</span><br><span class="line">    <span class="type">int</span> check2 = !((x &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> check3 = !(x ^ <span class="number">0x38</span>);</span><br><span class="line">    <span class="type">int</span> check4 = !(x ^ <span class="number">0x39</span>);</span><br><span class="line">    <span class="keyword">return</span> check1 &amp; (check2 | check3 | check4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="q7"><a class="markdownIt-Anchor" href="#q7"></a> q7</h3><h4 id="description-7"><a class="markdownIt-Anchor" href="#description-7"></a> Description</h4><p>conditional - same as x ? y : z</p><h4 id="example-5"><a class="markdownIt-Anchor" href="#example-5"></a> Example</h4><p>Example: conditional(2,4,5) = 4</p><h4 id="answer-7"><a class="markdownIt-Anchor" href="#answer-7"></a> Answer</h4><p>At first, we can use x = !x to make <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo stretchy="false">{</mo><mi>x</mi><mo mathvariant="normal">≠</mo><mn>0</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(x)= 0 \{x\neq 0\}, 1 \{x = 0\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">}</span></span></span></span>.</p><p>With x = ~x  + 1, we can get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mo stretchy="false">{</mo><mi>x</mi><mo mathvariant="normal">≠</mo><mn>0</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mn>0000</mn><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">g(x) = ffff \{x\neq 0 \}, 0000\{x=0\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">}</span></span></span></span>.</p><p>Notice that y ^ y  ^ z = z, y ^ 0 = y. Therefore, we can use y ^ ((y ^ z) &amp; x) to get answer. When x = 0, (y ^ z) &amp; x = y ^ z, otherwise, (y ^ z) &amp; x = 0.</p><h4 id="code-7"><a class="markdownIt-Anchor" href="#code-7"></a> Code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    x = !x;</span><br><span class="line">    x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> y ^ ((y ^ z) &amp; x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;csapp-data-lab&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#csapp-data-lab&quot;&gt;&lt;/a&gt; CS:APP Data Lab&lt;/h1&gt;
&lt;h2 id=&quot;restriction&quot;&gt;&lt;a class=&quot;markdow</summary>
      
    
    
    
    <category term="csapp" scheme="https://booiris.space/categories/csapp/"/>
    
    
  </entry>
  
</feed>
