[{"title":"金字塔原理","path":"/pages/read_notes/金字塔原理.html","content":"概述 本书分为4个部分。 第1篇　表达的逻辑　介绍了金字塔原理的基本概念，以及如何利用这一原理构建基本的金字塔结构。本篇的内容足以使你理解和应用简单的公文写作技巧。 第2篇　思考的逻辑　介绍了如何深入细致地把握思维的细节，以保证你使用的语句真实、明确地呈现你希望表达的思想。本篇举了许多案例，突出了迫使自己进行“冷静思考”对明确阐述思想的重要性。 第3篇　解决问题的逻辑　读者对象是需要写研究报告的人，以及需要分析复杂问题、提出结论以作出决策的人。本篇介绍了如何在解决问题过程的不同阶段，使用多种框架组织分析过程，使你的思路实际上进行了预先组织，从而可以更方便地应用金字塔原理。 第4篇　演示的逻辑　介绍了设计 PowerPoint 演示幻灯片的技巧，可以帮助你在用演示文稿呈现具有金字塔结构的思想时，使读者或观众感受到金字塔结构。 (用不到先不看了) 第一篇 表达的逻辑 第一篇主要所写的是如何让文章更易理解的方法论。方法论的阐释往往需要辅以具体事例，文中也举例了一些事例进行说明。但本章既然是讲述写作的方法论，那么不如直接以原文章的行文顺序做例子，看看原文是否实现了自己提出的方法论的自举( 。 核心观点 对受众（包括读者、听众、观众或学员）来说，最容易理解的顺序是：先了解主要的、抽象的思想，然后了解次要的、为主要思想提供支持的思想。因为主要思想总是从次要思想概括总结得出，文章中所有思想的理想组织结构也必定是一个金字塔结构——由一个总的思想统领多组思想。 在本篇开头，一堆引言结束后作者提出了本篇的核心观点: 写作需要按照金字塔的结构，首先提出主要思想，然后介绍多组次要思想支持主要思想。每组思想间的联系可以是纵向的 (即上层思想是对下层的总结)，也可以是横向的 (即多个思想组成同一个逻辑推理过程，而被并列排在一起)。(怎么感觉在教高中议论文😂) #todo 加个思维导图 1.1 为什么要用金字塔结构 第二篇 思考的逻辑 第三篇 解决问题的逻辑","categories":["read_notes"]},{"title":"sicp 章节1","path":"/pages/sicp/sicp 章节1.html","content":"题解: SICP-learning/exercise_1 at master · booiris/SICP-learning · GitHub 1. Building Abstractions With Procedures sicp 前面部分介绍的内容还是比较基础的，具体是在介绍程序是什么。 We are about to study the idea of a computational process. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program. – computational process (即计算过程) 是操作数据的过程，这一过程的实现由一组定义的规则(程序)完成。 从中可以看出编写的计算机程序有两个重要的元素: 数据 操作数据的行为 笔者认为我们编写的程序就是处理数据的过程，是对数据的各种加工变换(这就是为啥一个好的类型系统那么重要，土法炼钢不可取，此处@某一个大道至简的语言😚为啥 go 不支持泛型方法)。 1.1 The elements of Programming 本节开始又到了最喜欢的概念定义环节，一个成熟的语言需要以下三种结构： primitive expressions, which represent the simplest entities the language is concerned with, means of combination, by which compound elements are built from simpler ones, and means of abstraction, by which compound elements can be named and manipulated as units. 具体来说就是需要 基本表达式，表示语言中的一些基础的实体，比如变量和基本类型等 组合算子，能够从简单的元素构建出复杂的运算，比如运算符和函数调用等 抽象方式，能够将一组过程或者数据类型封装合并为一个单元，比如变量定义、函数定义和抽象数据类型的定义 之后，文中再次强调了程序中最重要的两个元素，过程和数据(但实际上过程也可以认为是一种数据(有没有函数是一等公民的即视感) )： In programming, we deal with two kinds of elements: procedures and data. (Later we will discover that they are really not so distinct.) 1.1.1 Expressions 基本上是在通过介绍 lisp 中的一些语法来阐释 expressions 这一概念（不过 lisp 是前缀表达式还真是反直觉👾，当然把运算符当成函数调用看能好一点，也确实能更好表达函数复合等概念，但还是难受🤖）。 一些表达式例子: 123123(+ 1 2)(* (+ 1 2) 4) 后面带运算符的表达式被称为组合式。 1.1.2 Naming and the Environment 介绍了 lisp 的变量定义方式，还捎带讲了下变量作用域的概念。 1.1.3 Evaluating Combinations 介绍了 lisp 计算组合式的方式： 计算组合式需要首先计算所有子表达式，是一个递归计算的过程。 自左向右计算值。 计算组合式的过程构成了一个多叉树，计算组合式的过程就是计算一个个基本表达式的过程，而构成基本表达式的规则为： 数值的值就是它们所代表的数字本身 (有点怪怪的，应该指的是 数值是最基本的元素，参与运算的实际上是具体的数值。比如计算 x=2， + x 1 时，实际上是计算 + 2 1，在计算的过程中变量已经替换为具体的值了)。 表达式中有一些基本内置运算符，对应着完成相应操作的机器指令。 表达式中还存在着一些变量，这些变量指向当前作用域中的一个特定对象。所以变量不能脱离作用域，单纯的 (+ x 1) 是无意义的，无法计算出它的值。 1.1.4 Compound Procedures 这一章介绍的是 lisp 中函数的定义方法，在文中被称为 “compound procedure”。 lisp 的函数定义语法形式为： 1( define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt; ) 1.1.5 The Substitution Model for Procedure Application 本章讲的是 lisp 计算自定函数的过程，和 1.1.3 Evaluating Combinations 中计算组合式的过程类似。在本章中使用了 “substitution model” (替换)来解释运算过程。 例: 对于如下函数 12345(define (square x) (* x x) )(define (sum-of-squares x y)\t(+ (square x) (square y) ) )(define (f a)\t(sum-of-squares (+ a 1) (* a 2) ) ) 计算 (f 5) 的过程如下: 1234567(f 5) -&gt;(sum-of-squares (+ 5 1) (* 5 2) ) -&gt;(sum-of-squares 6 10) -&gt;(+ (square 6) (square 10) ) -&gt;(+ (* 6 6) (* 10 10) ) -&gt;(+ 36 100) -&gt;136 substitution model 就是将实际的运算式替换函数名的过程。但这并不是lisp 的实际运算过程。在后续 3、4、5 章会更详细地讲述这一过程。 计算表达式的顺序 在上面举例计算 (f 5) 的过程中可以发现，我们是在遇到可计算的基本表达式时就直接计算出对应的值。然而还有另一种计算的方式，就是在计算表达式的过程中只展开表达式，而不计算值，当整个表达式被展开成只由基本表达式组成时，再计算出值。 12345(f 5) -&gt;(sum-of-squares (+ 5 1) (* 5 2) ) -&gt;(+ (square (+ 5 1)) (square (* 5 2) ) ) -&gt;(+ (* (+ 5 1) (+ 5 1) ) (* (* 5 2) (* 5 2) ) ) -&gt;136 这种完全展开的计算过程被称为 normal-order evaluation (正则序求值)，先求值再代入函数调用的被称为 applicative-order evaluation (应用序求值)。 lisp 中采用的是后面一种计算方式，部分原因在于其能够避免对表达式的重复求值。对于人类来说，完全展开然后计算从直觉上感觉就十分麻烦，但其也有特殊用处，可以用于处理无法求值的表达式，第三章讨论了使用正则式定义的流式过程，用于处理无限数据结构。 1.1.6 Conditional Expressions and Predicates 这一章介绍了 lisp 中的分支语法，语法形式为： 1234(cond (⟨p₁⟩ ⟨e₁⟩) (⟨p₂⟩ ⟨e₂⟩) … (⟨pₙ⟩ ⟨eₙ⟩)) 还有个 if 语法糖，语法形式为： 1(if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩) 分支语法关联的逻辑运算符为： 123(and ⟨e₁⟩ … ⟨eₙ⟩)(or ⟨e₁⟩ … ⟨eₙ⟩)(not ⟨e⟩) 1.1.7 Example: Square Roots by Newton’s Method 首先，如 1. Building Abstractions With Procedures 中所言，procedures 是操作数据的过程，这很像常规的数学函数，通过输出一些值，经过一些运算然后得到一些值。但和数学上的函数不一样的点在于，程序中的函数必须是可行的。 以计算平方根为例，在数学上定义平方根 yyy 为 y=x,wherey≥0andy2=xy = \\sqrt{x} , \\quad where \\quad y \\geq 0 \\quad and \\quad y^2 = x y=x​,wherey≥0andy2=x 非常的清晰，但也非常的抽象，这个函数只给出了什么是平方根函数(平方的逆函数)，但并没有给出怎么计算一个值的平方根。在书中提到这反映了说明性描述和过程性描述的区别，即使给出了一个函数的定义，但推出它的具体实现也是很困难的。 最常用的计算平方根的方法为牛顿迭代法，其过程用如下代码表示： 12345678910111213141516(define (sqrt-iter guess x)\t(if (good-enough? guess x) guess (sqrt-iter (improve guess x) x)))(define (improve guess x)\t(average guess (/ x guess)))(define (average x y)\t(/ (+ x y) 2))(define (good-enough? guess x)\t(&lt; (abs (- (* guess guess) x)) 0.001))(define (sqrt x)\t(sqrt-iter 1.0 x)) 文字描述为不断使用一种方法猜测一个数，计算它的平方，使得平方值不断逼近给定的被开方数。 1.1.8 Procedures as Black-Box Abstractions 这一章讲述了将程序作为黑箱抽象的重要性。这个没啥好说的，好是很好，但不恰当地执行就容易变得更加抽象🤣。 接口和实现分离：程序的接口（输入输出）和实现（内部细节）是分离的。用户通过接口使用程序，而不需要了解实现细节。 信息隐藏：通过隐藏不必要的实现细节，可以减少认知负担，使程序更易于理解和使用。 模块化设计：通过将程序分解为独立的模块，每个模块实现特定的功能，可以提高程序的可维护性和可扩展性。 1.2 Procedures and the Processes They Generate 在第一节讲述了什么是程序，但并没有讲该怎么写程序。这就相当于我们了解了下棋的规则，但还是不知道下棋的策略。这一节就是通过一些算法介绍一些常见的程序结构。(说实在的 sicp 的精华都在后几章，前面的太基础有点想跳过了…) 1.2.1 Linear Recursion and Iteration 这一小节通过计算阶乘介绍什么是递归和迭代结构。 定义阶乘: n!=n×(n−1)×(n−2)×⋯×2×1n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 2 \\times 1 n!=n×(n−1)×(n−2)×⋯×2×1 递归结构 根据数学定义，能够很容易地写出计算程序为: 123(define (factorial n) (if ( = n 1) 1 ( * n (factorial (- n 1))) ) ) 根据 1.1.5 The Substitution Model for Procedure Application 中所讲的，上述程序展开的计算过程为如下图: 迭代结构 我们可以换个顺序计算阶乘, 从 111 开始乘，直到乘到 nnn ，计算的程序为： 1234567(define (factorial n) (factorial-iter 1 1 n) )(define (factorial-iter res now max-iter-count) (if (= now max-iter-count) (* res now) ( factorial-iter (* res now) (+ now 1) max-iter-count ) ) ) 这个程序的展开计算过程为: 可以看出，计算同一个数学公式，上面两种的计算过程完全不同。 对于递归结构，它的表现是一种展开又收缩的过程，展开表现为程序构建了一系列的 “deferred operations”，收缩表现为在完全展开后这些运算的实际计算过程，解释器在计算的时候需要存储这些运算过程。在计算 n!n!n! 的时候，存储的表达式随着 nnn 线性增长，这被称为线性递归结构。 与之相对应的，第二种计算过程为迭代计算结构，可看出，解释器并不需要保存运算的过程，需要保存的是变量 res now max-iter-count 。一般来说，迭代计算过程就是那种可以使用固定变量表达计算状态的过程，同时它还有一个从当前状态转移到下一个状态的过程，还有一个表达式表达这个计算过程何时终止。在计算 n!n!n! 的时候，计算的表达式随着 nnn 线性增长，这种被称为线性迭代结构。 tips: 本章练习可以使用 trace 打印计算过程。 1.2.2 Tree Recursion 本小节通过计算斐波那契数列介绍树形递归结构，斐波那契数列为如下数列: 0,1,1,2,3,5,8,…0,1,1,2,3,5,8,\\dots 0,1,1,2,3,5,8,… 满足如下定义: F0=0F1=1Fn=Fn−1+Fn−2(n≥2) \\begin{aligned} F_0 &amp;= 0 \\\\ F_1 &amp;= 1 \\\\ F_n &amp;= F_{n-1} + F_{n-2} (n \\ge 2 ) \\end{aligned} F0​F1​Fn​​=0=1=Fn−1​+Fn−2​(n≥2)​ 它的对应程序为 12345(define (fib n) (cond [(= n 0) 0] [(= n 1) 1] [else (+ (fib (- n 1)) (fib (- n 2)))])) 它的对应计算过程为: 从计算图中可以看出，树形递归结构有许多冗余的计算，像 fib 2 就计算了三次。为了减少这种计算，我们可以使用一些变量存储当前计算的状态，下面的计算斐波那契数列的迭代结构: 12345(define (fib n) (fib-iter 0 1 n))(define (fib-iter now next count) (if (= count 0) now (fib-iter next (+ now next) (- count 1)))) 显然，这种方式计算 fib n 的时间复杂度是 O(n) 的。尽管后一种结构相较于第一种结构速度更优，但第一种是最直观的，迭代法 (动态规划) 的关键在于找到能够代表当前状态的一组变量，这往往是比较难想到的，书中之后就给了个分钱币的例子，使用树形递归能够很容易写出问题的递归形式，但迭代形式却相对困难，书中作为思考题。背包问题太基础了就不说了，跳过。 1.2.3 Orders of Growth 这章讲的是什么是时间复杂度，跳过吧 后面几节基本是在介绍一些基础的算法。 1.2.4 Exponentiation 介绍快速幂，跳了 1,2.5 Greatest Common Divisors 介绍计算最大公约数的方法，经典的 Euclid’s Algorithm，其中简略地提到了时间复杂度的证明方法： 1.2.6 Example: Testing for Primality 介绍素数检测的方法，根号下遍历 和 费马测试(这玩意写不写呢…)， 1.3 Formulating Abstractions with Higher-Order Procedures 在经过了一系列算法的洗礼后，我们需要换换口味，来了解一些更加偏向 pl 的知识。本节介绍的是对过程使用高阶函数进行抽象。(高阶函数本质就是能够接受函数作为参数的函数) 1.3.1 Procedures as Arguments 本节首先提出了一个场景: 计算 从 a 到 b 的和、平方和、指定序列和。常规来说可以写出如下代码: 12345678910111213141516(define (sum-integers a b) (if (&gt; a b) 0 (+ a (sum-integers (+ a 1) b))))(define (sum-cubes a b) (if (&gt; a b) 0 (+ (cube a) (sum-cubes (+ a 1) b))))(define (pi-sum a b) (if (&gt; a b) 0 (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b)))) 显然，这些代码除了函数名和内部计算函数不同之外，其余的几乎没有区别，我们可以从数学的角度上看待这些过程: 数学上，对于 a 到 b 的求和可以表示为 ∑n=abf(n)=f(a)+⋯+f(b)\\sum_{n=a}^{b} f(n) = f(a) + \\dots + f(b) n=a∑b​f(n)=f(a)+⋯+f(b) 其中 f(n) 就是可以替换的函数。 对与如上的过程，我们可以写出如下的函数: 12345(define (sum term a next b) (if (&gt; a b) 0 (+ (term a) (sum term (next a) next b)))) 于是如上的过程可以被写成: 12345678910(define (inc n) (+ n 1))(define (identity x) x)(define (sum-integers a b) (sum identity a inc b))(define (sum-cubes a b) (sum cube a inc b)) 1.3.2 Constructing Procedures Using Lambda 介绍 lisp 匿名函数还有使用 let 创建局部变量，用于简化高阶函数的输入。 1.3.3 Procedures as General Methods 1.3.4 Procedures as Returned Values","tags":["sicp"],"categories":["sicp"]},{"title":"rust 反序列化时的 zero copy","path":"/pages/blog/rust 反序列化时的 zero copy.html","content":"Not a Yoking Matter (Zero-Copy #1) - In Pursuit of Laziness","categories":["blog"]},{"title":"使用 rust 游玩 cf 的姿势","path":"/pages/blog/使用 rust 游玩 cf 的姿势.html","content":"cf 是什么 具体来说就是 穿越火线是一款非常受欢迎的第一人称射击网络游戏，它也被称作&quot;CrossFire&quot;。它最早由韩国SmileGate公司开发，后来在中国由腾讯公司运营。这个游戏在中国有着庞大的玩家基础，在亚洲其他地区以及全球也有相当多的粉丝。 游戏提供了多种模式，包括经典的团队对战、爆破模式、生化模式等。玩家能选择成为全球反恐精英的一员，或者加入恐怖分子阵营。在游戏中，玩家可以购买和升级各种武器装备，与队友协同作战，完成不同的任务和挑战。 Codeforces 是一个在线编程和算法竞赛平台，广受全球程序员和算法爱好者的欢迎。它提供了一个平台，用户可以通过参加定期举办的编程比赛来提高自己的编程技能和算法知识。这些比赛通常分为几个不同的难度等级，适合从初学者到高级程序员的各个水平。 在Codeforces上，参赛者需要在限定时间内解决一系列编程问题。这些问题覆盖了数据结构、算法、数学、字符串处理、图论等众多领域。参赛者的表现根据解决问题的速度和正确性来评分，并在全球范围内进行排名。 – chatgpt 生成 网站: Codeforces rust 是什么 具体来说就是 《Rust》是一款多人生存游戏，玩家需收集资源，建造庇护所，与环境和其他玩家互动以求生存。游戏以其开放世界、真实的生存挑战和玩家之间的复杂互动闻名。 Rust是一种开源的系统编程语言，以安全性、速度和并发性为设计目标。它旨在帮助开发者构建高效、可靠的软件，同时避免常见的内存安全错误，如缓冲区溢出。Rust通过一套严格的编译时检查机制实现这些目标，而无需依赖于传统的垃圾回收机制或大量的运行时检查。 Rust的设计充分考虑了现代硬件的特性，提供了零成本抽象、安全的并发编程模型，以及对内存布局的精细控制。这些特性使Rust成为开发操作系统、游戏引擎、浏览器组件以及需要高性能和高可靠性的应用程序的理想选择。 – chatgpt 生成 网站: Rust Programming Language 正文 rust 标准库只提供了一些基本和常用的数据结构和一套&quot;抽象特性&quot;(或者说规范)，所以可能需要手动造一些轮子，比如处理输入和随机数生成等等，下面将介绍对应的实现代码。 处理输入 相较于 c++ 的 scanf 、cin ，rust 的标准库中缺少一种方便地从标准输入中读取并构造数据的方法，网上也存在一些讨论: Why is it so difficult to get user input in Rust? - help - The Rust Programming Language Forum Why is it so painful to read user inputs in Rust 所以使用 rust 解决 codeforces 中的问题所遇到的第一个困难就是如何处理输入，所幸的是这个问题在这里有所讨论，具体的解决方法参考这个回复。根据讨论中的代码修改，笔者使用的模板代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pub struct Scanner&lt;B&gt; &#123; reader: B, buf_str: Vec&lt;u8&gt;, buf_iter: std::str::SplitWhitespace&lt;&#x27;static&gt;,&#125;impl&lt;B: BufRead&gt; Scanner&lt;B&gt; &#123; pub fn new(reader: B) -&gt; Self &#123; Self &#123; reader, buf_str: Vec::new(), buf_iter: &quot;&quot;.split_whitespace(), &#125; &#125; pub fn sc&lt;T: std::str::FromStr&gt;(&amp;mut self) -&gt; T &#123; loop &#123; if let Some(token) = self.buf_iter.next() &#123; return token.parse().ok().expect(&quot;Failed parse&quot;); &#125; self.buf_str.clear(); self.reader .read_until(b&#x27; &#x27;, &amp;mut self.buf_str) .expect(&quot;Failed read&quot;); self.buf_iter = unsafe &#123; let slice = std::str::from_utf8_unchecked(&amp;self.buf_str); std::mem::transmute(slice.split_whitespace()) &#125; &#125; &#125;&#125;static mut IN: *mut Scanner&lt;StdinLock&lt;&#x27;static&gt;&gt; = std::ptr::null_mut();#[allow(unused_macros)]macro_rules! i &#123; () =&gt; &#123;&#123; i!(i32) &#125;&#125;; ($t:ty) =&gt; &#123;&#123; unsafe &#123; (*IN).sc::&lt;$t&gt;() &#125; &#125;&#125;;&#125;// 使用方法fn main() &#123;\t// 需要首先初始化全局的读入器。 unsafe &#123; IN = Box::leak(Box::new(Scanner::new(io::stdin().lock()))) as *mut Scanner&lt;StdinLock&lt;&#x27;_&gt;&gt;; &#125;\tlet t = i!(String); // 从标准输入中读入一个 string。\tlet a = i!(); // 默认读入的类型为 i32。&#125; 下面大致解释一下代码的实现，首先核心的是一个名为 Scanner 的结构体，其中的 Reader 保存了数据的来源，它是一个 trait ，可以认为是任意实现了 std::io::BufRead 这一&quot;规范&quot;的结构体。具体到本代码则为标准输入流。buf_str 则是用于储存从 reader 中获取的数据(每次以行为单位读取数据)。buf_iter 用于解析和迭代遍历行内的数据。 一个读入的过程为: 从 Reader 中根据换行符为分隔读取数据，保存到 buf_str 中，然后根据空白符做切分保存到 buf_iter 中，然后对每一块做解析转换成需要的格式。 在之后是一个宏，用于优化使用体验。然而一定会使用到全局变量，rust 中对于全局变量的使用较为繁琐，这里采用两种方法: 使用全局裸指针，使用 box::leak 将读取器内存泄漏，然后将裸指针指向这块内存进行调用，不过这个需要用到 unsafe ，由于 codeforces 算法都为单线程，所以不用考虑并发问题，所以这个 unsafe 是可控的。 使用 RefCell 获取内部可变性。 通常来说，应该是使用全局裸指针性能更好，因为 RefCell 会在运行期进行借用检测。但经测试两者的性能差距不明显，所以读者自行选择。 全局读取器使用裸指针和 refcell 性能测试 · GitHub 1234567891011121314151617// RefCell 方式的全局变量thread_local! &#123; pub static STDIN: std::cell::RefCell&lt;Scanner&lt;StdinLock&lt;&#x27;static&gt;&gt;&gt; = std::cell::RefCell::new(Scanner::new(io::stdin().lock()));&#125;#[allow(unused_macros)]macro_rules! safe_i &#123; () =&gt; &#123;&#123; safe_i!(i32) &#125;&#125;; ($t:ty) =&gt; &#123; STDIN.with(|r| &#123; let mut r = r.borrow_mut(); r.sc::&lt;$t&gt;() &#125;) &#125;;&#125; 除了上面的解决方式之外，讨论中还出现了一种解决方式，具体实现原理基本上和 c++ 的快读方式相似，然后通过把快读封装成 trait，给基本类型使用宏实现快读的 trait 实现数据的读入。理论上这种读取方式应该更快，请读者自行取用。 处理输出 对于输出也需要特殊处理一下，使用普通的 println! 宏可能会导致输出时间过长导致超时。原因是每次调用 println! 的时候都会给标准输出上锁。遇到需要许多输出的题目可能会因为频繁上锁解锁导致输出时间过长。 println! 的注释中也提到可以使用 writeln! 宏进行输出。对于输出加锁导致变慢的问题可以使用缓冲区解决。将输出保存到缓冲区中，最后调用 flush! 将缓冲区的内容写入输出流，这样就减少了加锁解锁的时间，实现了快速输出。 1234567891011121314151617181920212223242526272829303132333435363738394041static mut OUT: *mut std::io::BufWriter&lt;std::io::StdoutLock&lt;&#x27;_&gt;&gt; = std::ptr::null_mut();#[allow(unused_macros)]macro_rules! w &#123; ($fmt:expr) =&gt; &#123; unsafe&#123; write!(*OUT, &quot;&#123;&#125;&quot;, $fmt);&#125; &#125;; ($fmt:expr, $($args:tt)*) =&gt; &#123; unsafe&#123; write!(*OUT, $fmt, $($args)*);&#125; &#125;;&#125;#[allow(unused_macros)]macro_rules! wln &#123; () =&gt; &#123; unsafe&#123; writeln!(*OUT);&#125; &#125;; ($fmt:expr) =&gt; &#123; unsafe&#123; writeln!(*OUT, &quot;&#123;&#125;&quot;, $fmt);&#125; &#125;; ($fmt:expr, $($args:tt)*) =&gt; &#123; unsafe&#123; writeln!(*OUT, $fmt, $($args)*);&#125; &#125;;&#125;#[allow(unused_macros)]macro_rules! flush &#123; () =&gt; &#123; unsafe &#123; (*OUT).flush(); &#125; &#125;;&#125;fn main()&#123; OUT = Box::leak(Box::new(io::BufWriter::new(io::stdout().lock()))) as *mut std::io::BufWriter&lt;std::io::StdoutLock&lt;&#x27;_&gt;&gt;; let a: i32 = 1; wln!(); // 输出 wln!(a); // 输出 1 w!(a); // 输出 1 wln!(&quot;test: &#123;&#125;&quot;,a); // 输出 test: 1 flush!(); // 因为全局变量已经主动泄露，所以最后不会自动 drop ，最后需要手动调用 flush 将数据由缓冲区输入到标准输出流&#125; 同样的，对应输出器的全局变量也有两种写法，一种 static mut 的全局变量，一种是 Refcell ，这里作为思考题请读者自行实现。 处理随机数 同样的，rust 的 std 中没有随机数库，需要自己手动造一下轮子。代码来源不可考了，贴一下原始的论文吧： vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf 123456789101112131415161718192021222324252627282930313233343536373839404142#[derive(Debug, Clone, PartialEq, Eq)]struct Rand &#123; s: [u64; 4],&#125;impl Rand &#123; pub fn new(mut state: u64) -&gt; Self &#123; const PHI: u64 = 0x9e3779b97f4a7c15; let mut seed = &lt;[u64; 4]&gt;::default(); for chunk in &amp;mut seed &#123; state = state.wrapping_add(PHI); let mut z = state; z = (z ^ (z &gt;&gt; 30)).wrapping_mul(0xbf58476d1ce4e5b9); z = (z ^ (z &gt;&gt; 27)).wrapping_mul(0x94d049bb133111eb); z = z ^ (z &gt;&gt; 31); *chunk = z; &#125; Self &#123; s: seed &#125; &#125; #[inline] pub fn next_u32(&amp;mut self) -&gt; u32 &#123; (self.next_u64() &gt;&gt; 32) as u32 &#125; #[inline] pub fn next_u64(&amp;mut self) -&gt; u64 &#123; let result_plusplus = self.s[0] .wrapping_add(self.s[3]) .rotate_left(23) .wrapping_add(self.s[0]); let t = self.s[1] &lt;&lt; 17; self.s[2] ^= self.s[0]; self.s[3] ^= self.s[1]; self.s[1] ^= self.s[2]; self.s[0] ^= self.s[3]; self.s[2] ^= t; self.s[3] = self.s[3].rotate_left(45); result_plusplus &#125;&#125; 使用随机化算法的题目不是特别多，具体使用方法请看如下示例: Submission #252682933 - Codeforces 图模板 图的表示一般为邻接表和邻接矩阵。对于邻接矩阵注意如果能用定长数组就用定长数组。而对于邻接表的数据存储可以有两种方式，一种是放在 struct 中，每次创建的时候都分配一次内存，或者将数据存储再全局变量中，动态地扩展长度。从性能测试的结果也能看出后面一种方式是更快的，由于算法题中不涉及到并发问题，所以操作全局变量是安全的，所以请尽情地使用 unsafe 吧( 图结构性能测试 · GitHub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct PathType &#123; from: usize, to: usize, v: i64,&#125;impl fmt::Display for PathType &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123; write!(f, &quot;(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;, self.from, self.to, self.v) &#125;&#125;static mut PATHS: Vec&lt;PathType&gt; = vec![];static mut POINT: Vec&lt;Vec&lt;usize&gt;&gt; = vec![];struct Graph &#123; pub start_from: usize,&#125;#[allow(dead_code)]impl Graph &#123; pub fn new(p_size: usize, start_from: usize) -&gt; Graph &#123; unsafe &#123; PATHS.clear(); POINT.reserve((p_size + start_from).saturating_sub(POINT.capacity())); POINT.clear(); POINT.resize_with(p_size + start_from, || vec![]); &#125; Graph &#123; start_from &#125; &#125; pub fn add_path(&amp;mut self, from: usize, to: usize, v: i64) &#123; unsafe &#123; POINT[from].push(PATHS.len()); PATHS.push(PathType &#123; from, to, v &#125;); &#125; &#125; pub fn add_bi_path(&amp;mut self, from: usize, to: usize, v: i64) &#123; unsafe &#123; POINT[from].push(PATHS.len()); PATHS.push(PathType &#123; from, to, v &#125;); POINT[to].push(PATHS.len()); PATHS.push(PathType &#123; from: to, to: from, v, &#125;); &#125; &#125; pub fn get(&amp;self, now_p: usize) -&gt; impl Iterator&lt;Item = &amp;&#x27;_ PathType&gt; &#123; unsafe &#123; POINT[now_p].iter().map(move |x| PATHS.get_unchecked(*x)) &#125; &#125;&#125;impl fmt::Display for Graph &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123; unsafe &#123; for now_p in self.start_from..POINT.len() &#123; write!(f, &quot;&#123;&#125; -- &quot;, now_p); for path in self.get(now_p) &#123; write!(f, &quot;&#123;&#125; &quot;, path)? &#125; writeln!(f)? &#125; &#125; Ok(()) &#125;&#125; 使用方法参见: Submission #252942104 - Codeforces 柯里化 柯里化在算法题中使用不多，大部分作用都是为了保存局部变量，用于传递给函数(由于 rust 不鼓励使用全局变量，所以容易导致传递较多的变量)。当然这种功能也能使用闭包实现，就请读者自行取用吧。使用方法参见: Submission #252806831 - Codeforces 123456789101112131415#[allow(unused_macros)]macro_rules! curry2 ( ($f:expr) =&gt; &#123; |a| move |b| $f(a, b) &#125;;);#[allow(unused_macros)]macro_rules! curry3 ( ($f:expr) =&gt; &#123; |a| move |b| move |c| $f(a, b, c) &#125;;);// 源自 Rust 如何实现柯里化？ - Spore的回答 - 知乎// https://www.zhihu.com/question/437123518/answer/1655807344 至此，请愉快地使用 rust 受苦玩耍吧(","categories":["blog"]},{"title":"为啥 go 不支持泛型方法","path":"/pages/blog/为啥 go 不支持泛型方法.html","content":"引言 众所周知， go 的泛型并不完善，由于其不支持 parameterized methods (泛型方法)，导致其无法实现 monad、流式调用等等操作。在这个 issue 中 proposal: spec: allow parameterized methods in methods · Issue #49085 · golang/go · GitHub 有着充分的讨论，本文旨在对其中的讨论进行总结(加一点指指点点)，找出 go 是 xx 的原因，如有错误恳请斧正。 有点长的前置知识… 在看 issue 之前，首先介绍一下泛型的通常实现方式，一般有如下几种方式 类型擦除+虚函数表: 这是 Java 泛型的实现方式。在编译时，泛型类型信息会被擦除，所有的泛型被转换为基类 Object (在 go 中相当于将所有的类型变成 interface{} )，编译器同时会在必要时插入类型转换代码来确保类型安全。 模板实例化: C++ 使用模板来实现泛型。在编译时，模板会生成对应于每种具体类型的实例化代码。如 T add(T a, T b) 的泛型方法，对于 add(1,2) 和 add(1.0,2.0) 会生成两个函数 int add(int a, int b) 和 double add( double a, double b) 。 即时编译: How Generics Differ in Java and C# | HackerNoon, C#泛型详解 - 知乎, c# - What is reification? - Stack Overflow，从这些链接可以大致看出，c# 的泛型实现是编译时使用占位符表示泛型类型，然后在运行时动态实例化各种类型。 回到 go 的泛型，实际上 go 的泛型实现方式有三种提案，下面分别介绍这三种提案，有助于后续对 issue 中的讨论进行分析。(本来想简单写写的，写着写着太长了，不想看的请跳至 正文 部分) Stenciling Generics implementation - Stenciling 首先是被称为蜡印(Stenciling) 的实现，实际上这个 c++、rust 的泛型实现方法很相似，都是在编译实例化所有的类型，生成多个对应类型的函数。 对于如下泛型函数: 123func f[T1, T2 any](x int, y T1) T2 &#123; ...&#125; 存在如下两个调用: 12var a float64 = f[int, float64](7, 8.0)var b struct&#123;f int&#125; = f[complex128, struct&#123;f int&#125;](3, 1+1i) 使用 Stenciling 方法会实例化两个类型函数用于调用: 123456func f1(x int, y int) float64 &#123; ... identical bodies ...&#125;func f2(x int, y complex128) struct&#123;f int&#125; &#123; ... identical bodies ...&#125; 由于不是 go 泛型的实际实现，所以其中所提到的命名实现、实例化方法、类型约束和重复实例化代码处理就不细说了。具体提一下其中的问题部分。 问题 对于 Stenciling 方法，提案提出两个问题: 编译期实例化泛型导致编译时间变长 编译期实例化泛型导致生成的代码变多，生成的二进制文件变大，有可能导致 instruction cache miss 和 分支预测失效(为啥?)等问题。 提案末尾中大致提出了使用增量编译减少编译时间、多次调用编译器来去除重复的实例化代码(因为 go 是以包维度进行编译的)等方案。不过这些都不重要，重要的是提案中的一段话: I suspect there will be lots of cases where sharing is possible, if the underlying types are indistinguishable w.r.t. the garbage collector (same size and ptr/nonptr layout) 提案认为尽管类型可以有很多个(如 int 、type IntAlias = int )，但实际上内存布局都是相同的，相同内存布局的值类型可以共享代码，这就减少了生成的代码大小同时也加快了编译时间。实际上这就是 go 实际的泛型实现(GC Shape Stenciling) 。 Dictionaries Generics implementation - Dictionaries 字典(Dictionaries)方式的实现方式正如其名，对于如下泛型函数: 123func f[T1, T2 any](x int, y T1) T2 &#123; ...&#125; 存在如下两个调用: 12var a float64 = f[int, float64](7, 8.0)var b struct&#123;f int&#125; = f[complex128, struct&#123;f int&#125;](3, 1+1i) 那么编译其会实例化一个函数，这个函数的第一个参数是一个字典。同时会有多个字典，每个字典包含一些运行时需要的信息，传入的字典内容由调用点生成和传入: 1234567891011type pos1CallSiteDictionary struct &#123;\t... runtime._type&#125;type pos2CallSiteDictionary struct &#123;\t... runtime._type&#125;func f (type_info dictionary, x int, y T1) T2 &#123; ...&#125; dictionary 包含的信息 对于形如 f [T1, T2] 的泛型函数，所需要的信息如下: Instantiated types 首先需要包含函数签名上的类型，可能以如下形式进行存储 12345type dictionary struct &#123; T1 *runtime._type T2 *runtime._type ...&#125; 出于打印栈的目的，字典中需要包含未被使用的类型，即即使 T2 没有在函数中用到也需要保存 T2 的类型 (为啥不禁止未使用的泛型类型呢…)。 Derived types 除了函数签名上的类型，字典中还需要保存函数中派生出的类型，比如泛型函数中如果定义了如下类型: 12type X struct &#123; x int; y T1 &#125;m := map[string] T1&#123;&#125; 那么需要保存派生出来的类型: 123456type dictionary struct &#123; ... D1 *runtime._type // struct &#123; x int; y T1 &#125; D2 *runtime._type // map[string] T1 ...&#125; Subdictionaries 如果泛型中函数调用了其他的泛型函数，还需要保存对应泛型函数的字典。这样才能接着传递 dictionary 参数，调用对应的泛型函数，提案中称之为子字典: 1234567// func g[T](g T) &#123; ... &#125;// in f[T1]: g[T1] (y)type dictionary struct &#123; ... S1 *dictionary // SubDictionary for call to g ...&#125; Helper methods 字典中还需要保存泛型类型的操作符，比如对于如下运算: 12y2 := y + 1if y2 &gt; y &#123; … &#125; 为了表达泛型操作，需要将其中的 + 和 &gt; 抽象出来变成一种方法保存到字典中: 123456type dictionary struct &#123; ... plus func(z, x, y *T1) // does *z = *x+*y greater func(x, y *T1) bool // computes *x&gt;*y ...&#125; Stack layout 因为类型不确定，字典中还需要保存函数中所有非指针类型临时变量的占用空间，用于分配栈空间。而之前提到过，字典是由调用点传入的，因为只有调用点才知道所有的类型，所以在调用点需要计算所需要的栈空间。然后字典中还需要保存每个临时对象在栈内的地址。 12345678910type dictionary struct &#123; ... frameSize uintptr stackObjects []stackObject ...&#125;type stackObject struct &#123; offset uintptr typ *runtime._type&#125; 对于泛型函数的嵌套调用也需要特殊处理。对于如下函数调用: 12345func f[T1, T2 any](x int, y T1, h func(x T1, y int, z T2) int) T2 &#123; var z T2 .... r := h(y, x, z)&#125; 提案中提出了两种方法: 逐个参数处理 逐个处理参数，将参数复制到栈上正确的位置: 1234567891011argPtr = SPmemmove(argPtr, &amp;y, dictionary.T1.size)argPtr += T1.sizeargPtr = roundUp(argPtr, alignof(int))*(*int)argPtr = xargPtr += sizeof(int)memmove(argPtr, &amp;z, dictionary.T2.size)argPtr += T2.sizecall hargPtr = roundUp(argPtr, 8) // alignment of return value startr = *(*int)argPtr 使用字典存储偏移量 或者提前计算出调用函数的入参出参在栈上的偏移量，然后保存到字典中，使用的时候根据偏移量复制参数: 12345memmove(SP + dictionary.callsite1.arg1offset, &amp;y, dictionary.T1.size)*(*int)(SP + dictionary.callsite1.arg2offset) = xmemmove(SP + dictionary.callsite1.arg3offset, &amp;z, dictionary.T2.size)call hr = *(*int)(SP + dictionary.callsite1.ret1offset) Pointer maps 需要一个 bitMap 存储入参出参的空间大小和是否是指针类型。用于调用者分配空间入参和出参空间。 12345type dictionary struct &#123; ... argPointerMap bitMap // arg size and ptr/nonptr bitmap ...&#125; 问题 提案中提到了虽然采用字典方法减少了代码的生成，但是占用的内存变多了（从上面也可以看出一个泛型示例要存储多少信息）。这也出现了 data cache misses 和 instruction cache misses 的替换。需要找一种折中的方法。 还有提案中提到使用字典方法也有可能导致性能的下降，比如当泛型方法中具体类型为 int 的情况，x=y 的操作在使用蜡印方法可以优化成一次寄存器复制的操作，而使用字典的方法，由于需要处理不同类型的数据，只能使用 memmove 操作复制数据，这无疑是一种额外的开销。 GC Shape Stenciling ！本节的分析基于提案和 go 1.18，部分信息可能和高版本的 go 有所不同，请注意区分。 Generics implementation - GC Shape Stenciling proposal/design/generics-implementation-dictionaries-go1.18.md at master · golang/proposal · GitHub GC Shape Stenciling 是 go 的真正泛型实现。它是 Stenciling 和 Dictionaries 的折中实现。GC Shape 在提案中的解释是: The GC shape of a type means how that type appears to the allocator / garbage collector. 举例来说 int 和 type IntAlias = int 是属于一个 GC Shape，比较特别的是对于所有的指针类型属于一个 GC Shape，使用虚表进行方法的调用。 对于每一个 GC Shape，go 会实例化一个具体的代码，具体来说，对于如下 12345678910111213141516171819package mainfunc f[T any] (t T) T &#123;\tvar x T\treturn x&#125;type MyInt inttype IntAlias = intfunc main() &#123;\tf[int](5)\tf[MyInt](5)\tf[IntAlias](5)\tf[*int](nil)\tf[*MyInt](nil)\tf[interface&#123;&#125;](nil)&#125; 正文 下面终于来到 issue 分析环节。 首先是有人提出由于 go 的泛型不支持 parameterized methods，所以如下代码无法编译: 1func (si *stream[IN]) Map[OUT any](f func(IN) OUT) stream[OUT] 这就导致了在 go 中无法实现常规的流式处理方法。提问人也提出如果 go 能支持 parameterized methods，那么某些领域在构造代码的时候会更加简便，例如(举的例子奇奇怪怪的，看着也没用到 parameterized methods): testing (?): Assert(actual).ToBe(expected) mocking (?): On(obj.Sum).WithArgs(7, 8).ThenReturn(15) 原因 之后有人贴出 go 不支持 parameterized methods 的原因: parameterized methods Proposal。考虑如下代码: 123456789101112131415161718192021222324252627package p1type S struct&#123;&#125;func (S) Identity[T any] (v T) T &#123; return v &#125;package p2type HasIdentity interface &#123;\tIdentity[T any] (T) T&#125;package p3import &quot;p2&quot;func CheckIdentity(v interface&#123;&#125;) &#123;\tif vi, ok := v.(p2.HasIdentity); ok &#123; if got := vi.Identity[int] (0); got != 0 &#123; panic(got) &#125;\t&#125;&#125;package p4import (\t&quot;p1&quot;\t&quot;p3&quot;)func CheckSIdentity() &#123;\tp3.CheckIdentity(p1.S&#123;&#125;)&#125; 在上面的代码中，p1 中的 S 实现了 p2 中的 HasIdentity 接口，在 p3 中有一个函数实现了将入参断言为 HasIdentity 并调用其中的函数的功能。在 p4 中调用了 p3 中的函数并传入了 p1 中定义的 S。 看着还挺合理，但是问题来了，在 p3 中的 CheckIdentity 在断言完入参后，调用了一个类型为 int 的 Identity 函数。根据上面函数的调用链我们可以知道，它其实是在调用 p1.S.Identity[int]，只需要实例化一个 p1.S.Identity[int] 代码块即可。然而，由于 go 的大道至简，类型只有通过 import 才可见，也就是说 p3 是无法感知到 p1.S 这个类型的，所以实例化 p1.S.Identity[int] 也就无从说起了。 之后提案中给出了三个方案: 编译器努努力，根据函数的调用链实例化对应的函数。然而由于 go 中的反射的存在，在编译期实际上无法确定所有的函数调用链 。(这个也是我感觉 go 支持 parameterized methods 里最难受的地方) 学习 java or C#，运行时实例化，这就导致了 go 需要支持某种 JIT，或者使用基于反射的方法，这些实现起来都十分复杂，而且会导致运行时速度变慢。 约束 interface 中禁用 parameterized methods ，因为无法感知类型的原因就是 interface 将实际类型信息隐藏了，不过还是存在反射的问题(直接禁止反射调用泛型函数?)： 1234567type S struct&#123;&#125;func (S) Identity[T any] (v T) T &#123; return v &#125;func main() &#123;\tf, _ := reflect.TypeOf(S&#123;&#125;).MethodByName(&quot;Identity&quot;)\tf.Func.Call([]reflect.Value&#123;reflect.ValueOf(S&#123;&#125;), reflect.ValueOf(0)&#125;)&#125; 在这里我想讲一讲第三点，提案给出的原文是: Or, we could decide that parameterized methods do not, in fact, implement interfaces, but then it’s much less clear why we need methods at all. If we disregard interfaces, any parameterized method can be implemented as a parameterized function. 后面这一段真的是迷惑发言(issue 里有些人也对这段提出疑问)，提案作者认为如果 parameterized methods 不参与 interface 的实现（相当于在 interface 中禁用 parameterized methods 了）, 那为啥还需要 parameterized method，因为所有的 parameterized method 都可以用 parameterized function 实现？？？？ 难不成作者认为 func (S[T]) F[ M, U] ( M ) U 可以简单等效为 func F[T, M, U] (T, M) U ，所以调用方式 x.f(y).g(z) 和 g(f(x,y),z) 没区别 🤔？那 go 语言写起来那么啰嗦的原因找到了(。 具体来说请看这个评论 和这个评论。 后面作者的补充也很迷惑: proposal: spec: allow parameterized methods in methods · Issue #49085 · golang/go · GitHub，不予置评了。 讨论 由于之后的关于解决泛型方法的问题讨论太长，所以接下来省略部分评论(有些不是关于泛型的讨论)并且根据 issue 里提出的不同解决方案进行分类。 gava派 I think that the example issue can be approached the same way as Java does: using interface&#123;&#125; behind the scenes and panic if the customer did a bad assignment (also the compiler could warn about the unsafe operation). –link How about using type erasure to handle the generic method issue? –link interface 代表一切！不过显然 gava 和 anygo 是不行滴。 语法糖派(投降派) Maybe add some syntactic sugar like extension methods in C#. –link Something similar that’s been proposed before and is more explicit and thus feels, at least to me, more Go-like is to add a new operator, such as -&gt; or |&gt;, that chains functions such that a -&gt; f(b, c) is equivalent to f(a, b, c). That would allow the benefit of a method-like ordering to the execution without needing to actually support methods with extra types or method implementations for interface types. –link For the solution #49085 (comment), the problem is that functions with infix are different from normal functions, and it may requires to write a function twice to provide both forms. I’d like to have a new way to call a function at the right position of a value, like using | in template. So I propose following: –link 这一派对 go 语言的泛型彻底的妥协，不要求改变目前的泛型现状，只要求添加一个中缀调用的语法糖(不过这个也老早被 go 团队打了回去)。 在之前提到过，虽然不支持泛型方法 ， func (S[T]) F[ M, U] ( M ) U 也可以由 func F[T, M, U] (T, M) U 替换，但是随之而来的是深层次的调用嵌套，由原本的 x.f(y).g(z) 变成了 g(f(x, y), z) 。如果有一种中缀语法糖 x -&gt; f(y) 表达 f(x,y)，那么 g(f(x, y), z) 就能变成 x -&gt; f(y) -&gt; g(z)，调用嵌套就没有了，流式调用看起来也能写了。(这很难评，加这种晦涩的函数式语法糖不如改进一下泛型) xx派(想不出名字了) 首先因为 go 团队的 less is more 理念，让编译器做分析调用链这么重的活也不太现实（这里也辩解一下，即使调用链分析也无法覆盖反射、传 interface 调用、插件模式等场景，所以调用链分析是不现实的）。 但是禁用整个泛型方法也太过极端了，如果只禁用 interface 中的 parameterized methods ，而放过成员方法的 parameterized methods ，我认为有几点好处吧: 最重要的一点是向下兼容，这种修改没有对 go 的语义有重大改变，同时是大范围约束到小范围约束的过程，不会影响以前的代码运行。 可以用上 monad and stream call 。众所周知，合理地使用函数式能够减少临时变量和冗长的代码。有较大概率能减少下图中的代码(什么时候才能看到这张图不吐槽呢。。。) 实现起来相对的不是特别复杂(相较于分析调用链来说)，因为泛型结构本身是可以具有方法的，也许可能再支持一个泛型方法相对来说没那么困难? 以上为笔者个人观点。实际上，这一派为 issue 中大多数人的观点，其中有几位有较深入的讨论，下面对他们的讨论做下分析: 一 I think this solution makes the most sense. They could then (under the hood) be treated a regular function. The reason why this would be useful is that methods do not only serve the purpose of implementing interfaces; methods also serve as a means of organization for functions that operate on particular structures. It may be a bit of a challenge about how type-parameterized methods would appear in &quot;reflect&quot;, though. – link 把这段话放到第一个的原因是这是第一个提出这一派观点的人，还顺便吐槽了下提案中的 &quot;any parameterized method can be implemented as a parameterized function&quot;😚。 二 I propose two constraints: Generic interfaces must be made “concrete” when used in a type assertion, within a type switch, and when invoking associated methods. By concrete, I mean that all type parameters on the generic interface are specified. Types having generic method(s) cannot be typecast to interface&#123;&#125; or a generic interface unless it is an “instantiated generic type”. By instantiated generic type, I mean a type that has one or more generic method instantiations. – link 对于提案中提出的问题，这位提出了两个约束: 泛型 interface 断言的时候必须指定具体类型。 具有泛型方法的类型除非 在这段讨论中还对反射处理有所补充: On the reflect package, I propose we simply add a new “law of reflection” that says that any compile-time uninstantiated type realizations are unavailable at run-time. –link 非常简单，就是检查泛型函数是否实例化，没有实例化的函数就是一调一个不吱声(panic 就完事了)。 反对派 proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub 总结 考虑到 go 语言团队已经在泛型实现上已经考虑了 10 年达到如今的成就，那么希望 go 团队能在不违反&quot;泛型方法在 interface 中的正交性🤗&quot;的约束下在下个 10 年实现泛型方法吧。在此之前，如果各位看官想使用泛型方法，请看下面评论(","categories":["blog"]},{"title":"monad 粗浅介绍","path":"/pages/blog/monad 粗浅介绍.html","content":"什么是 monad? monad(单子) 是函数式编程中的一种抽象，本文旨在对 monad 的粗浅介绍，所以跳过其数学上的定义和结构性证明(其实是目前笔者也不太懂🤫)，通过一些具体的例子说明它的概念和作用。 定义 尽管没有太复杂的数学概念，但还是需要一个定义说明什么样的东西才能称之为 monad。在接下来的说明中，除了列举出数学定义以外，还有其在 go 语言中的具体表现形式。在 wiki 的定义中: Monad (functional programming) - Wikipedia 一个 monad 包含三个部分: 类型构造子 M 。 在 go 中可以理解为一种名为 M 包裹着 T 的泛型结构体 M&lt;T&gt;&#123; val: T &#125; 类型转换子 Unit :: T -&gt; M T。 在 go 中可以理解为由值 T 构造 M 的函数 func Unit[T any] (val T) -&gt; M&lt;T&gt; 组合子 &gt;&gt;= or FlatMap :: M T -&gt; ( T -&gt; M U) -&gt; M U 。 在 go 中可以理解为 M&lt;T&gt;&#123; val: T &#125; 这个结构体具有一个成员方法 func flatMap[T, U any] (func(T) -&gt; M&lt;U&gt;) -&gt; M&lt;U&gt; ，能够接受一个函数参数实现从 M&lt;T&gt; 到 M&lt;U&gt; 的变换。 那么我们可以称这个具有 FlatMap 方法的 M 为一个 Monad (请注意不是 M&lt;\\T&gt; )。 更严格的定义 一个 monad 还必须含有以下三个约束: 转换子 Unit 是组合子 &gt;&gt;= 的左单位元: Unit &gt;&gt;= f &lt;-&gt; f 。 在 go 中可以理解为：如果有一个函数为 F[ T, U any] (T) M U, 那么 Unit(x).FlatMap(f) 的执行结果和执行 f(x) 结果相同 转换子 Unit 是组合子 &gt;&gt;= 的右单位元: f &gt;&gt;= Unit &lt;-&gt; f 在 go 中可以理解为：如果有一个函数为 F[ T, U any] (T) M U, F(x).FlatMap(Unit) 的执行结果等于 F(x) 组合子 &gt;&gt;= 满足结合律: ma &gt;&gt;= λx -&gt; (f(x) &gt;&gt;= λy -&gt; g(y)) &lt;-&gt; (ma &gt;&gt;= λx -&gt; f(x)) &gt;&gt;= λy -&gt; g(y) 在 go 中可以理解为以下两个过程执行结果相等 123456func F[T, U any](x T) M&lt;U&gt; &#123; f(x) &#125; // f(x) 是对 x 的一些行为func G[U, P any](y U) M&lt;P&gt; &#123; g(y) &#125; // g(y) 是对 y 的一些行为func H[T, P any](x T) M&lt;P&gt; &#123; F(x).FlatMap(G) &#125; // g(f(x))res1 := M&#123;val: x&#125;.FlatMap(H) 1234func F[T, U any](x T) M&lt;U&gt; &#123; f(x) &#125; // f(x) 是对 x 的一些行为func G[U, P any](y U) M&lt;P&gt; &#123; g(y) &#125; // g(y) 是对 y 的一些行为res2 := M&#123; val: x &#125;.FlatMap(F).FlatMap(G) monad 有什么用? 在列举完 monad 的定义后，为了避免陷在抽象的世界里无法自拔，笔者在接下来会具体列举一些例子说明 monad 的作用 。以笔者的观点来说，monad 的作用就是提供了一种隐藏副作用的形式，使得在编写处理函数的时候只用考虑预期的输入，将副作用延续到最后处理。 另一个宇宙的 go error monad 引言 在 go 编程中，可能常见如下代码: 123456789101112131415161718192021222324// 获取要查询的IDfunc GetID (int64) (int64,error) &#123;&#125;// 获取 ID 对应的信息func GetInfo (id int64) (Info,error) &#123;&#125;// 获取上一个 Info 中 uid 对应的信息func GetUserInfo (Info) (UserInfo,error) &#123;&#125;func handle() error &#123;\trawID := 0\tid, err := GetID(rawID)\tif err != nil &#123; return err\t&#125;\tinfo, err := GetInfo(id)\tif err != nil &#123; return err &#125;\tuserInfo, err := GetUserInfo(info)\tif err != nil &#123; return err\t&#125;\t// use userInfo ...&#125; 可以看到 go 的灵魂出现了🤗 当然笔者并不反对 go 这种严格处理每个函数返回的错误值的思想，不过本文既然是有关 monad 的介绍，自然是想着怎么将 monad 套用到 go 的错误处理中。 go 版 monad 式错误处理 回顾 monad 的定义: 首先 monad 是一个结构体: 1234type ErrMonad[T any] struct &#123;\tResult T\tErr error&#125; 上面的结构体包含了返回值和错误。 然后需要一个由 T 构造成 M T 的函数: 123456func Unit[T any] (result T) ErrMonad[T] &#123;\treturn ErrMonad[T]&#123; Result: result,\t&#125;&#125; 有组合子 FlatMap 成员方法: 123456func (h ErrMonad[T]) FlatMap[U] (mapFunc func(T) ErrMonad[U] ) ErrMonad[U] &#123;\tif h.err != nil&#123; return h\t&#125;\treturn mapFunc(h.result)&#125; 有了上述实现后，之前的流程就可以改写为: 1234567891011121314151617181920// 获取要查询的IDfunc GetID (int64) ErrMonad[int64] &#123;&#125;// 获取 ID 对应的信息func GetInfo (id int64) ErrMonad[Info] &#123;&#125;// 获取上一个 Info 中 uid 对应的信息func GetUserInfo (Info) ErrMonad[UserInfo] &#123;&#125;func handle() error &#123;\trawID := Unit(int64(0))\tres := rawID. FlatMap(GetID). FlatMap(GetInfo). FlatMap(GetUserInfo)\tif res.Err != nil&#123; return res.Err\t&#125;\tuserInfo = res.Result\t// use userInfo ...&#125; 可以看出相较于之前的版本，代码更简洁了一些 (至少少了 if err != nil &#123; return err &#125;)。 然而理想是美好的，看着 monad 实现这么简单，为啥群友总说 go 不支持 monad 呢。回看本节标题 “另一个宇宙的 go error monad”，非常遗憾的是，目前的 go 不支持泛型方法参数 Type Parameters Proposal，为啥 go 不支持泛型方法。具体来说就是不支持入参是一个带泛型的方法，即以下函数都是无法实现的: 12345func goIsBest( func[T any] () ) bool &#123; return false &#125;type GGGGGG[T any] struct&#123;&#125;func (GGGGGG[T]) gggggggggggg( func[U any] () ) &#123;&#125;func (GGGGGG[T]) gggggggggggg[U any] () &#123;&#125; 摆个 issue 做参考(希望未来会有解决方法吧): proposal: spec: allow type parameters in methods · Issue #49085 · golang/go · GitHub 这就导致了 FlatMap 方法是不可行的。至此，go 的 monad 之旅到此结束。 附一篇经典的错误处理方法 blog ( 感觉就像一种青春版的 monad，在所举的例子中存在类型只有 io.Writer，所以只用在单个类型里打转，省略了由 T 类型到 U 类型的转换，所以这种形式可以在 go 中实现: Errors are values - Thttps://go.dev/blog/errors-are-valueshe Go Programming Language if err != nil 太烦？Go 创始人教你如何对错误进行编程！ - 知乎 (评论区) monad 如何解决回调地狱 现在让我们来看看一点老(不新又不老)的东西。 引言 各位即使没写过 javascript，也可能听说过回调地狱这个概念，具体来讲这是一种 javascript 异步编程中出现的一种现象。拿Callback Hell中的例子举例吧: 123456789101112131415161718192021222324fs.readdir(source, function (err, files) &#123; if (err) &#123; console.log(&#x27;Error finding files: &#x27; + err) &#125; else &#123; files.forEach(function (filename, fileIndex) &#123; console.log(filename) gm(source + filename).size(function (err, values) &#123; if (err) &#123; console.log(&#x27;Error identifying file size: &#x27; + err) &#125; else &#123; console.log(filename + &#x27; : &#x27; + values) aspect = (values.width / values.height) widths.forEach(function (width, widthIndex) &#123; height = Math.round(width / aspect) console.log(&#x27;resizing &#x27; + filename + &#x27;to &#x27; + height + &#x27;x&#x27; + height) this.resize(width, height).write(dest + &#x27;w&#x27; + width + &#x27;_&#x27; + filename, function(err) &#123; if (err) console.log(&#x27;Error writing file: &#x27; + err) &#125;) &#125;.bind(this)) &#125; &#125;) &#125;) &#125;&#125;) 上面的代码具体作用就是异步执行如下操作: 通过传入的 srouce 读取指定目录下的文件列表，然后使用 gm 函数进行图像处理，保存处理后的图像到目标目录。 可以看到代码的嵌套层级非常深，这就是早期 javascript 异步编程的问题。对于异步函数，需要传入一个回调函数表明在当前状态结束后 (如读取文件结束后) 应该继续执行的动作。可以想象一旦异步处理过程多了，如果没有合适的方法，必然会导致深层次的函数嵌套。一般的做法就是将嵌套的函数抽出来，将异步调用拆解到每个函数中： 123456789101112131415161718main() &#123;\ta(value, b(value, c (value)))&#125;// -------------------------------------------------main() &#123;\ta(value, B)&#125;B(value) &#123;\t// do something\tb(value, c)&#125;c(value) &#123;\t// do something&#125; 但上述做法带来的一个小问题是如果需要了解整个运行的流程，需要不断跳转函数才能知道整个运行逻辑，而不能直接在一个 main 函数中知晓。 异步和 monad 上述问题的根本原因在于异步过 promise 介绍 在 2015 年后，promise 的出现缓解了 javascript 在异步编程中的问题，首先介绍一下什么是 promise: promise 是 javascript 中的一个对象，通过 Promise.resolve 方法可以构造出一个 promise 对象。 12let x = Promise.resolve(123)console.log(x) // Promise &#123; 123 &#125; promise 内部有三种状态 pending 、fulfilled 和 rejected 。他们的作用在这里不深究，只要粗略地了解： fulfilled 可以认为是方法执行成功的状态，rejected 可以认为是方法返回 error 的状态。 promise 有三个成员方法 then ，catch 和 finally。这里只介绍 then 和 catch 方法。 then 方法接受两个类型为函数的参数，一个是当状态为 fulfilled 的时候调用，另一个为 rejected 的时候调用。一般来说，笔者喜欢只传前一个参数，第二个参数使用缺省值，即只有在状态为成功的时候才执行传入的函数。具体代码例子如下: 12345let x = Promise.resolve(&quot;now&quot;)x.then((x) =&gt; &#123; console.log(&quot;pre: &quot;, x, &quot;running 1&quot;) return Promise.resolve(&quot;run1&quot;)&#125;) 和 then 类似，catch 方法接受一个类型为函数的参数，当状态为 rejected 会调用，具体代码例子如下: 1234let x = Promise.reject(&quot;now&quot;)x.catch((reason) =&gt; &#123; console.log(&quot;break at &quot; + reason)&#125;) promise 和 monad 在了解了 promise 的概念后，可以看出 promise 非常像一个 monad。下面来点证明： 类型构造子：Promise &lt; T &gt; 类型转换子：Promise.resolve 组合子：Promise&lt; T &gt;.then( (value: T) =&gt; U ) 1234567891011121314151617181920let x = Promise.resolve(&quot;now&quot;)console.log(x)x.then((x) =&gt; &#123; console.log(&quot;pre: &quot;, x, &quot;run1&quot;) return Promise.resolve(&quot;run1&quot;)&#125;).then((x) =&gt; &#123; console.log(&quot;pre: &quot;, x, &quot;run2&quot;) return Promise.reject(&quot;run2&quot;)&#125;).then((x) =&gt; &#123; console.log(&quot;pre: &quot;, x, &quot;run3&quot;) return Promise.resolve(&quot;run3&quot;)&#125;).catch((reason) =&gt; &#123; console.log(&quot;break at &quot; + reason)&#125;)/*Promise &#123; &#x27;now&#x27; &#125;pre: now run1pre: run1 run2break at run2*/ 总结 相关阅读 Haskell Monad_哔哩哔哩_bilibili Functors, Applicatives, And Monads In Pictures - adit.io 如何自底向上地建立起对 Monad 的理解 - 知乎 什么是 Monad (Functional Programming)？ - Belleve的回答 - 知乎 🤣 深入理解函数式编程（上） - 美团技术团队 深入理解函数式编程（下） - 美团技术团队 Future与promise - 维基百科，自由的百科全书","categories":["blog"]},{"title":"SipHash","path":"/pages/blog/SipHash.html","content":"论文 eprint.iacr.org/2012/351.pdf 代码位置 library/core/src/hash/sip.rs SipHash 是一类针对短消息设计的伪随机函数族，相较于其他的哈希函数有在短消息上性能高、由于随机输入的存在难以构造哈希 dos 攻击的优点，是 rust 、python 的内置哈希函数实现。 实现 对于 SipHash-c-d 函数族，输入为一个 128 bit 的 k 和 可为空的输入 m，输出为一个 64 位长度的 SipHash-c-d(k,m)。其中 c 为 “compression rounds” 的次数， d 为 “finalization rounds” 的次数，“compression rounds” 和 “finalization rounds” 在之后中有说明具体的实现步骤。 初始化 首先使用 k0、k1 初始化四个值 v0 、v1 、v2 、v3，其中 k0、k1 为 输入 k 的 64 位的小端编码 (也就是两个 u64 值 k0 、k1 组成了 k )。 对于其中的常量，论文的选取解释为: The initial state constant corresponds to the ASCII string “somepseudorandomlygeneratedbytes”, big-endian encoded. 论文中提出只需要满足 v0 和 v1 不同于 v2 和 v3 即可(也没分析为啥。。。)。 the only requirement was some asymmetry so that the initial v0 and v1 differ from v2 and v3. Compression Round 在初始化状态后，将输入的字符串进行编码，将输入的字符串以每 8 字节作为一组以小端序编码成 64 位的数 mim_imi​ ，最后不够的用 0 做填充，最后一个字节的值为输入的字符串长度 len mod 256len \\bmod 256lenmod256。具体来说，编码的过程如下图: 在将输入 s 编码成 m0,m1…m⌈(len+1)8⌉m_0,m_1 \\dots m_{\\lceil \\frac{(len+1)}{8} \\rceil}m0​,m1​…m⌈8(len+1)​⌉​ 后，对于每个 mim_imi​ 执行以下步骤，迭代执行完所有的输入后，Compression Round 完成。 v3 ⊕=miSipRound(v0,v1,v2,v3) for c timesv0 ⊕=mi\\begin{aligned} v_3 \\ \\oplus = m_i \\\\ SipRound(v_0,v_1,v_2,v_3)\\ for\\ c \\ times \\\\ v_0 \\ \\oplus = m_i \\end{aligned} v3​ ⊕=mi​SipRound(v0​,v1​,v2​,v3​) for c timesv0​ ⊕=mi​​ PS: 巨💩🤡的是论文中的 “For example, the one-byte input string m = ab is parsed as m0 = 01000000000000ab”。开始我还以为输入的是字符串 “ab”，没看到 “one-byte input”，导致编码输入 m 这块卡了一会。感觉写成 “0xab” 和 “0x01000000000000ab” 会好一点🤡。 Finalization Round 在所有的输入字节处理在 Compression Round 处理完成后，将 v2v_2v2​ 和常量 0xff0\\mathrm{xff}0xff (也是一个随机的非零值即可) 进行异或，再进行 d 轮 SipRound 之后，将 v0v_0v0​ 、v1v_1v1​、v2v_2v2​、v3v_3v3​ 进行异或和后得到最终的 64 位哈希值。 v2 ⊕=0xffSipRound(v0,v1,v2,v3) for d timesres=v0⊕v1⊕v2⊕v3\\begin{aligned} v_2 \\ \\oplus = 0\\mathrm{xff} \\\\ SipRound(v_0,v_1,v_2,v_3)\\ for\\ d \\ times \\\\ res = v_0 \\oplus v_1 \\oplus v_2 \\oplus v_3 \\end{aligned} v2​ ⊕=0xffSipRound(v0​,v1​,v2​,v3​) for d timesres=v0​⊕v1​⊕v2​⊕v3​​ SipRound SipRound 的运算过程如下: 安全性分析 #todo [ ] SipHash 安全性分析","tags":["hash"],"categories":["blog"]},{"title":"摄影学习","path":"/pages/blog/摄影学习.html","content":"参考+图片来源 从零开始手把手教你学摄影，20节课带你从小白到大师 | 摄影前期拍摄入门教程_哔哩哔哩_bilibili 概念 传感器大小分类 下图来自于 焦距 曝光 光圈 快门时间 感光度 (ISO) 拍摄模式","categories":["blog"]},{"title":"rust源码阅读","path":"/pages/blog/rust源码阅读.html","content":"更新中… wiki链接","tags":["rust"],"categories":["blog"]},{"title":"Rust For Screeps (3): 系统监控和 panic 处理","path":"/pages/blog/Rust For Screeps (3) 系统监控和 panic 处理.html","content":"#todo [ ] TODO: 系统监控和 panic 处理","categories":["screeps"]},{"title":"Rust For Screeps (3): 系统监控","path":"/pages/blog/Rust For Screeps (3) 系统监控.html","content":"参考 Screeps 制作统计图表 - 简书 首先说明: 本文使用 docker 将监控系统部署在自有服务器上，所以先决条件是一台能公网访问的服务器( 整体流程 具体实现 记录当前状态存入内存 在 Screeps 制作统计图表 - 简书 中使用的是 memory object 存储系统信息。遗憾的是在 rust 中无法使用 memory 对象，但是 screeps 还有另一个存储信息的地方，那就是 raw memory 。 raw memory 可以存储 10 MB 的序列化后的内容，它由一个个 segment 组成，每个segment 最多存储 100 KB 内容。所以可以指定一段 segment 用于存储当前系统的状态。 12345fn log(&amp;self) &#123;\tlet status_segement = raw_memory::segments();\tlet status = Status::get_status();\tstatus_segement.set(STATUS_INDEX, status.into());&#125; 访问内存并解析内存内容 GitHub - booiris/rust-learning at screep_log 将信息存储到时序数据库中 使用 Grafana 制作图表 123456789101112131415161718192021222324252627282930313233343536373839404142version: &#x27;2&#x27;services: sync: restart: unless-stopped build: context: ./sync dockerfile: Dockerfile image: sync:1 volumes: - ./sync/log:/log depends_on: - influxdb# https://hub.docker.com/_/influxdb 查看参数含义 influxdb: image: influxdb:latest restart: unless-stopped volumes: - ./influxdb-data:/var/lib/influxdb2 - ./influxdb-config:/etc/influxdb2 environment: - DOCKER_INFLUXDB_INIT_MODE=setup - DOCKER_INFLUXDB_INIT_USERNAME=$&#123;username&#125; - DOCKER_INFLUXDB_INIT_PASSWORD=$&#123;pwd&#125; - DOCKER_INFLUXDB_INIT_ORG=$&#123;org&#125; - DOCKER_INFLUXDB_INIT_BUCKET=$&#123;bucket&#125;# https://grafana.com/docs/grafana/latest/setup-grafana/installation/docker/ 查看参数含义 grafana: image: grafana/grafana:latest restart: unless-stopped ports: - &#x27;12002:3000&#x27; volumes: - ./grafana-data:/var/lib/grafana - ./grafana-provisioning/:/etc/grafana/provisioning depends_on: - influxdb user: &quot;$UID:$GID&quot; environment: - GF_SECURITY_ADMIN_USER=$&#123;GRAFANA_USERNAME&#125; - GF_SECURITY_ADMIN_PASSWORD=$&#123;GRAFANA_PASSWORD&#125;","categories":["screeps"]},{"title":"Rust For Screeps (2): 自定义存储模型","path":"/pages/blog/Rust For Screeps (2) 自定义存储模型.html","content":"Screeps 存储模型 screeps 的存储模型基本如图所示。 其中存在两种类型的 memory，一个是 memory object ，另一个是 raw memory 。 memory object memory object 的具体介绍在 Global Objects | Screeps Documentation。 Each player has access to the global object Memory in which he/she may store any information in the JSON format. 1Memory.someData = &#123;...&#125;; 可以看出 screeps 本身内置了一个 Memory 的对象实例。可以往其中添加各种属性来达到存储信息的目的。 raw memory raw memory 在这里被提到 Global Objects | Screeps Documentation The Memory object is stored in the stringified form and is parsed each time upon the first in the tick access from your script with the help of the JSON.parse method. 可以看出 Memory 的对象实例最终会被序列化为字符串存储到 raw memory 中，在游戏的每个 tick 进行传递。 存储传递过程 在游戏的进行每个 tick ，screeps 系统会反序列化 raw memory 到 Memory Object (代码见 game.js、game.js) 1234_.extend(runCodeCache[userId].globals, &#123;\tRawMemory: runCodeCache[userId].memory,\tconsole: runCodeCache[userId].fakeConsole&#125;); 12345678910111213141516171819202122Object.defineProperty(runCodeCache[userId].globals, &#x27;Memory&#x27;, &#123;\tconfigurable: true,\tenumerable: true,\tget() &#123; try &#123; runCodeCache[userId].memory._parsed = JSON.parse(runCodeCache[userId].memory.get() || &quot;&#123;&#125;&quot;); runCodeCache[userId].memory._parsed.__proto__ = null; &#125; catch (e) &#123; runCodeCache[userId].memory._parsed = null; &#125; Object.defineProperty(runCodeCache[userId].globals, &#x27;Memory&#x27;, &#123; configurable: true, enumerable: true, value: runCodeCache[userId].memory._parsed &#125;); return runCodeCache[userId].memory._parsed;\t&#125;&#125;); 在每个 tick 最后，再将 Memory 序列化到 raw memory 里。所以，在每个 tick 间，真正传递的是 raw memory。 Rust 存储模型 从上面可以知道，Screeps 有一个 JavaScript 对象 Memory 保存需要的信息。但是要从 rust 中访问 JavaScript 里的对象十分麻烦。同时 screeps-game-api 里似乎只有 raw memory 的获取方法，而没有 memory 对象的获取方法。 所以显然易见，我们的存储信息需要放到 rust 里。在上一章的示例代码中，有这样一个变量: 12345// this is one way to persist data between ticks within Rust&#x27;s memory, as opposed to// keeping state in memory on game objects - but will be lost on global resets!thread_local! &#123; static CREEP_TARGETS: RefCell&lt;HashMap&lt;String, CreepTarget&gt;&gt; = RefCell::new(HashMap::new());&#125; 我们可以使用 RefCell 创建一个全局变量 (类似 javaScript 里的 Memory 对象) 存储到 wasm 的线性内存里。只要 wasm 的实例没有被销毁，那么这个全局变量就可以随着 wasm 实例在每个 tick 传递。 自定义存储实现 通过 rust 的全局变量我们实现了信息跨 tick 存储，但注意到注释中存在着一句话。 keeping state in memory on game objects - but will be lost on global resets! Screeps 系统存在着一个机制，就是 global reset ，会定时销毁 javaScript 里的对象并且重建，这就导致了这会销毁 wasm 的实例，进而导致存储的信息丢失。 raw memory 使用 从第一部分可以知道 raw memory 可以认为是 Screeps 中的持久性存储。所以如果可以在每个 tick 最后把 rust 里的全局变量序列化到 raw memory 里，然后在 wasm 实例初始化时再从 raw memory 里反序列化回 rust 的全局变量，这就实现了信息的跨 tick 保存而又不会受到 global reset 的影响。 rust 部分实现 Screeps 的 api 存在对 raw memory 的操作方法 Screeps Documentation。 储存全局变量参考代码: 123456789thread_local! &#123; pub static GLOBAL_LONG_MEMORY: RefCell&lt;GlobalMemory&gt; = RefCell::new(GlobalMemory::new());&#125;GLOBAL_LONG_MEMORY.with(|mem| &#123;\tlet mem = &amp;*mem.borrow();\tlet mem: String = mem.into();\traw_memory::set(&amp;JsString::from_str(&amp;mem).expect(&quot;can conver global mem to string&quot;))&#125;); 其中 GlobalMemory 是一个结构体，并且实现了 into String 的方法，所以可以使用 mem.into() 转换为 String 类型，最后通过 api 的 raw_memory::set 方法将全局变量保存到 raw memory 中。 初始化全局变量参考代码: 1234567891011GLOBAL_LONG_MEMORY.with(|mem| &#123;\tlet raw_memory: String = raw_memory::get() .try_into() .expect(&quot;can not get raw memory&quot;);\tif let Ok(raw_mem) = GlobalMemory::try_from(raw_memory) &#123; *mem.borrow_mut() = raw_mem;\t&#125; else &#123; log::error!(&quot;old mem can not match new struct!&quot;); *mem.borrow_mut() = GlobalMemory::new();\t&#125;&#125;); 可以看出，存在无法从 raw memory 还原回全局变量的情况 ( GlobalMemory 的结构出现了破坏性的更改导致无法从之前的结构反序列化回去)。这时候需要考虑构建一个在空的全局变量下还能继续运行并且还原的系统。 javaScript 部分实现 本来存储 raw memory 的过程在 rust 中实现即可。但是存在一个问题，Screeps 系统运行中，某些动作 (比如 creep_move) 会使用的 memory object 实例，所以会对 raw memory 进行反序列化。为了不必要的消耗，我们可以持有一个 mem_proxy 对象实例，每个 tick 开始，就对 memory object 进行赋值，这样就不会触发反序列化，减少 cpu 消耗。 参考 Screeps游戏 Memory仙术 - 简书 实现代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&quot;use strict&quot;;let wasm_module;const MODULE_NAME = &quot;rust-screep-world&quot;;function console_error(...args) &#123; console.log(...args); Game.notify(args.join(&#x27; &#x27;));&#125;let mem_proxy = &#123; creeps: &#123;&#125; &#125;module.exports.loop = function () &#123; delete global.Memory; global.Memory = mem_proxy RawMemory._parsed = mem_proxy try &#123; if (wasm_module) &#123; wasm_module.loop(); &#125; else &#123; // attempt to load the wasm only if there&#x27;s enough bucket to do a bunch of work this tick if (Game.cpu.bucket &lt; 500) &#123; console.log(&quot;we are running out of time, pausing compile!!!&quot; + JSON.stringify(Game.cpu)); return; &#125; // delect the module from the cache, so we can reload it if (MODULE_NAME in require.cache) &#123; delete require.cache[MODULE_NAME]; &#125; // replace this initialize function on the module wasm_module = require(MODULE_NAME); // load the wasm instance! wasm_module.initialize_instance(); // run the setup function, which configures logging wasm_module.setup(); // go ahead and run the loop for its first tick wasm_module.loop(); &#125; &#125; catch (error) &#123; console_error(&quot;caught exception err:&quot;, error); if (error.stack) &#123; console_error(&quot;stack trace:&quot;, error.stack); &#125; console_error(&quot;resetting VM next tick.&quot;); wasm_module = null; &#125; mem_proxy = global.Memory&#125;","categories":["screeps"]},{"title":"Rust For Screeps (1): 初始环境搭建","path":"/pages/blog/Rust For Screeps (1) 初始环境搭建.html","content":"参考 GitHub - rustyscreeps/screeps-starter-rust: Starter Rust AI for Screeps, the JavaScript-based MMO game 安装相关cli 1cargo install cargo-screeps 命令包含了构建代码、上传代码等操作。 下载模板文件 12git clone https://github.com/rustyscreeps/screeps-starter-rust.gitcd screeps-starter-rust 模板 (版本:d91b60f9a13eb0bd763b094acb6a1d749bb1b12f) 中包含的文件: 12345678910./├── Cargo.toml├── example-screeps.toml├── javascript│ └── main.js├── LICENSE├── README.md└── src ├── lib.rs └── logging.rs 模板文件说明 example-screeps.toml 用于 cargo-screeps 的配置。 javascript/main.js 为游戏主入口，其中内容如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&quot;use strict&quot;;let wasm_module;// replace this with the name of your moduleconst MODULE_NAME = &quot;screeps-starter-rust&quot;;function console_error(...args) &#123; console.log(...args); Game.notify(args.join(&#x27; &#x27;));&#125;module.exports.loop = function () &#123; try &#123; if (wasm_module) &#123; wasm_module.loop(); &#125; else &#123; // attempt to load the wasm only if there&#x27;s enough bucket to do a bunch of work this tick if (Game.cpu.bucket &lt; 500) &#123; console.log(&quot;we are running out of time, pausing compile!&quot; + JSON.stringify(Game.cpu)); return; &#125; // delect the module from the cache, so we can reload it if (MODULE_NAME in require.cache) &#123; delete require.cache[MODULE_NAME]; &#125; // load the wasm module wasm_module = require(MODULE_NAME); // load the wasm instance! wasm_module.initialize_instance(); // run the setup function, which configures logging wasm_module.setup(); // go ahead and run the loop for its first tick wasm_module.loop(); &#125; &#125; catch (error) &#123; console_error(&quot;caught exception:&quot;, error); if (error.stack) &#123; console_error(&quot;stack trace:&quot;, error.stack); &#125; console_error(&quot;resetting VM next tick.&quot;); wasm_module = null; &#125;&#125; 文件中 wasm_module 保存了 wasm 的实例。如果 wasm 的实例存在，就调用 loop 函数运行游戏逻辑。如果 wasm 的实例不存在 (由于更新代码或 screeps 进行了内存回收等原因导致实列被销毁)，重新载入 wasm 并且调用 setup 函数进行初始化，然后再运行游戏逻辑。 src/logging.rs 为辅助文件，用于日志的实现。基本上就是进行 log 格式的创建，不做过多说明。在 setup 阶段调用一下 setup_logging 函数就行。 src/lib.rs 为 rust 的实现逻辑入口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273use std::cell::RefCell;use std::collections::&#123;hash_map::Entry, HashMap&#125;;use log::*;use screeps::&#123; constants::&#123;ErrorCode, Part, ResourceType&#125;, enums::StructureObject, find, game, local::ObjectId, objects::&#123;Creep, Source, StructureController&#125;, prelude::*,&#125;;use wasm_bindgen::prelude::*;mod logging;// add wasm_bindgen to any function you would like to expose for call from js#[wasm_bindgen]pub fn setup() &#123; logging::setup_logging(logging::Info);&#125;// this is one way to persist data between ticks within Rust&#x27;s memory, as opposed to// keeping state in memory on game objects - but will be lost on global resets!thread_local! &#123; static CREEP_TARGETS: RefCell&lt;HashMap&lt;String, CreepTarget&gt;&gt; = RefCell::new(HashMap::new());&#125;// this enum will represent a creep&#x27;s lock on a specific target object, storing a js reference// to the object id so that we can grab a fresh reference to the object each successive tick,// since screeps game objects become &#x27;stale&#x27; and shouldn&#x27;t be used beyond the tick they were fetched#[derive(Clone)]enum CreepTarget &#123; Upgrade(ObjectId&lt;StructureController&gt;), Harvest(ObjectId&lt;Source&gt;),&#125;// to use a reserved name as a function name, use `js_name`:#[wasm_bindgen(js_name = loop)]pub fn game_loop() &#123; debug!(&quot;loop starting! CPU: &#123;&#125;&quot;, game::cpu::get_used()); // mutably borrow the creep_targets refcell, which is holding our creep target locks // in the wasm heap CREEP_TARGETS.with(|creep_targets_refcell| &#123; let mut creep_targets = creep_targets_refcell.borrow_mut(); debug!(&quot;running creeps&quot;); for creep in game::creeps().values() &#123; run_creep(&amp;creep, &amp;mut creep_targets); &#125; &#125;); debug!(&quot;running spawns&quot;); let mut additional = 0; for spawn in game::spawns().values() &#123; debug!(&quot;running spawn &#123;&#125;&quot;, String::from(spawn.name())); let body = [Part::Move, Part::Move, Part::Carry, Part::Work]; if spawn.room().unwrap().energy_available() &gt;= body.iter().map(|p| p.cost()).sum() &#123; // create a unique name, spawn. let name_base = game::time(); let name = format!(&quot;&#123;&#125;-&#123;&#125;&quot;, name_base, additional); // note that this bot has a fatal flaw; spawning a creep // creates Memory.creeps[creep_name] which will build up forever; // these memory entries should be prevented (todo doc link on how) or cleaned up match spawn.spawn_creep(&amp;body, &amp;name) &#123; Ok(()) =&gt; additional += 1, Err(e) =&gt; warn!(&quot;couldn&#x27;t spawn: &#123;:?&#125;&quot;, e), &#125; &#125; &#125; info!(&quot;done! cpu: &#123;&#125;&quot;, game::cpu::get_used())&#125; 其中需要关注两个函数 setup 和 game_loop 。 setup 为 wasm 实例创建的时候调用的函数，在其中可以实现日志初始化、数据初始化的逻辑。 game_loop 通过 #[wasm_bindgen(js_name = loop)] 的标注 (rust 中称为过程宏) 将其改名为wasm 里运行的 loop 函数，这也是游戏中每 tick 运行的主逻辑。","categories":["screeps"]},{"title":"杂记","path":"/pages/linux/杂记.html","content":"[[2022-08-20]] 我们建立ssh隧道的时候，往往是想通过一台公网的主机或者是大家都可以访问的主机做跳转机，来访问内部或者外部不能直接访问的机器。所以一般像这种情况下，请将跳转机中的ssh服务器中的GatewayPorts设为yes。 端口转发时参数为 -NfR [[2022-08-30]] docker运行systemctl 1docker run -d --name desk -p 2222:22 -v /home/booiris:/home/booiris --hostname vm-host --env container=docker --privileged archlinux /sbin/init [[2022-10-08]] @ + 时间 == today rust partition_point(|x| x &lt; &amp;s) 函数 lower_bound upper_bound 在位置左边的为满足表达式的值，右边为不满足表达式的值。 [[2022-12-25]] 灵感： 卡牌拓印场景中的元素 控制人物会有影响","categories":["linux"]},{"title":"linux自启动服务","path":"/pages/linux/linux自启动服务.html","content":"自启动文件放在 /usr/lib/systemd/system 12345678910[Unit]Description=code-server[Service]Type=simpleExecStart=/usr/bin/code-serverUser=your user name[Install]WantedBy=multi-user.target 123sudo systemctl daemon-reload #刷新sudo systemctl start code-serversudo systemctl enable code-server","categories":["linux"]},{"title":"arch虚拟机安装","path":"/pages/linux/arch虚拟机安装.html","content":"查看ip地址 1ip addr 时间同步 1timedatectl set-ntp true 准备磁盘分区 显示所有分区 1fdisk -l 开始分区 1fdisk /dev/sda 分区过程参考网址 确认是否生效 1fdisk -l /dev/sda 格式化分区和设置swap分区 123mkfs.fat -F32 /dev/sda1mkswap /dev/sda2mkfs.ext4 /dev/sda3 启用交换分区 1swapon /dev/sda2 挂载根目录 1mount /dev/sda3 /mnt 挂载boot目录 12mkdir /mnt/bootmount /dev/sda1 /mnt/boot 安装系统 修改镜像源 1vim /etc/pacman.d/mirrorlist 添加 Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch 镜像 如果安装时报错 ERROR: 5984EA8F3C could not be locally signed 解决办法： 123456rm -fr /etc/pacman.d/gnupgumount /etc/pacman.d/gnupgrm -fr /etc/pacman.d/gnupgpacman-key --initpacman-key --populate archlinuxpacman -Sy archlinux-keyring 安装系统和网络插件 1pacstrap /mnt base linux networkmanager 配置系统 生成fstab文件 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 进入chroot 1arch-chroot /mnt 设置时区 1ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 设置硬件时间同步 1hwclock --systohc 安装vim 1pacman -S vim 语言设置 123vim /etc/locale.genen_USzh_CN 生成语言 1locale-gen 设置默认语言 1echo LANG=en_US.UTF-8 &gt; /etc/locale.conf 创建host文件 1echo YourNewHostname &gt; /etc/hostname 添加host 123456vim /etc/hosts# Static table lookup for hostnames. # See hosts(5) for details. 127.0.0.1 localhost ::1 localhost 127.0.1.1 YourNewHostname.localdomain YourNewHostname 开启网络服务 1systemctl enable NetworkManager 设置 root 用户密码 1passwd 安装引导程序 UEFI 系统： 123pacman -S grub efibootmgrgrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=&quot;Arch Linux&quot; --recheckgrub-mkconfig -o /boot/grub/grub.cfg 完成安装 123exitumount -R /mntreboot 备注 实体机安装类似，关闭显示屏 1setterm -blank 1 # 待机一分钟关闭显示屏 在进入fakeroot后安装 intel-ucode,电源管理tlp","categories":["linux"]},{"title":"nginx反向代理自签名","path":"/pages/linux/nginx反向代理自签名.html","content":"自签名ca证书 首先创建cert文件夹保存证书。 12mkdir certcd cert 然后创建配置文件cert.cnf，注意如果时ip自签名就在your_IP填写自己的ip，如果是自签名域名就是在your_domain写自己的域名。 [dn]下CN字段是ca根服务器地址，alt_names下是ca验证的ip和域名地址，一般情况下这两个是一样的。 12345678910111213141516171819202122232425[req] prompt = no default_bits = 4096default_md = sha256distinguished_name = dn x509_extensions = v3_req[dn] C=CNST=ShanghaiL=ShanghaiO=TESTOU=Testing DomainCN=$your_IP or $your_domainemailAddress=admin@localhost[v3_req]basicConstraints=CA:TRUEkeyUsage=digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentextendedKeyUsage=serverAuthsubjectAltName=@alt_names[alt_names]IP.1=$your_IPDNS.1=$your_domain 根据配置文件生成证书。 1openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout cert.key -out cert.crt -config cert.cnf 当前目录下生成两个文件cert.crt和cert.key，至此自签名步骤完成。 nginx反向代理 docker拉取nginx镜像。 1docker pull nginx 新建一个容器获取config文件。 1234docker run -d --name nginx nginxdocker cp nginx:/etc/nginx/nginx.conf ./nginx.confdocker stop nginxdocker rm nginx 在config文件的http内加入如下内容。 123456789101112131415161718192021server&#123;\tlisten 443 ssl;\tserver_name $your_ip or website;\tssl_certificate /cert/cert.crt;\tssl_certificate_key /cert/cert.key;\tssl_session_cache shared:SSL:1m;\tssl_session_timeout 5m;\tssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法\tssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议\tssl_prefer_server_ciphers on; #使用服务器端的首选算法\tlocation / &#123; proxy_pass http://$your_proxy_ip:$your_proxy_port; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Accept-Encoding gzip;\t&#125;&#125; 使用nginx反向代理。 1docker run -d --restart=always -p $your_port:443 --name nginx -v &quot;$PWD&quot;/nginx.conf:/etc/nginx/nginx.conf -v &quot;$PWD&quot;/cert:/cert nginx 更新nginx 1234#测试配置文件docker exec nginx nginx -t #更新nginx配置docker exec nginx nginx -s reload","categories":["linux"]},{"title":"Data Lab","path":"/pages/csapp/Data Lab.html","content":"CS:APP Data Lab restriction Integer constants 0 through 255 (0xFF), inclusive. You are not allowed to use big constants such as 0xffffffff. Function arguments and local variables (no global variables). Unary integer operations ! ~ Binary integer operations &amp; ^ | + &lt;&lt; &gt;&gt; NOT ALLOW Use any control constructs such as if, do, while, for, switch, etc. Define or use any macros. Define any additional functions in this file. Call any functions. Use any other operations, such as &amp;&amp;, ||, -, or ?: Use any form of casting. Use any data type other than int. This implies that you cannot use arrays, structs, or unions. Question q1 Description bitXor - x^y using only ~ and &amp;. Example bitXor(4, 5) = 1 Answer x⊕y=(∼x∧y)∨(x∧∼y)=∼(∼(∼x∧y)∧∼(x∧∼y))x⊕y=(x∨y)∧(∼x∨∼y)=∼(∼x∧∼y)∧∼(x∧y)\\begin{aligned} x \\oplus y &amp;= (\\sim x \\wedge y) \\vee (x \\wedge \\sim y) = \\sim(\\sim(\\sim x \\wedge y) \\wedge \\sim(x \\wedge \\sim y)) \\\\ x \\oplus y &amp;= (x \\vee y) \\wedge (\\sim x \\vee \\sim y) = \\sim(\\sim x \\wedge \\sim y) \\wedge \\sim (x \\wedge y) \\end{aligned} x⊕yx⊕y​=(∼x∧y)∨(x∧∼y)=∼(∼(∼x∧y)∧∼(x∧∼y))=(x∨y)∧(∼x∨∼y)=∼(∼x∧∼y)∧∼(x∧y)​ Compare eq1 and eq2, eq1 uses five NOT operations and three AND operations, eq2 uses four NOT operations and three AND operations. Therefore eq2 is better. Code 1234int bitXor(int x, int y) &#123; return ~(x &amp; y) &amp; ~(~x &amp; ~y); // return ~(~(x &amp; ~y) &amp; ~(~x &amp; y));&#125; q2 Description tmin - return minimum two’s complement integer. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;. Answer For data of type int, the minimum value is −231-2^{31}−231 which is expressed in binary as 1|0x31. Code 123int tmin(void) &#123; return 1 &lt;&lt; 31;&#125; q3 Description IsTmax - returns 1 if x is the maximum, two’s complement number, and 0 otherwise. Legal ops: ! ~ &amp; ^ | +. Answer Notice that only when x = -1 or x = INT_MAX, x^(x+1) = 0xffffffff. Therefore, we can use a = ~(x ^ (x+1)) to find INT_MAX and -1. when a = 0, x = INT_MAX or -1. Next step we need to distinguish INT_MAX and -1. Notice that -1 + 1 = 0. So we can use b = !(x+1) to find -1. when b = 0, x = INT_MAX; b = 1, x = -1. At Last, we can use res = !(a | b) to check whether x is INT_MAX. Code 12345int isTmax(int x) &#123; int temp = x + 1; int a = ~(x ^ temp); return !((!temp) | a);&#125; q4 Description allOddBits - return 1 if all odd-numbered bits in word set to 1 where bits are numbered from 0 (least significant) to 31 (most significant). Example Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1. Answer We can use (x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA to check if all odd-numbered bits in word set to 1. Therefore it’s important to get a constant 0xAAAAAAAA. Since we can only use 0 ~ 0xff, we can simply repeate flowing code four times to get 0xAAAAAAAA. 12key |= 0xaa;key &lt;&lt;= 8; However, it will cost 2 * 4 = 8 operations. We can use a better way to get constant. get a = 0xAA. get b = 0xAAAA. get c = 0xAAAAAAAA. It’s a bit like binary serach. Every time we can construct double length number. Therefore to build a 32 bits number, we just use log(324)=3log(\\frac{32}{4}) = 3log(432​)=3 operations to get the number. Code 1234567int allOddBits(int x) &#123; int a = 0xaa; int b = a | a &lt;&lt; 8; int c = b | b &lt;&lt; 16; return !((x &amp; c) ^ c);&#125; q5 Description negate - return -x Example Example: negate(1) = -1. Answer Since x + ~x = -1, we can change it to -x = ~x + 1. Code 1234int negate(int x)&#123; return ~x + 1;&#125; q6 Description isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’) Example isAsciiDigit(0x35) = 1. isAsciiDigit(0x3a) = 0. isAsciiDigit(0x05) = 0. Answer %TODO Code 12345678910int isAsciiDigit(int x)&#123; int a = x &gt;&gt; 4; int key = 0x3; int check1 = !(key ^ a); int check2 = !((x &gt;&gt; 3) &amp; 1); int check3 = !(x ^ 0x38); int check4 = !(x ^ 0x39); return check1 &amp; (check2 | check3 | check4);&#125; q7 Description conditional - same as x ? y : z Example Example: conditional(2,4,5) = 4 Answer At first, we can use x = !x to make f(x)=0{x≠0},1{x=0}f(x)= 0 \\{x eq 0\\}, 1 \\{x = 0\\}f(x)=0{x=0},1{x=0}. With x = ~x + 1, we can get g(x)=ffff{x≠0},0000{x=0}g(x) = ffff \\{x eq 0 \\}, 0000\\{x=0\\}g(x)=ffff{x=0},0000{x=0}. Notice that y ^ y ^ z = z, y ^ 0 = y. Therefore, we can use y ^ ((y ^ z) &amp; x) to get answer. When x = 0, (y ^ z) &amp; x = y ^ z, otherwise, (y ^ z) &amp; x = 0. Code 123456int conditional(int x, int y, int z)&#123; x = !x; x = ~x + 1; return y ^ ((y ^ z) &amp; x);&#125;","categories":["csapp"]},{"title":"树状数组","path":"/pages/algorithm/segment_tree/树状数组.html","content":"区间和模板： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pub struct Bitree &#123; tree: Vec&lt;i32&gt;, len: usize,&#125;impl Bitree &#123; #[inline] pub fn new(ini: &amp;Vec&lt;i32&gt;) -&gt; Self &#123; let mut res = Bitree &#123; tree: vec![0; ini.len() + 1], len: ini.len(), &#125;; for (index, v) in ini.iter().enumerate() &#123; res.update(index + 1, *v); &#125; res &#125; #[inline] fn lowbit(x: usize) -&gt; usize &#123; return (x as i32 &amp; -(x as i32)) as usize; &#125; fn update(&amp;mut self, index: usize, v: i32) &#123; let mut pos = index; while pos &lt;= self.len &#123; self.tree[pos] += v; pos += Self::lowbit(pos); &#125; &#125; fn get(&amp;self, n: usize) -&gt; i32 &#123; let mut res = 0; let mut pos = n; while pos &gt; 0 &#123; res += self.tree[pos]; pos -= Self::lowbit(pos); &#125; res &#125; /// `query` 下标从`1`开始 pub fn query(&amp;self, l: usize, r: usize) -&gt; i32 &#123; self.get(r) - self.get(l - 1) &#125;&#125; 查询 log⁡(n)\\log(n)log(n) ,更新 log⁡(n)\\log(n)log(n)。 区间最值模版: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051use std::cmp::*;pub struct Bitree &#123; tree: Vec&lt;i32&gt;, val: Vec&lt;i32&gt;, len: usize,&#125;impl Bitree &#123; #[inline] pub fn new(len: usize) -&gt; Self &#123; Bitree &#123; tree: vec![0; len + 1], val: vec![0; len + 1], len, &#125; &#125; #[inline] fn lowbit(x: usize) -&gt; usize &#123; return (x as i32 &amp; -(x as i32)) as usize; &#125; fn update(&amp;mut self, index: usize, v: i32) &#123; let mut pos = index; self.val[pos] = v; while pos &lt;= self.len &#123; self.tree[pos] = self.val[pos]; let low = Self::lowbit(pos); let mut i = 1; while i &lt; low &#123; self.tree[pos] = max(self.tree[pos], self.tree[pos - i]); i &lt;&lt;= 1; &#125; pos += Self::lowbit(pos); &#125; &#125; /// `query` 下标从`1`开始 pub fn query(&amp;self, mut l: i32, mut r: i32) -&gt; i32 &#123; let mut res = 0; l = max(1, l); while r &gt;= l &#123; res = max(res, self.val[r as usize]); r -= 1; while r - Self::lowbit(r as usize) as i32 &gt;= l &#123; res = max(res, self.tree[r as usize]); r -= Self::lowbit(r as usize) as i32; &#125; &#125; res &#125;&#125; 查询 log⁡(n)\\log(n)log(n) ,更新 log⁡(n)2\\log(n)^2log(n)2。","categories":["algorithm","segment_tree"]},{"title":"Obsidian 多平台同步方法","path":"/pages/blog/sync.html","content":"! 推荐自建 webdav 服务 webdav 同步 使用 Remotely Save 插件进行多平台同步。 注册 webdav 服务 使用 TeraCLOUD 网盘。使用步骤如下： 注册账号。 登录 ，进入 mypage 界面。 开启 webdav 服务，记住用户名和密码。 至此，webdav 服务注册成功。 使用 Remotely Save 插件进行同步 安装插件。 服务选择 webdav。 填写上面的用户名和密码。 测试连接，之后自行设置同步方式即可。","categories":["blog"]},{"title":"插件列表","path":"/pages/blog/extension.html","content":"Admonition Auto Link Title Advanced table Better word count Calendar Check list Collapse All Data view Editor syntax highlight Excalidraw File tree alternative Full screen plugin Image Toolkit Link Favicons Linter Mind map Minimal theme settings Natural Language Dates Note refactor obsidian Outliner Remember cursor position Remotely Save Templater Auto Link Title 粘贴互联网链接的时候自动添加标题。 Link Favicons 显示链接的 icon Image Toolkit 预览图片 Collapse All 折叠所有文件夹 Natural Language Dates 自动生成日期 + @ Better word count 计算字数 Excalidraw 绘画板 outliner 列表调整 mind map 思维导图 refactor obsidian 将过长的笔记分为多个笔记 advanced table 强化表格 syntax highlight 代码高亮 123int main()&#123;\tcout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;&#125; admonition 12345678标注栏 添加 ad 前缀```ad-bugtitle: I&#x27;m Nested!~~~javascriptthrow new Error(&quot;Oops, I&#x27;m a bug.&quot;);~~~``` remotely save 同步文档 linter 格式化文档 data view 文档信息聚合 file tree 文件树管理 full screen 禅模式 templater 模板插件 check list todo 列表 相关链接 Obsidian-插件推荐（20220323更新-附压缩包） - 知乎","categories":["blog"]},{"title":"linux-install","path":"/pages/linux/linux-install.html","content":"WSL 1wsl --list 卸载对应的系统 1wsl --unregister Ubuntu 设置默认系统 1wslconfig /setdefault Name 修改默认用户，主机名，修改/etc/wsl.conf文件 12345[user]default=youruser[network]hostname=yourhostname Ubuntu 换源 备份sources.list文件 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 编辑/etc/apt/sources.list文件 1sudo vim /etc/apt/sources.list 在文件前面添加下面的条目(阿里源) 12345678910deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 更新 1sudo apt update oh-my-bash 美化 安装 1bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmybash/oh-my-bash/master/tools/install.sh)&quot; 安装软件 安装i3wm 安装 1sudo apt install i3 同步最新仓库 12345sudo apt install ca-certificates/usr/lib/apt/apt-helper download-file https://debian.sur5r.net/i3/pool/main/s/sur5r-keyring/sur5r-keyring_2021.02.02_all.deb keyring.deb SHA256:cccfb1dd7d6b1b6a137bb96ea5b5eef18a0a4a6df1d6c0c37832025d2edaa710sudo dpkg -i ./keyring.debsudo sh -c &quot;echo &quot;deb http://debian.sur5r.net/i3/ $(grep &#x27;^DISTRIB_CODENAME=&#x27; /etc/lsb-release | cut -f2 -d=) universe&quot; &gt; /etc/apt/sources.list.d/sur5r-i3.list&quot;sudo apt update 安装tigervnc 安装 1sudo apt install tigervnc-standalone-server 启动 1vncserver -SecurityTypes=None -localhost=no --I-KNOW-THIS-IS-INSECURE :1 -dpi 150 -geometry=1920x1080 显示当前ip 1ip addr | grep eth0 安装feh、xfce4-terminal、rofi、polybar 1sudo apt install feh xfce4-terminal rofi polybar 安装picom 12345678sudo apt install libxext-dev libxcb1-dev libxcb-damage0-dev libxcb-xfixes0-dev libxcb-shape0-dev libxcb-render-util0-dev libxcb-render0-dev libxcb-randr0-dev libxcb-composite0-dev libxcb-image0-dev libxcb-present-dev libxcb-xinerama0-dev libxcb-glx0-dev libpixman-1-dev libdbus-1-dev libconfig-dev libgl1-mesa-dev libpcre2-dev libpcre3-dev libevdev-dev uthash-dev libev-dev libx11-xcb-dev meson gcccdgit clone https://github.com/yshui/picom.git --depth=1cd picomgit submodule update --init --recursivemeson --buildtype=release . buildninja -C buildsudo ninja -C build install 安装google 下载安装包 1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 安装 1sudo apt install ./google-chrome-stable_current_amd64.deb 加载字体 12sudo mkfontscalesudo fc-cache -fv ARCH 创建用户 12345678useradd -m -G wheel username# 请自行替换 username 为你的用户名passwd username# 请自行替换 username 为你的用户名vim /etc/sudoers# 去掉# %wheel ALL=(ALL)ALL 设置默认用户 1./Arch.exe config --default-user booiris 换源 12345678910111213141516171819202122232425sudo pacman-key --initsudo pacman-key --populate archlinuxcp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backupsudo vim /etc/pacman.d/mirrorlist# 清华大学Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch## 163Server = http://mirrors.163.com/archlinux/$repo/os/$arch## aliyunServer = http://mirrors.aliyun.com/archlinux/$repo/os/$archcp /etc/pacman.conf /etc/pacman.conf.backupsudo vim /etc/pacman.conf[archlinuxcn]# The Chinese Arch Linux communities packages.# SigLevel = Optional TrustedOnlySigLevel = Optional TrustAll# 清华大学Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$archsudo pacman -Syyu YAY 安装 1sudo pacman -S yay 换源 1yay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save 安装软件 123yay -S base-develyay -S i3 tigervnc sublime-text-4 google-chrome xfce4-terminal tighervnc 配置 用 vncpasswd 创建密码，它会将哈希处理之后的密码存储在 ~/.vnc/passwd。 编辑 /etc/tigervnc/vncserver.users 来定义用户映射 创建 ~/.vnc/config，其中至少要有一行定义会话的类型，比如 session=foo （将foo替换为你想要运行的桌面环境）。你可以通过查看 /usr/share/xsessions/ 里的 .desktop 文件来知道有哪些桌面环境在当前系统上可以使用。 1234session=i3geometry=1920x1080dpi=150alwaysshared 语言 12sudo vim /etc/locale.gensudo locale-gen 字体 1yay -S noto-fonts-emoji adobe-source-han-serif-cn-fonts adobe-source-han-serif-tw-fonts adobe-source-han-sans-cn-fonts adobe-source-han-sans-tw-fonts nerd-fonts-jetbrains-mono ttf-iosevka-nerd ttf-material-icons-git papirus-icon-theme 桌面 12yay -S polybar rofi feh picom xss-lock dbus-x11 google-chromeyay -S fcitx5-im fcitx5-chinese-addons 创建.Xresources 1234567Xft.dpi: 120Xft.autohint: 0Xft.lcdfilter: lcddefaultXft.hintstyle: hintfullXft.hinting: 1Xft.antialias: 1Xft.rgba: rgb rofi 1234mkdir ~/.local/share/rofigit clone https://github.com/Murzchnvok/rofi-collection.git --depth=1cp -r nord $HOME/.local/share/rofi/themes/ 创建config.rasi 12//@theme &quot;/home/booiris/.local/share/rofi/themes/nord.rasi&quot;@theme &quot;/home/booiris/.local/share/rofi/themes/nord.rasi&quot;","categories":["linux"]},{"title":"chapter 1","path":"/pages/csapp/chapter 1.html","content":"#todo [ ] TODO: 没写完 1.3 funny question Optimize Problems Is a switch statment always more efficient than a sequence of if-else statements? [ ] q1 answer: How much overhead is incurred by a function call? [ ] q2 answer: Is a while loop more efficient than a for loop? [ ] q3 answer: Are pointer references more efficient than array indexes? [ ] q4 answer: Why does out loop run so much faster if we sum into a local variable instead of an argument that is passed by reference? [ ] q5 answer: How can a function run faster when we simply rearrange the parenthes in an arithmetic expression? [ ] q6 answer: 1.4 1.4.1 I/O Devices Each I/O devices is connected to I/O bus by either a controller or an adapter. Controller is chip set in the devices or on the system's motherboard. Adapter is a card that plugs into a slot on the motherboard. #chapter1/IO","categories":["csapp"]},{"path":"/package.json","content":"{\"name\":\"hexo-site\",\"version\":\"0.0.0\",\"private\":true,\"hexo\":{\"version\":\"6.2.0\"},\"dependencies\":{\"hexo\":\"^6.2.0\",\"hexo-deployer-git\":\"^3.0.0\",\"hexo-generator-archive\":\"^1.0.0\",\"hexo-generator-category\":\"^1.0.0\",\"hexo-generator-index\":\"^2.0.0\",\"hexo-generator-tag\":\"^1.0.0\",\"hexo-renderer-ejs\":\"^2.0.0\",\"hexo-renderer-markdown-it-plus\":\"^1.0.4\",\"hexo-renderer-stylus\":\"^2.1.0\",\"hexo-server\":\"^3.0.0\"},\"devDependencies\":{\"@vercel/node\":\"^2.5.22\",\"web-vitals\":\"^3.0.3\"}}"},{"path":"/vercel.json","content":"{\"github\":{\"silent\":true},\"headers\":[{\"source\":\"/(.*)\",\"headers\":[{\"key\":\"Access-Control-Allow-Origin\",\"value\":\"*\"},{\"key\":\"Access-Control-Allow-Headers\",\"value\":\"content-type\"},{\"key\":\"Access-Control-Allow-Methods\",\"value\":\"DELETE,PUT,POST,GET,OPTIONS\"}]}]}"},{"path":"/api/analytics.js","content":"import { getCLS, getFCP, getFID, getLCP, getTTFB } from 'web-vitals'; const vitalsUrl = 'https://vitals.vercel-analytics.com/v1/vitals'; function getConnectionSpeed() { return 'connection' in navigator && navigator['connection'] && 'effectiveType' in navigator['connection'] ? navigator['connection']['effectiveType'] : ''; } function sendToAnalytics(metric, options) { const page = Object.entries(options.params).reduce( (acc, [key, value]) => acc.replace(value, `[${key}]`), options.path, ); const body = { dsn: options.analyticsId, // qPgJqYH9LQX5o31Ormk8iWhCxZO id: metric.id, // v2-1653884975443-1839479248192 page, // /blog/[slug] href: location.href, // https://my-app.vercel.app/blog/my-test event_name: metric.name, // TTFB value: metric.value.toString(), // 60.20000000298023 speed: getConnectionSpeed(), // 4g }; if (options.debug) { console.log('[Analytics]', metric.name, JSON.stringify(body, null, 2)); } const blob = new Blob([new URLSearchParams(body).toString()], { // This content type is necessary for `sendBeacon` type: 'application/x-www-form-urlencoded', }); if (navigator.sendBeacon) { navigator.sendBeacon(vitalsUrl, blob); } else fetch(vitalsUrl, { body: blob, method: 'POST', credentials: 'omit', keepalive: true, }); } export function webVitals(options) { try { getFID((metric) => sendToAnalytics(metric, options)); getTTFB((metric) => sendToAnalytics(metric, options)); getLCP((metric) => sendToAnalytics(metric, options)); getCLS((metric) => sendToAnalytics(metric, options)); getFCP((metric) => sendToAnalytics(metric, options)); } catch (err) { console.error('[Analytics]', err); } }"},{"path":"/api/hello.js","content":"export default function handler(request, response) { const { name } = request.query response.status(200).send(`Hello ${name}!`) }"},{"title":"game","path":"/game/index.html","content":"一些小玩意儿，点击标题查看 Life-time The wasm-bindgen based Conway game. 使用 rust wasm 编写的康威游戏 github link: rust-learning/life-game at rust-game · booiris/rust-learning · GitHub Push-box 强化学习版推箱子 Reinforcement learning based Sokoban game. github link: rust-learning/push-box at rust-game · booiris/rust-learning · GitHub flappy-bird Attention! This game size is 10 MB. 使用 bevy (一种数据驱动游戏引擎，还挺有意思的) 编写的 flappy-bird Bevy based Flappy Bird game. github link: GitHub - booiris/rust-learning at snake snake 基于 fc 模拟器运行的贪吃蛇游戏 github link: rust-nes/test-snake at master · booiris/rust-nes · GitHub"},{"title":"Picture","path":"/pic/index.html","content":"1 2 3"},{"path":"/js/memos.js","content":"utils.jq(() => { $(function () { const els = document.getElementsByClassName('ds-memos'); for (var i = 0; i < els.length; i++) { const el = els[i]; const api = el.getAttribute('api'); if (api == null) { continue; } const default_avatar = el.getAttribute('avatar') || def.avatar; const limit = el.getAttribute('limit'); const host = api.replace(/https:\\/\\/(.*?)\\/(.*)/i, '$1'); // layout utils.request(el, api, function (data) { data = data.memos var users = []; const filter = el.getAttribute('user'); if (filter && filter.length > 0) { users = filter.split(\",\"); } var hide = []; const hideStr = el.getAttribute('hide'); if (hideStr && hideStr.length > 0) { hide = hideStr.split(\",\"); } data.forEach((item, i) => { if (limit && i >= limit) { return; } if (item.user && item.user.login && users.length > 0) { if (!users.includes(item.user.login)) { return; } } let date = new Date(item.createTime) var cell = ''; cell += ''; if (!users.length && !hide.includes('user')) { cell += ''; if (default_avatar.length > 0) { cell += ``; } cell += '' + booiris + ''; cell += ''; } cell += '' + date.toLocaleString() + ''; cell += ''; cell += ''; cell += marked.parse(item.content || ''); var imgs = []; for (let res of item.resources) { if (res.type?.includes('image/')) { imgs.push(res); } } if (imgs.length > 0) { cell += ''; for (let img of imgs) { if (img.externalLink?.length > 0) { cell += ``; } else { cell += ``; } } cell += ''; } cell += ''; cell += ''; $(el).append(cell); }); }); } }); });"},{"path":"/src/auto-render.min.js","content":"!function (e, t) { \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t(require(\"katex\")) : \"function\" == typeof define && define.amd ? define([\"katex\"], t) : \"object\" == typeof exports ? exports.renderMathInElement = t(require(\"katex\")) : e.renderMathInElement = t(e.katex) }(\"undefined\" != typeof self ? self : this, function (e) { return function (e) { var t = {}; function r(n) { if (t[n]) return t[n].exports; var o = t[n] = { i: n, l: !1, exports: {} }; return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports } return r.m = e, r.c = t, r.d = function (e, t, n) { r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n }) }, r.r = function (e) { \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 }) }, r.t = function (e, t) { if (1 & t && (e = r(e)), 8 & t) return e; if (4 & t && \"object\" == typeof e && e && e.__esModule) return e; var n = Object.create(null); if (r.r(n), Object.defineProperty(n, \"default\", { enumerable: !0, value: e }), 2 & t && \"string\" != typeof e) for (var o in e) r.d(n, o, function (t) { return e[t] }.bind(null, o)); return n }, r.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return r.d(t, \"a\", t), t }, r.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, r.p = \"\", r(r.s = 1) }([function (t, r) { t.exports = e }, function (e, t, r) { \"use strict\"; r.r(t); var n = r(0), o = r.n(n), a = function (e, t, r) { for (var n = r, o = 0, a = e.length; n < t.length;) { var i = t[n]; if (o"},{"path":"/game/flappy-bird/index.html","content":"import init from './flappy-bird.js' init()"},{"path":"/game/flappy-bird/flappy-bird.js","content":"const lAudioContext = (typeof AudioContext !== 'undefined' ? AudioContext : (typeof webkitAudioContext !== 'undefined' ? webkitAudioContext : undefined)); let wasm; const heap = new Array(32).fill(undefined); heap.push(undefined, null, true, false); function getObject(idx) { return heap[idx]; } let heap_next = heap.length; function dropObject(idx) { if (idx < 36) return; heap[idx] = heap_next; heap_next = idx; } function takeObject(idx) { const ret = getObject(idx); dropObject(idx); return ret; } const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }); cachedTextDecoder.decode(); let cachedUint8Memory0 = new Uint8Array(); function getUint8Memory0() { if (cachedUint8Memory0.byteLength === 0) { cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer); } return cachedUint8Memory0; } function getStringFromWasm0(ptr, len) { return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len)); } function addHeapObject(obj) { if (heap_next === heap.length) heap.push(heap.length + 1); const idx = heap_next; heap_next = heap[idx]; heap[idx] = obj; return idx; } function isLikeNone(x) { return x === undefined || x === null; } let cachedFloat64Memory0 = new Float64Array(); function getFloat64Memory0() { if (cachedFloat64Memory0.byteLength === 0) { cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer); } return cachedFloat64Memory0; } let cachedInt32Memory0 = new Int32Array(); function getInt32Memory0() { if (cachedInt32Memory0.byteLength === 0) { cachedInt32Memory0 = new Int32Array(wasm.memory.buffer); } return cachedInt32Memory0; } let WASM_VECTOR_LEN = 0; const cachedTextEncoder = new TextEncoder('utf-8'); const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) { return cachedTextEncoder.encodeInto(arg, view); } : function (arg, view) { const buf = cachedTextEncoder.encode(arg); view.set(buf); return { read: arg.length, written: buf.length }; }); function passStringToWasm0(arg, malloc, realloc) { if (realloc === undefined) { const buf = cachedTextEncoder.encode(arg); const ptr = malloc(buf.length); getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf); WASM_VECTOR_LEN = buf.length; return ptr; } let len = arg.length; let ptr = malloc(len); const mem = getUint8Memory0(); let offset = 0; for (; offset < len; offset++) { const code = arg.charCodeAt(offset); if (code > 0x7F) break; mem[ptr + offset] = code; } if (offset !== len) { if (offset !== 0) { arg = arg.slice(offset); } ptr = realloc(ptr, len, len = offset + arg.length * 3); const view = getUint8Memory0().subarray(ptr + offset, ptr + len); const ret = encodeString(arg, view); offset += ret.written; } WASM_VECTOR_LEN = offset; return ptr; } function debugString(val) { // primitive types const type = typeof val; if (type == 'number' || type == 'boolean' || val == null) { return `${val}`; } if (type == 'string') { return `\"${val}\"`; } if (type == 'symbol') { const description = val.description; if (description == null) { return 'Symbol'; } else { return `Symbol(${description})`; } } if (type == 'function') { const name = val.name; if (typeof name == 'string' && name.length > 0) { return `Function(${name})`; } else { return 'Function'; } } // objects if (Array.isArray(val)) { const length = val.length; let debug = '['; if (length > 0) { debug += debugString(val[0]); } for(let i = 1; i < length; i++) { debug += ', ' + debugString(val[i]); } debug += ']'; return debug; } // Test for built-in const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val)); let className; if (builtInMatches.length > 1) { className = builtInMatches[1]; } else { // Failed to match the standard '[object ClassName]' return toString.call(val); } if (className == 'Object') { // we're a user defined class or Object // JSON.stringify avoids problems with cycles, and is generally much // easier than looping through ownProperties of `val`. try { return 'Object(' + JSON.stringify(val) + ')'; } catch (_) { return 'Object'; } } // errors if (val instanceof Error) { return `${val.name}: ${val.message} ${val.stack}`; } // TODO we could test for more things here, like `Set`s and `Map`s. return className; } function makeMutClosure(arg0, arg1, dtor, f) { const state = { a: arg0, b: arg1, cnt: 1, dtor }; const real = (...args) => { // First up with a closure we increment the internal reference // count. This ensures that the Rust closure environment won't // be deallocated while we're invoking it. state.cnt++; const a = state.a; state.a = 0; try { return f(a, state.b, ...args); } finally { if (--state.cnt === 0) { wasm.__wbindgen_export_2.get(state.dtor)(a, state.b); } else { state.a = a; } } }; real.original = state; return real; } function __wbg_adapter_34(arg0, arg1) { wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h27253a35839af148(arg0, arg1); } function __wbg_adapter_37(arg0, arg1, arg2) { wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h1c8b3d7dcee3199d(arg0, arg1, addHeapObject(arg2)); } function handleError(f, args) { try { return f.apply(this, args); } catch (e) { wasm.__wbindgen_exn_store(addHeapObject(e)); } } function getArrayU8FromWasm0(ptr, len) { return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len); } let cachedFloat32Memory0 = new Float32Array(); function getFloat32Memory0() { if (cachedFloat32Memory0.byteLength === 0) { cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer); } return cachedFloat32Memory0; } function getArrayF32FromWasm0(ptr, len) { return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len); } function getArrayI32FromWasm0(ptr, len) { return getInt32Memory0().subarray(ptr / 4, ptr / 4 + len); } let cachedUint32Memory0 = new Uint32Array(); function getUint32Memory0() { if (cachedUint32Memory0.byteLength === 0) { cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer); } return cachedUint32Memory0; } function getArrayU32FromWasm0(ptr, len) { return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len); } async function load(module, imports) { if (typeof Response === 'function' && module instanceof Response) { if (typeof WebAssembly.instantiateStreaming === 'function') { try { return await WebAssembly.instantiateStreaming(module, imports); } catch (e) { if (module.headers.get('Content-Type') != 'application/wasm') { console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error: \", e); } else { throw e; } } } const bytes = await module.arrayBuffer(); return await WebAssembly.instantiate(bytes, imports); } else { const instance = await WebAssembly.instantiate(module, imports); if (instance instanceof WebAssembly.Instance) { return { instance, module }; } else { return instance; } } } function getImports() { const imports = {}; imports.wbg = {}; imports.wbg.__wbg_fetch_c5d08af59be0ee7d = function(arg0, arg1, arg2) { const ret = getObject(arg0).fetch(getStringFromWasm0(arg1, arg2)); return addHeapObject(ret); }; imports.wbg.__wbg_instanceof_Response_eaa426220848a39e = function(arg0) { let result; try { result = getObject(arg0) instanceof Response; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_arrayBuffer_4c27b6f00c530232 = function() { return handleError(function (arg0) { const ret = getObject(arg0).arrayBuffer(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) { const ret = new Uint8Array(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) { const ret = getObject(arg0).length; return ret; }; imports.wbg.__wbindgen_object_drop_ref = function(arg0) { takeObject(arg0); }; imports.wbg.__wbg_connected_41b85c162970593b = function(arg0) { const ret = getObject(arg0).connected; return ret; }; imports.wbg.__wbg_isSecureContext_541f52c311a1c679 = function(arg0) { const ret = getObject(arg0).isSecureContext; return ret; }; imports.wbg.__wbg_mark_40e050a77cc39fea = function(arg0, arg1) { performance.mark(getStringFromWasm0(arg0, arg1)); }; imports.wbg.__wbg_log_c9486ca5d8e2cbe8 = function(arg0, arg1) { try { console.log(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_log_aba5996d9bde071f = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { try { console.log(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5), getStringFromWasm0(arg6, arg7)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_fenceSync_91d72c970c880844 = function(arg0, arg1, arg2) { const ret = getObject(arg0).fenceSync(arg1 >>> 0, arg2 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createVertexArrayOES_00a5c523e5b17eff = function(arg0) { const ret = getObject(arg0).createVertexArrayOES(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createVertexArray_8467a75e68fec199 = function(arg0) { const ret = getObject(arg0).createVertexArray(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_bindVertexArrayOES_84540c072ea96b75 = function(arg0, arg1) { getObject(arg0).bindVertexArrayOES(getObject(arg1)); }; imports.wbg.__wbg_bindVertexArray_9d12800e272184b0 = function(arg0, arg1) { getObject(arg0).bindVertexArray(getObject(arg1)); }; imports.wbg.__wbg_bufferData_a33528a74dd300f4 = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferData(arg1 >>> 0, getObject(arg2), arg3 >>> 0); }; imports.wbg.__wbg_bufferData_8d206d7adf6751c0 = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferData(arg1 >>> 0, getObject(arg2), arg3 >>> 0); }; imports.wbg.__wbg_createSampler_288fd761eabe283d = function(arg0) { const ret = getObject(arg0).createSampler(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_new_0b9bfdd97583284e = function() { const ret = new Object(); return addHeapObject(ret); }; imports.wbg.__wbindgen_string_new = function(arg0, arg1) { const ret = getStringFromWasm0(arg0, arg1); return addHeapObject(ret); }; imports.wbg.__wbg_getContext_a6ea7a8e317f182a = function() { return handleError(function (arg0, arg1, arg2, arg3) { const ret = getObject(arg0).getContext(getStringFromWasm0(arg1, arg2), getObject(arg3)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_instanceof_WebGl2RenderingContext_fcfa91cd777063f3 = function(arg0) { let result; try { result = getObject(arg0) instanceof WebGL2RenderingContext; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbindgen_object_clone_ref = function(arg0) { const ret = getObject(arg0); return addHeapObject(ret); }; imports.wbg.__wbg_exitPointerLock_1405aae165b47bfd = function(arg0) { getObject(arg0).exitPointerLock(); }; imports.wbg.__wbg_requestPointerLock_3bc7c389fbad1a71 = function(arg0) { getObject(arg0).requestPointerLock(); }; imports.wbg.__wbg_exitFullscreen_1510ded2ca20d624 = function(arg0) { getObject(arg0).exitFullscreen(); }; imports.wbg.__wbg_width_2f4b0cbbf1c850d9 = function(arg0) { const ret = getObject(arg0).width; return ret; }; imports.wbg.__wbg_height_a81d308a000d91d0 = function(arg0) { const ret = getObject(arg0).height; return ret; }; imports.wbg.__wbg_requestAnimationFrame_4181656476a7d86c = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).requestAnimationFrame(getObject(arg1)); return ret; }, arguments) }; imports.wbg.__wbg_error_02ffd4185a83fe18 = function(arg0, arg1) { console.error(getObject(arg0), getObject(arg1)); }; imports.wbg.__wbindgen_cb_drop = function(arg0) { const obj = takeObject(arg0).original; if (obj.cnt-- == 1) { obj.a = 0; return true; } const ret = false; return ret; }; imports.wbg.__wbg_clearTimeout_7d6f7bfeed34b348 = function(arg0, arg1) { getObject(arg0).clearTimeout(arg1); }; imports.wbg.__wbg_cancelAnimationFrame_679ac3913d7f9b34 = function() { return handleError(function (arg0, arg1) { getObject(arg0).cancelAnimationFrame(arg1); }, arguments) }; imports.wbg.__wbg_stopPropagation_eca3af16f2d02a91 = function(arg0) { getObject(arg0).stopPropagation(); }; imports.wbg.__wbg_cancelBubble_8c0bdf21c08f1717 = function(arg0) { const ret = getObject(arg0).cancelBubble; return ret; }; imports.wbg.__wbg_innerWidth_ffa584f74d721fce = function() { return handleError(function (arg0) { const ret = getObject(arg0).innerWidth; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_innerHeight_f4804c803fcf02b0 = function() { return handleError(function (arg0) { const ret = getObject(arg0).innerHeight; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_preventDefault_3209279b490de583 = function(arg0) { getObject(arg0).preventDefault(); }; imports.wbg.__wbg_deltaX_6b627fd6f4c19e51 = function(arg0) { const ret = getObject(arg0).deltaX; return ret; }; imports.wbg.__wbg_deltaY_a5393ec7ac0f7bb4 = function(arg0) { const ret = getObject(arg0).deltaY; return ret; }; imports.wbg.__wbg_deltaMode_a90be314f5c676f1 = function(arg0) { const ret = getObject(arg0).deltaMode; return ret; }; imports.wbg.__wbg_addEventListener_1fc744729ac6dc27 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) { getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3), getObject(arg4)); }, arguments) }; imports.wbg.__wbg_buttons_047716c1296e3d1c = function(arg0) { const ret = getObject(arg0).buttons; return ret; }; imports.wbg.__wbg_pointerId_18be034781db46f3 = function(arg0) { const ret = getObject(arg0).pointerId; return ret; }; imports.wbg.__wbg_setPointerCapture_7cc6c6e831d5dae0 = function() { return handleError(function (arg0, arg1) { getObject(arg0).setPointerCapture(arg1); }, arguments) }; imports.wbg.__wbg_getBoundingClientRect_06acb6ac1c23e409 = function(arg0) { const ret = getObject(arg0).getBoundingClientRect(); return addHeapObject(ret); }; imports.wbg.__wbg_clientX_e39206f946859108 = function(arg0) { const ret = getObject(arg0).clientX; return ret; }; imports.wbg.__wbg_x_419967b8271dcf59 = function(arg0) { const ret = getObject(arg0).x; return ret; }; imports.wbg.__wbg_clientY_e376bb2d8f470c88 = function(arg0) { const ret = getObject(arg0).clientY; return ret; }; imports.wbg.__wbg_y_0f67486e0f88b265 = function(arg0) { const ret = getObject(arg0).y; return ret; }; imports.wbg.__wbg_getModifierState_135305ae40997dc7 = function(arg0, arg1, arg2) { const ret = getObject(arg0).getModifierState(getStringFromWasm0(arg1, arg2)); return ret; }; imports.wbg.__wbg_createElement_976dbb84fe1661b5 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_get_55f248d76a5aa3d1 = function(arg0, arg1, arg2) { const ret = getObject(arg0)[getStringFromWasm0(arg1, arg2)]; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_body_3cb4b4042b9a632b = function(arg0) { const ret = getObject(arg0).body; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_appendChild_e513ef0e5098dfdd = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).appendChild(getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_parentElement_0cffb3ceb0f107bd = function(arg0) { const ret = getObject(arg0).parentElement; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_width_3ca95ccb4ba994e2 = function(arg0) { const ret = getObject(arg0).width; return ret; }; imports.wbg.__wbg_height_52d1d8c8ada7c55d = function(arg0) { const ret = getObject(arg0).height; return ret; }; imports.wbg.__wbg_new_abda76e883ba8a5f = function() { const ret = new Error(); return addHeapObject(ret); }; imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) { const ret = getObject(arg1).stack; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) { try { console.error(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_eval_6dc8993472839847 = function() { return handleError(function (arg0, arg1) { const ret = eval(getStringFromWasm0(arg0, arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbindgen_boolean_get = function(arg0) { const v = getObject(arg0); const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2; return ret; }; imports.wbg.__wbg_close_7d5aa2babb9d8fc2 = function() { return handleError(function (arg0) { const ret = getObject(arg0).close(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbindgen_is_object = function(arg0) { const val = getObject(arg0); const ret = typeof(val) === 'object' && val !== null; return ret; }; imports.wbg.__wbg_randomFillSync_6894564c2c334c42 = function() { return handleError(function (arg0, arg1, arg2) { getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2)); }, arguments) }; imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) { const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_getRandomValues_805f1c3d65988a5a = function() { return handleError(function (arg0, arg1) { getObject(arg0).getRandomValues(getObject(arg1)); }, arguments) }; imports.wbg.__wbg_crypto_e1d53a1d73fb10b8 = function(arg0) { const ret = getObject(arg0).crypto; return addHeapObject(ret); }; imports.wbg.__wbg_process_038c26bf42b093f8 = function(arg0) { const ret = getObject(arg0).process; return addHeapObject(ret); }; imports.wbg.__wbg_versions_ab37218d2f0b24a8 = function(arg0) { const ret = getObject(arg0).versions; return addHeapObject(ret); }; imports.wbg.__wbg_node_080f4b19d15bc1fe = function(arg0) { const ret = getObject(arg0).node; return addHeapObject(ret); }; imports.wbg.__wbindgen_is_string = function(arg0) { const ret = typeof(getObject(arg0)) === 'string'; return ret; }; imports.wbg.__wbg_require_78a3dcfbdba9cbce = function() { return handleError(function () { const ret = module.require; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbindgen_is_function = function(arg0) { const ret = typeof(getObject(arg0)) === 'function'; return ret; }; imports.wbg.__wbg_call_168da88779e35f61 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).call(getObject(arg1), getObject(arg2)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_msCrypto_6e7d3e1f92610cbb = function(arg0) { const ret = getObject(arg0).msCrypto; return addHeapObject(ret); }; imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) { const ret = new Uint8Array(arg0 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_navigator_d1dcf282b97e2495 = function(arg0) { const ret = getObject(arg0).navigator; return addHeapObject(ret); }; imports.wbg.__wbg_getGamepads_8001a499f2b689fe = function() { return handleError(function (arg0) { const ret = getObject(arg0).getGamepads(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) { const ret = getObject(arg0).length; return ret; }; imports.wbg.__wbg_instanceof_DomException_c2b4ae110dc047f8 = function(arg0) { let result; try { result = getObject(arg0) instanceof DOMException; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_message_a7af3ee0cc0fe28d = function(arg0, arg1) { const ret = getObject(arg1).message; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbindgen_number_get = function(arg0, arg1) { const obj = getObject(arg1); const ret = typeof(obj) === 'number' ? obj : undefined; getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret; getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret); }; imports.wbg.__wbindgen_is_null = function(arg0) { const ret = getObject(arg0) === null; return ret; }; imports.wbg.__wbg_id_55b63ccda43785eb = function(arg0, arg1) { const ret = getObject(arg1).id; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_buttons_1162e62c0dc4246e = function(arg0) { const ret = getObject(arg0).buttons; return addHeapObject(ret); }; imports.wbg.__wbg_axes_385390941534cfd7 = function(arg0) { const ret = getObject(arg0).axes; return addHeapObject(ret); }; imports.wbg.__wbg_mapping_778a451256a4d95e = function(arg0) { const ret = getObject(arg0).mapping; return addHeapObject(ret); }; imports.wbg.__wbindgen_string_get = function(arg0, arg1) { const obj = getObject(arg1); const ret = typeof(obj) === 'string' ? obj : undefined; var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_now_58886682b7e790d7 = function() { const ret = Date.now(); return ret; }; imports.wbg.__wbindgen_number_new = function(arg0) { const ret = arg0; return addHeapObject(ret); }; imports.wbg.__wbg_createFramebuffer_9b5b0507480146cd = function(arg0) { const ret = getObject(arg0).createFramebuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createFramebuffer_d5f3985ce3652661 = function(arg0) { const ret = getObject(arg0).createFramebuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createShader_4017d9fbc36659af = function(arg0, arg1) { const ret = getObject(arg0).createShader(arg1 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createShader_46a66dce5a9e22d0 = function(arg0, arg1) { const ret = getObject(arg0).createShader(arg1 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createTexture_4ce49e8a8c655124 = function(arg0) { const ret = getObject(arg0).createTexture(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createTexture_269f67d411bdc4dc = function(arg0) { const ret = getObject(arg0).createTexture(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_deleteShader_246e6e678f3eb957 = function(arg0, arg1) { getObject(arg0).deleteShader(getObject(arg1)); }; imports.wbg.__wbg_deleteShader_89369612f61ec145 = function(arg0, arg1) { getObject(arg0).deleteShader(getObject(arg1)); }; imports.wbg.__wbg_shaderSource_a0001b8eab5d44f4 = function(arg0, arg1, arg2, arg3) { getObject(arg0).shaderSource(getObject(arg1), getStringFromWasm0(arg2, arg3)); }; imports.wbg.__wbg_shaderSource_5111981e7afb61fb = function(arg0, arg1, arg2, arg3) { getObject(arg0).shaderSource(getObject(arg1), getStringFromWasm0(arg2, arg3)); }; imports.wbg.__wbg_compileShader_22b038faa1f49857 = function(arg0, arg1) { getObject(arg0).compileShader(getObject(arg1)); }; imports.wbg.__wbg_compileShader_822f38928f6f2a08 = function(arg0, arg1) { getObject(arg0).compileShader(getObject(arg1)); }; imports.wbg.__wbg_createProgram_1c5f8dffd1066e71 = function(arg0) { const ret = getObject(arg0).createProgram(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createProgram_dc6b23d3caa1d86e = function(arg0) { const ret = getObject(arg0).createProgram(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_deleteProgram_ce56000628d7f1ce = function(arg0, arg1) { getObject(arg0).deleteProgram(getObject(arg1)); }; imports.wbg.__wbg_deleteProgram_e8636e3cb5a18a59 = function(arg0, arg1) { getObject(arg0).deleteProgram(getObject(arg1)); }; imports.wbg.__wbg_attachShader_f4d51147351a1906 = function(arg0, arg1, arg2) { getObject(arg0).attachShader(getObject(arg1), getObject(arg2)); }; imports.wbg.__wbg_attachShader_90ad543fb1bccb18 = function(arg0, arg1, arg2) { getObject(arg0).attachShader(getObject(arg1), getObject(arg2)); }; imports.wbg.__wbg_linkProgram_25cda5f9318ea316 = function(arg0, arg1) { getObject(arg0).linkProgram(getObject(arg1)); }; imports.wbg.__wbg_linkProgram_c33885d9ea798810 = function(arg0, arg1) { getObject(arg0).linkProgram(getObject(arg1)); }; imports.wbg.__wbg_getProgramInfoLog_e47d5073d57fb18d = function(arg0, arg1, arg2) { const ret = getObject(arg1).getProgramInfoLog(getObject(arg2)); var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_getProgramInfoLog_1e37a3d1d090ec1c = function(arg0, arg1, arg2) { const ret = getObject(arg1).getProgramInfoLog(getObject(arg2)); var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_getActiveUniform_fd021da851153e8c = function(arg0, arg1, arg2) { const ret = getObject(arg0).getActiveUniform(getObject(arg1), arg2 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_size_878ba1bf0c2ec606 = function(arg0) { const ret = getObject(arg0).size; return ret; }; imports.wbg.__wbg_type_ca7819eaadc2049f = function(arg0) { const ret = getObject(arg0).type; return ret; }; imports.wbg.__wbg_getActiveUniform_97472b76b9daa461 = function(arg0, arg1, arg2) { const ret = getObject(arg0).getActiveUniform(getObject(arg1), arg2 >>> 0); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_useProgram_156511a425feb519 = function(arg0, arg1) { getObject(arg0).useProgram(getObject(arg1)); }; imports.wbg.__wbg_useProgram_35a58ac1e0d9577b = function(arg0, arg1) { getObject(arg0).useProgram(getObject(arg1)); }; imports.wbg.__wbg_createBuffer_6e747d928c9ba46d = function(arg0) { const ret = getObject(arg0).createBuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createBuffer_a6cffb7f7d5b92a3 = function(arg0) { const ret = getObject(arg0).createBuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_bindBuffer_8b5135aa633680f5 = function(arg0, arg1, arg2) { getObject(arg0).bindBuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindBuffer_66e359418f5c82d7 = function(arg0, arg1, arg2) { getObject(arg0).bindBuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindFramebuffer_080d0b0cf22e1645 = function(arg0, arg1, arg2) { getObject(arg0).bindFramebuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindFramebuffer_5c01742edd5d843a = function(arg0, arg1, arg2) { getObject(arg0).bindFramebuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindRenderbuffer_6da549f066c1b8a5 = function(arg0, arg1, arg2) { getObject(arg0).bindRenderbuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindRenderbuffer_f66dee160b94e5ef = function(arg0, arg1, arg2) { getObject(arg0).bindRenderbuffer(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_pixelStorei_bee1e2da4cb1115b = function(arg0, arg1, arg2) { getObject(arg0).pixelStorei(arg1 >>> 0, arg2); }; imports.wbg.__wbg_pixelStorei_51c83dc5117bea35 = function(arg0, arg1, arg2) { getObject(arg0).pixelStorei(arg1 >>> 0, arg2); }; imports.wbg.__wbg_bufferSubData_a116fea11850b38f = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferSubData(arg1 >>> 0, arg2, getObject(arg3)); }; imports.wbg.__wbg_bufferSubData_0e04c6c7fec3c949 = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferSubData(arg1 >>> 0, arg2, getObject(arg3)); }; imports.wbg.__wbg_clearBufferiv_8bb0c2b97eedc22b = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).clearBufferiv(arg1 >>> 0, arg2, getArrayI32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_clearBufferfv_5cc4edeacbcf72e8 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).clearBufferfv(arg1 >>> 0, arg2, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_copyBufferSubData_11187dccce72b79b = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).copyBufferSubData(arg1 >>> 0, arg2 >>> 0, arg3, arg4, arg5); }; imports.wbg.__wbg_copyTexSubImage2D_e815f93a9ef52dd2 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { getObject(arg0).copyTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8); }; imports.wbg.__wbg_copyTexSubImage2D_4c72e3ef713b65e6 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { getObject(arg0).copyTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8); }; imports.wbg.__wbg_deleteBuffer_12fd7d93834069ef = function(arg0, arg1) { getObject(arg0).deleteBuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteBuffer_6fd9bca7f8a6d9de = function(arg0, arg1) { getObject(arg0).deleteBuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteFramebuffer_d7551444a28f508e = function(arg0, arg1) { getObject(arg0).deleteFramebuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteFramebuffer_2617e39d2c39b4da = function(arg0, arg1) { getObject(arg0).deleteFramebuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteSync_48aed3df05f4f497 = function(arg0, arg1) { getObject(arg0).deleteSync(getObject(arg1)); }; imports.wbg.__wbg_deleteTexture_68a539339fd87792 = function(arg0, arg1) { getObject(arg0).deleteTexture(getObject(arg1)); }; imports.wbg.__wbg_deleteTexture_5c40169772519141 = function(arg0, arg1) { getObject(arg0).deleteTexture(getObject(arg1)); }; imports.wbg.__wbg_disable_6835d16c2cd3fa26 = function(arg0, arg1) { getObject(arg0).disable(arg1 >>> 0); }; imports.wbg.__wbg_disable_1659dc1efb5fb934 = function(arg0, arg1) { getObject(arg0).disable(arg1 >>> 0); }; imports.wbg.__wbg_drawArrays_c0dcb4151e0bf007 = function(arg0, arg1, arg2, arg3) { getObject(arg0).drawArrays(arg1 >>> 0, arg2, arg3); }; imports.wbg.__wbg_drawArrays_d587302f7a868d91 = function(arg0, arg1, arg2, arg3) { getObject(arg0).drawArrays(arg1 >>> 0, arg2, arg3); }; imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() { const ret = new Array(); return addHeapObject(ret); }; imports.wbg.__wbg_drawBuffers_23c1572f12f90db2 = function(arg0, arg1) { getObject(arg0).drawBuffers(getObject(arg1)); }; imports.wbg.__wbg_push_740e4b286702d964 = function(arg0, arg1) { const ret = getObject(arg0).push(getObject(arg1)); return ret; }; imports.wbg.__wbg_of_d79bf3cec607f7a4 = function(arg0) { const ret = Array.of(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_drawBuffersWEBGL_482a093ae5a4ad55 = function(arg0, arg1) { getObject(arg0).drawBuffersWEBGL(getObject(arg1)); }; imports.wbg.__wbg_enable_fc393941ac400f72 = function(arg0, arg1) { getObject(arg0).enable(arg1 >>> 0); }; imports.wbg.__wbg_enable_4791414dce6f602a = function(arg0, arg1) { getObject(arg0).enable(arg1 >>> 0); }; imports.wbg.__wbg_framebufferTexture2D_499d1c21458d0113 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).framebufferTexture2D(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, getObject(arg4), arg5); }; imports.wbg.__wbg_framebufferTexture2D_4b810902dffa1ef3 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).framebufferTexture2D(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, getObject(arg4), arg5); }; imports.wbg.__wbg_framebufferTextureLayer_d5e78fc74b8261e3 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).framebufferTextureLayer(arg1 >>> 0, arg2 >>> 0, getObject(arg3), arg4, arg5); }; imports.wbg.__wbg_getIndexedParameter_d4a2b68e14a022a1 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).getIndexedParameter(arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_getUniformLocation_8e9cc276a231ddcd = function(arg0, arg1, arg2, arg3) { const ret = getObject(arg0).getUniformLocation(getObject(arg1), getStringFromWasm0(arg2, arg3)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_getUniformLocation_0da0c93f626244a2 = function(arg0, arg1, arg2, arg3) { const ret = getObject(arg0).getUniformLocation(getObject(arg1), getStringFromWasm0(arg2, arg3)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_samplerParameterf_6eda655d7213cb18 = function(arg0, arg1, arg2, arg3) { getObject(arg0).samplerParameterf(getObject(arg1), arg2 >>> 0, arg3); }; imports.wbg.__wbg_samplerParameteri_390f1debfe40f83b = function(arg0, arg1, arg2, arg3) { getObject(arg0).samplerParameteri(getObject(arg1), arg2 >>> 0, arg3); }; imports.wbg.__wbindgen_memory = function() { const ret = wasm.memory; return addHeapObject(ret); }; imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) { const ret = getObject(arg0).buffer; return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_890b478c8d7226ff = function(arg0, arg1, arg2) { const ret = new Int8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_698c5100ae9c3365 = function(arg0, arg1, arg2) { const ret = new Int16Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_5540e144e9b8b907 = function(arg0, arg1, arg2) { const ret = new Uint16Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_7be13f49af2b2012 = function(arg0, arg1, arg2) { const ret = new Int32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_9cc9adccd861aa26 = function(arg0, arg1, arg2) { const ret = new Uint32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4 = function(arg0, arg1, arg2) { const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_texStorage2D_d25a76ad1b1ea98f = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).texStorage2D(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_uniform1i_50124a48de1da66b = function(arg0, arg1, arg2) { getObject(arg0).uniform1i(getObject(arg1), arg2); }; imports.wbg.__wbg_uniform1i_49986febd844f2c4 = function(arg0, arg1, arg2) { getObject(arg0).uniform1i(getObject(arg1), arg2); }; imports.wbg.__wbg_colorMask_bc13c97d0db65962 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).colorMask(arg1 !== 0, arg2 !== 0, arg3 !== 0, arg4 !== 0); }; imports.wbg.__wbg_colorMask_12687df5490e9bc9 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).colorMask(arg1 !== 0, arg2 !== 0, arg3 !== 0, arg4 !== 0); }; imports.wbg.__wbg_depthMask_88ab181c23c32dcd = function(arg0, arg1) { getObject(arg0).depthMask(arg1 !== 0); }; imports.wbg.__wbg_depthMask_55f538b7411e5023 = function(arg0, arg1) { getObject(arg0).depthMask(arg1 !== 0); }; imports.wbg.__wbg_bindTexture_6f1dec563e82e818 = function(arg0, arg1, arg2) { getObject(arg0).bindTexture(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindTexture_ae9620ea4a6ffb97 = function(arg0, arg1, arg2) { getObject(arg0).bindTexture(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_bindSampler_4b0e0e598e2cae44 = function(arg0, arg1, arg2) { getObject(arg0).bindSampler(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_activeTexture_02b7c73c76c2c06b = function(arg0, arg1) { getObject(arg0).activeTexture(arg1 >>> 0); }; imports.wbg.__wbg_activeTexture_6a9afd67cc0ade73 = function(arg0, arg1) { getObject(arg0).activeTexture(arg1 >>> 0); }; imports.wbg.__wbg_texParameteri_1b210b807f1ea723 = function(arg0, arg1, arg2, arg3) { getObject(arg0).texParameteri(arg1 >>> 0, arg2 >>> 0, arg3); }; imports.wbg.__wbg_texParameteri_21fd6b6b394882c9 = function(arg0, arg1, arg2, arg3) { getObject(arg0).texParameteri(arg1 >>> 0, arg2 >>> 0, arg3); }; imports.wbg.__wbg_texSubImage2D_f06e46b3b25ee691 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).texSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, arg8 >>> 0, arg9); }, arguments) }; imports.wbg.__wbg_texSubImage2D_421e29fed0db07ab = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).texSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, arg8 >>> 0, getObject(arg9)); }, arguments) }; imports.wbg.__wbg_texSubImage2D_cb339dd200dd1179 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).texSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, arg8 >>> 0, getObject(arg9)); }, arguments) }; imports.wbg.__wbg_compressedTexSubImage2D_5b2a7dc8dc7b3e73 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).compressedTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, arg8, arg9); }; imports.wbg.__wbg_compressedTexSubImage2D_fd1cef4f6a5da5c3 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { getObject(arg0).compressedTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, getObject(arg8)); }; imports.wbg.__wbg_compressedTexSubImage2D_30943b654d04ee44 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { getObject(arg0).compressedTexSubImage2D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7 >>> 0, getObject(arg8)); }; imports.wbg.__wbg_texSubImage3D_ebb9e6f80d19a411 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) { getObject(arg0).texSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, arg10 >>> 0, arg11); }, arguments) }; imports.wbg.__wbg_texSubImage3D_591b8511a3c7593a = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) { getObject(arg0).texSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, arg10 >>> 0, getObject(arg11)); }, arguments) }; imports.wbg.__wbg_vertexAttribPointer_63d2aef49627302b = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) { getObject(arg0).vertexAttribPointer(arg1 >>> 0, arg2, arg3 >>> 0, arg4 !== 0, arg5, arg6); }; imports.wbg.__wbg_vertexAttribPointer_3b06d737566f0745 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) { getObject(arg0).vertexAttribPointer(arg1 >>> 0, arg2, arg3 >>> 0, arg4 !== 0, arg5, arg6); }; imports.wbg.__wbg_getUniformBlockIndex_a6f3a994dcc7399d = function(arg0, arg1, arg2, arg3) { const ret = getObject(arg0).getUniformBlockIndex(getObject(arg1), getStringFromWasm0(arg2, arg3)); return ret; }; imports.wbg.__wbg_uniformBlockBinding_50ced0c985f91a02 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniformBlockBinding(getObject(arg1), arg2 >>> 0, arg3 >>> 0); }; imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) { const ret = Reflect.get(getObject(arg0), getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_now_8172cd917e5eda6b = function(arg0) { const ret = getObject(arg0).now(); return ret; }; imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) { const ret = getObject(arg0)[arg1 >>> 0]; return addHeapObject(ret); }; imports.wbg.__wbg_self_6d479506f72c6a71 = function() { return handleError(function () { const ret = self.self; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_window_f2557cc78490aceb = function() { return handleError(function () { const ret = window.window; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_globalThis_7f206bda628d5286 = function() { return handleError(function () { const ret = globalThis.globalThis; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_global_ba75c50d1cf384f4 = function() { return handleError(function () { const ret = global.global; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbindgen_is_undefined = function(arg0) { const ret = getObject(arg0) === undefined; return ret; }; imports.wbg.__wbg_newnoargs_b5b063fc6c2f0376 = function(arg0, arg1) { const ret = new Function(getStringFromWasm0(arg0, arg1)); return addHeapObject(ret); }; imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).call(getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_is_40a66842732708e7 = function(arg0, arg1) { const ret = Object.is(getObject(arg0), getObject(arg1)); return ret; }; imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) { const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2)); return ret; }, arguments) }; imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) { const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) { getObject(arg0).set(getObject(arg1), arg2 >>> 0); }; imports.wbg.__wbg_newwithcontextoptions_0d1099da75124451 = function() { return handleError(function (arg0) { const ret = new lAudioContext(getObject(arg0)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_createBuffer_47ef089f86b99318 = function() { return handleError(function (arg0, arg1, arg2, arg3) { const ret = getObject(arg0).createBuffer(arg1 >>> 0, arg2 >>> 0, arg3); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_resume_244684c4c6bb49fa = function() { return handleError(function (arg0) { const ret = getObject(arg0).resume(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_measure_aa7a73f17813f708 = function() { return handleError(function (arg0, arg1, arg2, arg3) { try { performance.measure(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3)); } finally { wasm.__wbindgen_free(arg0, arg1); wasm.__wbindgen_free(arg2, arg3); } }, arguments) }; imports.wbg.__wbindgen_debug_string = function(arg0, arg1) { const ret = debugString(getObject(arg1)); const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbindgen_throw = function(arg0, arg1) { throw new Error(getStringFromWasm0(arg0, arg1)); }; imports.wbg.__wbg_then_11f7a54d67b4bfad = function(arg0, arg1) { const ret = getObject(arg0).then(getObject(arg1)); return addHeapObject(ret); }; imports.wbg.__wbg_then_cedad20fbbd9418a = function(arg0, arg1, arg2) { const ret = getObject(arg0).then(getObject(arg1), getObject(arg2)); return addHeapObject(ret); }; imports.wbg.__wbg_resolve_99fe17964f31ffc0 = function(arg0) { const ret = Promise.resolve(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_instanceof_Window_acc97ff9f5d2c7b4 = function(arg0) { let result; try { result = getObject(arg0) instanceof Window; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_copyToChannel_e683ef3e184292ab = function() { return handleError(function (arg0, arg1, arg2, arg3) { getObject(arg0).copyToChannel(getArrayF32FromWasm0(arg1, arg2), arg3); }, arguments) }; imports.wbg.__wbg_setbuffer_ead89b52e0bf1c40 = function(arg0, arg1) { getObject(arg0).buffer = getObject(arg1); }; imports.wbg.__wbg_setonended_ae460558754eae1e = function(arg0, arg1) { getObject(arg0).onended = getObject(arg1); }; imports.wbg.__wbg_start_e330425e284a693a = function() { return handleError(function (arg0, arg1) { getObject(arg0).start(arg1); }, arguments) }; imports.wbg.__wbg_destination_df4e9893e562390a = function(arg0) { const ret = getObject(arg0).destination; return addHeapObject(ret); }; imports.wbg.__wbg_currentTime_80316e838e7d1028 = function(arg0) { const ret = getObject(arg0).currentTime; return ret; }; imports.wbg.__wbg_createBufferSource_f06449934aee7f6f = function() { return handleError(function (arg0) { const ret = getObject(arg0).createBufferSource(); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_connect_463d4300ff833991 = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).connect(getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_querySelector_3628dc2c3319e7e0 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).querySelector(getStringFromWasm0(arg1, arg2)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_requestFullscreen_7d41309612540445 = function() { return handleError(function (arg0) { getObject(arg0).requestFullscreen(); }, arguments) }; imports.wbg.__wbg_setAttribute_d8436c14a59ab1af = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) { getObject(arg0).setAttribute(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4)); }, arguments) }; imports.wbg.__wbg_target_bf704b7db7ad1387 = function(arg0) { const ret = getObject(arg0).target; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_addEventListener_cbe4c6f619b032f3 = function() { return handleError(function (arg0, arg1, arg2, arg3) { getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3)); }, arguments) }; imports.wbg.__wbg_removeEventListener_dd20475efce70084 = function() { return handleError(function (arg0, arg1, arg2, arg3) { getObject(arg0).removeEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3)); }, arguments) }; imports.wbg.__wbg_index_94744625261e9824 = function(arg0) { const ret = getObject(arg0).index; return ret; }; imports.wbg.__wbg_pressed_7add67434a3dd765 = function(arg0) { const ret = getObject(arg0).pressed; return ret; }; imports.wbg.__wbg_instanceof_HtmlCanvasElement_97761617af6ea089 = function(arg0) { let result; try { result = getObject(arg0) instanceof HTMLCanvasElement; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_altKey_6dbe46bf3ae42d67 = function(arg0) { const ret = getObject(arg0).altKey; return ret; }; imports.wbg.__wbg_ctrlKey_fd79f035994d9387 = function(arg0) { const ret = getObject(arg0).ctrlKey; return ret; }; imports.wbg.__wbg_key_ad4fc49423a94efa = function(arg0, arg1) { const ret = getObject(arg1).key; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_matches_206d50bc7cb1f89e = function(arg0) { const ret = getObject(arg0).matches; return ret; }; imports.wbg.__wbg_getExtension_e7912bce04869d40 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).getExtension(getStringFromWasm0(arg1, arg2)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_getParameter_4e2ccc745690476a = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).getParameter(arg1 >>> 0); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_getProgramParameter_acf4ae158143e2b2 = function(arg0, arg1, arg2) { const ret = getObject(arg0).getProgramParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_name_2473476082bed625 = function(arg0, arg1) { const ret = getObject(arg1).name; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_getParameter_585a5b83c595ada8 = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).getParameter(arg1 >>> 0); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_getProgramParameter_eaf768a9b399b7cf = function(arg0, arg1, arg2) { const ret = getObject(arg0).getProgramParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_document_3ead31dbcad65886 = function(arg0) { const ret = getObject(arg0).document; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_setTimeout_d6fcf0d9067b8e64 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).setTimeout(getObject(arg1), arg2); return ret; }, arguments) }; imports.wbg.__wbg_deleteVertexArray_00194a31d79df7e5 = function(arg0, arg1) { getObject(arg0).deleteVertexArray(getObject(arg1)); }; imports.wbg.__wbg_deleteVertexArrayOES_98b83132b3d85825 = function(arg0, arg1) { getObject(arg0).deleteVertexArrayOES(getObject(arg1)); }; imports.wbg.__wbg_createRenderbuffer_69c2f0554298bf89 = function(arg0) { const ret = getObject(arg0).createRenderbuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_createRenderbuffer_531167a301a60e27 = function(arg0) { const ret = getObject(arg0).createRenderbuffer(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_renderbufferStorage_4ceec9b17dbd1e76 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).renderbufferStorage(arg1 >>> 0, arg2 >>> 0, arg3, arg4); }; imports.wbg.__wbg_renderbufferStorage_0b6269243d09a9f7 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).renderbufferStorage(arg1 >>> 0, arg2 >>> 0, arg3, arg4); }; imports.wbg.__wbg_renderbufferStorageMultisample_3e76453eed60554b = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).renderbufferStorageMultisample(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_texStorage3D_19979792a7a67f59 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) { getObject(arg0).texStorage3D(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5, arg6); }; imports.wbg.__wbg_getSupportedExtensions_b84494641d686623 = function(arg0) { const ret = getObject(arg0).getSupportedExtensions(); return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_bufferData_d6fac0d761e08fec = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferData(arg1 >>> 0, arg2, arg3 >>> 0); }; imports.wbg.__wbg_bufferData_6ce28904b25c8be9 = function(arg0, arg1, arg2, arg3) { getObject(arg0).bufferData(arg1 >>> 0, arg2, arg3 >>> 0); }; imports.wbg.__wbg_getBufferSubData_6b00169c609c16f7 = function(arg0, arg1, arg2, arg3) { getObject(arg0).getBufferSubData(arg1 >>> 0, arg2, getObject(arg3)); }; imports.wbg.__wbg_deleteRenderbuffer_58c540348fb8606d = function(arg0, arg1) { getObject(arg0).deleteRenderbuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteRenderbuffer_e5b3450b8b57b395 = function(arg0, arg1) { getObject(arg0).deleteRenderbuffer(getObject(arg1)); }; imports.wbg.__wbg_deleteSampler_ec3ca2243d8cfcad = function(arg0, arg1) { getObject(arg0).deleteSampler(getObject(arg1)); }; imports.wbg.__wbg_getShaderParameter_42a35b974329561c = function(arg0, arg1, arg2) { const ret = getObject(arg0).getShaderParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_getShaderParameter_6cd8c36fded266ea = function(arg0, arg1, arg2) { const ret = getObject(arg0).getShaderParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_getShaderInfoLog_ec7e5b959e47645b = function(arg0, arg1, arg2) { const ret = getObject(arg1).getShaderInfoLog(getObject(arg2)); var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_getShaderInfoLog_451545b963646762 = function(arg0, arg1, arg2) { const ret = getObject(arg1).getShaderInfoLog(getObject(arg2)); var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); var len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_deleteQuery_77a7ae09eda297e1 = function(arg0, arg1) { getObject(arg0).deleteQuery(getObject(arg1)); }; imports.wbg.__wbg_getSyncParameter_ab2f9499a91faae0 = function(arg0, arg1, arg2) { const ret = getObject(arg0).getSyncParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_clientWaitSync_ad323ab9e423d0cf = function(arg0, arg1, arg2, arg3) { const ret = getObject(arg0).clientWaitSync(getObject(arg1), arg2 >>> 0, arg3 >>> 0); return ret; }; imports.wbg.__wbg_beginQuery_909ec673d606f873 = function(arg0, arg1, arg2) { getObject(arg0).beginQuery(arg1 >>> 0, getObject(arg2)); }; imports.wbg.__wbg_endQuery_05baee8fc782e5f0 = function(arg0, arg1) { getObject(arg0).endQuery(arg1 >>> 0); }; imports.wbg.__wbg_getQueryParameter_358ea490fb85e05c = function(arg0, arg1, arg2) { const ret = getObject(arg0).getQueryParameter(getObject(arg1), arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_readPixels_db685489e1779d63 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { getObject(arg0).readPixels(arg1, arg2, arg3, arg4, arg5 >>> 0, arg6 >>> 0, getObject(arg7)); }, arguments) }; imports.wbg.__wbg_readPixels_e855be1f94815442 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { getObject(arg0).readPixels(arg1, arg2, arg3, arg4, arg5 >>> 0, arg6 >>> 0, getObject(arg7)); }, arguments) }; imports.wbg.__wbg_readPixels_5d4e6205291096f0 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { getObject(arg0).readPixels(arg1, arg2, arg3, arg4, arg5 >>> 0, arg6 >>> 0, arg7); }, arguments) }; imports.wbg.__wbg_compressedTexSubImage3D_0df5a8ddb9ebafc2 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) { getObject(arg0).compressedTexSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, arg10, arg11); }; imports.wbg.__wbg_compressedTexSubImage3D_9c916feb243112db = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) { getObject(arg0).compressedTexSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, getObject(arg10)); }; imports.wbg.__wbg_copyTexSubImage3D_7a262558a6a33f2e = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) { getObject(arg0).copyTexSubImage3D(arg1 >>> 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9); }; imports.wbg.__wbg_drawElementsInstancedANGLE_6ac21f9a1ebe5f6b = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).drawElementsInstancedANGLE(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_drawArraysInstancedANGLE_89a45d6f51cd0483 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).drawArraysInstancedANGLE(arg1 >>> 0, arg2, arg3, arg4); }; imports.wbg.__wbg_drawElementsInstanced_2e05a96af17fe284 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).drawElementsInstanced(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_drawArraysInstanced_951a1d7e32c4f855 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).drawArraysInstanced(arg1 >>> 0, arg2, arg3, arg4); }; imports.wbg.__wbg_drawElements_e09dbef58c8f099a = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).drawElements(arg1 >>> 0, arg2, arg3 >>> 0, arg4); }; imports.wbg.__wbg_drawElements_241caa588795bcb1 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).drawElements(arg1 >>> 0, arg2, arg3 >>> 0, arg4); }; imports.wbg.__wbg_stencilMask_00541859199befd2 = function(arg0, arg1) { getObject(arg0).stencilMask(arg1 >>> 0); }; imports.wbg.__wbg_stencilMask_4eb0f989e4108b15 = function(arg0, arg1) { getObject(arg0).stencilMask(arg1 >>> 0); }; imports.wbg.__wbg_blendEquation_5d5abe2ee10109a9 = function(arg0, arg1) { getObject(arg0).blendEquation(arg1 >>> 0); }; imports.wbg.__wbg_blendEquation_72746aedc87e3f72 = function(arg0, arg1) { getObject(arg0).blendEquation(arg1 >>> 0); }; imports.wbg.__wbg_blendFunc_49ea28240d4c1084 = function(arg0, arg1, arg2) { getObject(arg0).blendFunc(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_blendFunc_99b48b64bde98c6f = function(arg0, arg1, arg2) { getObject(arg0).blendFunc(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_blendEquationSeparate_fa6aebc5cd0c5285 = function(arg0, arg1, arg2) { getObject(arg0).blendEquationSeparate(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_blendEquationSeparate_f0abe930082fff02 = function(arg0, arg1, arg2) { getObject(arg0).blendEquationSeparate(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_blendFuncSeparate_9fef8acb74d50df5 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).blendFuncSeparate(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, arg4 >>> 0); }; imports.wbg.__wbg_blendFuncSeparate_cecb7dfda39dc38d = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).blendFuncSeparate(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, arg4 >>> 0); }; imports.wbg.__wbg_uniformMatrix4fv_f16e4a5553357886 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix4fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix4fv_68d11b378757596e = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix4fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix3fv_2b7de3010c8ed627 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix3fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix3fv_a02aa02ecb8e5f99 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix3fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix2fv_4173a282fcaa5508 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix2fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniformMatrix2fv_f4fc5e6214cc5549 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).uniformMatrix2fv(getObject(arg1), arg2 !== 0, getArrayF32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniform4iv_19aa13960dc767c2 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform4iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform4iv_67eed4073c7e55c5 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform4iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform3iv_76acc51e8e6fe1a4 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform3iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform3iv_df752fa54b2b8b7b = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform3iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform2iv_8c390eac30cb1de3 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform2iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform2iv_b1b33c9425d5791b = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform2iv(getObject(arg1), getArrayI32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform4fv_a513dc4d02f192d3 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform4fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform4fv_737873ef0bcd5e6c = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform4fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform3fv_d1ef35c158c348e7 = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform3fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform3fv_740a7286bf6328ee = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform3fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform2fv_3aad4d306a1cb8af = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform2fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform2fv_a611afaf4a045f7e = function(arg0, arg1, arg2, arg3) { getObject(arg0).uniform2fv(getObject(arg1), getArrayF32FromWasm0(arg2, arg3)); }; imports.wbg.__wbg_uniform1f_f60e1072e28b8c49 = function(arg0, arg1, arg2) { getObject(arg0).uniform1f(getObject(arg1), arg2); }; imports.wbg.__wbg_uniform1f_ade6c204580582c8 = function(arg0, arg1, arg2) { getObject(arg0).uniform1f(getObject(arg1), arg2); }; imports.wbg.__wbg_bindBufferRange_b8f6dc19661d5cf7 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).bindBufferRange(arg1 >>> 0, arg2 >>> 0, getObject(arg3), arg4, arg5); }; imports.wbg.__wbg_blendColor_3bea829c60b1f6f2 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).blendColor(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_blendColor_50e203e2f58784cb = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).blendColor(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_frontFace_5fd354be6327d46b = function(arg0, arg1) { getObject(arg0).frontFace(arg1 >>> 0); }; imports.wbg.__wbg_frontFace_97d7f9493791771d = function(arg0, arg1) { getObject(arg0).frontFace(arg1 >>> 0); }; imports.wbg.__wbg_cullFace_aa9f8eea262690c0 = function(arg0, arg1) { getObject(arg0).cullFace(arg1 >>> 0); }; imports.wbg.__wbg_cullFace_d6b862a4ad70b414 = function(arg0, arg1) { getObject(arg0).cullFace(arg1 >>> 0); }; imports.wbg.__wbg_disableVertexAttribArray_ab474d273ff59265 = function(arg0, arg1) { getObject(arg0).disableVertexAttribArray(arg1 >>> 0); }; imports.wbg.__wbg_disableVertexAttribArray_6f3d27dd0ad6aabf = function(arg0, arg1) { getObject(arg0).disableVertexAttribArray(arg1 >>> 0); }; imports.wbg.__wbg_enableVertexAttribArray_3d21f4936ad4a378 = function(arg0, arg1) { getObject(arg0).enableVertexAttribArray(arg1 >>> 0); }; imports.wbg.__wbg_enableVertexAttribArray_a1ffc091f3999354 = function(arg0, arg1) { getObject(arg0).enableVertexAttribArray(arg1 >>> 0); }; imports.wbg.__wbg_vertexAttribIPointer_167c7ed4319992e7 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).vertexAttribIPointer(arg1 >>> 0, arg2, arg3 >>> 0, arg4, arg5); }; imports.wbg.__wbg_vertexAttribDivisorANGLE_d5931335aaf0c735 = function(arg0, arg1, arg2) { getObject(arg0).vertexAttribDivisorANGLE(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_vertexAttribDivisor_2dc16945a591d4c6 = function(arg0, arg1, arg2) { getObject(arg0).vertexAttribDivisor(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_polygonOffset_4cba459d8eacb66d = function(arg0, arg1, arg2) { getObject(arg0).polygonOffset(arg1, arg2); }; imports.wbg.__wbg_polygonOffset_7af170d91752512c = function(arg0, arg1, arg2) { getObject(arg0).polygonOffset(arg1, arg2); }; imports.wbg.__wbg_depthFunc_2ac2c797a8220f09 = function(arg0, arg1) { getObject(arg0).depthFunc(arg1 >>> 0); }; imports.wbg.__wbg_depthFunc_1015c3364a49cd2f = function(arg0, arg1) { getObject(arg0).depthFunc(arg1 >>> 0); }; imports.wbg.__wbg_stencilMaskSeparate_5e7b9b536eac0c5d = function(arg0, arg1, arg2) { getObject(arg0).stencilMaskSeparate(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_stencilMaskSeparate_69e9937a9533f4ab = function(arg0, arg1, arg2) { getObject(arg0).stencilMaskSeparate(arg1 >>> 0, arg2 >>> 0); }; imports.wbg.__wbg_stencilOpSeparate_153523493abc8ec8 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).stencilOpSeparate(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, arg4 >>> 0); }; imports.wbg.__wbg_stencilOpSeparate_c57c8bbe863e9f57 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).stencilOpSeparate(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, arg4 >>> 0); }; imports.wbg.__wbg_stencilFuncSeparate_1f0226d5d3acaf47 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).stencilFuncSeparate(arg1 >>> 0, arg2 >>> 0, arg3, arg4 >>> 0); }; imports.wbg.__wbg_stencilFuncSeparate_2939e543fa4caa77 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).stencilFuncSeparate(arg1 >>> 0, arg2 >>> 0, arg3, arg4 >>> 0); }; imports.wbg.__wbg_scissor_4b89b60091ee8f0e = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).scissor(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_scissor_b1b9e314ab6aac29 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).scissor(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_viewport_a93f3881c4202d5e = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).viewport(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_viewport_319ab5302767fcc9 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).viewport(arg1, arg2, arg3, arg4); }; imports.wbg.__wbg_depthRange_5dccc27b5cdd74b3 = function(arg0, arg1, arg2) { getObject(arg0).depthRange(arg1, arg2); }; imports.wbg.__wbg_depthRange_c6ed3371d3b601f8 = function(arg0, arg1, arg2) { getObject(arg0).depthRange(arg1, arg2); }; imports.wbg.__wbg_clearBufferfi_92173f77d7147a2f = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).clearBufferfi(arg1 >>> 0, arg2, arg3, arg4); }; imports.wbg.__wbg_clearBufferuiv_1f5c5e9baa9a3d9b = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).clearBufferuiv(arg1 >>> 0, arg2, getArrayU32FromWasm0(arg3, arg4)); }; imports.wbg.__wbg_uniform4f_5b62a0acebac4494 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).uniform4f(getObject(arg1), arg2, arg3, arg4, arg5); }; imports.wbg.__wbg_uniform4f_d564461a6e4fdfe0 = function(arg0, arg1, arg2, arg3, arg4, arg5) { getObject(arg0).uniform4f(getObject(arg1), arg2, arg3, arg4, arg5); }; imports.wbg.__wbg_invalidateFramebuffer_802e38619851791e = function() { return handleError(function (arg0, arg1, arg2) { getObject(arg0).invalidateFramebuffer(arg1 >>> 0, getObject(arg2)); }, arguments) }; imports.wbg.__wbg_readBuffer_f20d42ed12643534 = function(arg0, arg1) { getObject(arg0).readBuffer(arg1 >>> 0); }; imports.wbg.__wbg_blitFramebuffer_cdc1ebf043046b70 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) { getObject(arg0).blitFramebuffer(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 >>> 0, arg10 >>> 0); }; imports.wbg.__wbg_framebufferRenderbuffer_6b8dd5a111d341e6 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).framebufferRenderbuffer(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, getObject(arg4)); }; imports.wbg.__wbg_framebufferRenderbuffer_963b305ac8cb6fd6 = function(arg0, arg1, arg2, arg3, arg4) { getObject(arg0).framebufferRenderbuffer(arg1 >>> 0, arg2 >>> 0, arg3 >>> 0, getObject(arg4)); }; imports.wbg.__wbg_devicePixelRatio_476ddb014eb2520a = function(arg0) { const ret = getObject(arg0).devicePixelRatio; return ret; }; imports.wbg.__wbg_fullscreenElement_de98779ddf556e06 = function(arg0) { const ret = getObject(arg0).fullscreenElement; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbg_removeListener_c08dac8493263a47 = function() { return handleError(function (arg0, arg1) { getObject(arg0).removeListener(getObject(arg1)); }, arguments) }; imports.wbg.__wbg_button_2bb5dc0116d6b89b = function(arg0) { const ret = getObject(arg0).button; return ret; }; imports.wbg.__wbg_shiftKey_81014521a7612e6a = function(arg0) { const ret = getObject(arg0).shiftKey; return ret; }; imports.wbg.__wbg_ctrlKey_4795fb55a59f026c = function(arg0) { const ret = getObject(arg0).ctrlKey; return ret; }; imports.wbg.__wbg_altKey_2b8d6d80ead4bad7 = function(arg0) { const ret = getObject(arg0).altKey; return ret; }; imports.wbg.__wbg_metaKey_49e49046d8402fb7 = function(arg0) { const ret = getObject(arg0).metaKey; return ret; }; imports.wbg.__wbg_offsetX_8891849b36542d53 = function(arg0) { const ret = getObject(arg0).offsetX; return ret; }; imports.wbg.__wbg_offsetY_1f52082687af467b = function(arg0) { const ret = getObject(arg0).offsetY; return ret; }; imports.wbg.__wbg_movementX_f5947c282009d740 = function(arg0) { const ret = getObject(arg0).movementX; return ret; }; imports.wbg.__wbg_movementY_2c81eed268321a0a = function(arg0) { const ret = getObject(arg0).movementY; return ret; }; imports.wbg.__wbg_keyCode_72faed4278f77f2c = function(arg0) { const ret = getObject(arg0).keyCode; return ret; }; imports.wbg.__wbg_charCode_b0f31612a52c2bff = function(arg0) { const ret = getObject(arg0).charCode; return ret; }; imports.wbg.__wbg_code_06787cd3c7a60600 = function(arg0, arg1) { const ret = getObject(arg1).code; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_shiftKey_908ae224b8722a41 = function(arg0) { const ret = getObject(arg0).shiftKey; return ret; }; imports.wbg.__wbg_metaKey_cdd15bf44efb510e = function(arg0) { const ret = getObject(arg0).metaKey; return ret; }; imports.wbg.__wbg_matchMedia_0b5dc8aaf445df72 = function() { return handleError(function (arg0, arg1, arg2) { const ret = getObject(arg0).matchMedia(getStringFromWasm0(arg1, arg2)); return isLikeNone(ret) ? 0 : addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_addListener_19238ce0935173e6 = function() { return handleError(function (arg0, arg1) { getObject(arg0).addListener(getObject(arg1)); }, arguments) }; imports.wbg.__wbg_matches_0ffc2232d99a6034 = function(arg0) { const ret = getObject(arg0).matches; return ret; }; imports.wbg.__wbg_setwidth_afb418d3fbf71ba7 = function(arg0, arg1) { getObject(arg0).width = arg1 >>> 0; }; imports.wbg.__wbg_setheight_3eb8729b59493242 = function(arg0, arg1) { getObject(arg0).height = arg1 >>> 0; }; imports.wbg.__wbg_style_e9380748cee29f13 = function(arg0) { const ret = getObject(arg0).style; return addHeapObject(ret); }; imports.wbg.__wbg_setProperty_e489dfd8c0a6bffc = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) { getObject(arg0).setProperty(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4)); }, arguments) }; imports.wbg.__wbindgen_closure_wrapper2743 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 327, __wbg_adapter_34); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21156 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 327, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21162 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21166 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21169 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21172 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21175 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21178 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper21181 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 1787, __wbg_adapter_37); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper26316 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 327, __wbg_adapter_34); return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper26996 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 327, __wbg_adapter_37); return addHeapObject(ret); }; return imports; } function initMemory(imports, maybe_memory) { } function finalizeInit(instance, module) { wasm = instance.exports; init.__wbindgen_wasm_module = module; cachedFloat32Memory0 = new Float32Array(); cachedFloat64Memory0 = new Float64Array(); cachedInt32Memory0 = new Int32Array(); cachedUint32Memory0 = new Uint32Array(); cachedUint8Memory0 = new Uint8Array(); wasm.__wbindgen_start(); return wasm; } function initSync(module) { const imports = getImports(); initMemory(imports); if (!(module instanceof WebAssembly.Module)) { module = new WebAssembly.Module(module); } const instance = new WebAssembly.Instance(module, imports); return finalizeInit(instance, module); } async function init(input) { if (typeof input === 'undefined') { input = new URL('flappy-bird_bg.wasm', import.meta.url); } const imports = getImports(); if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) { input = fetch(input); } initMemory(imports); const { instance, module } = await load(await input, imports); return finalizeInit(instance, module); } export { initSync } export default init;"},{"path":"/game/life-game/bootstrap.js","content":"// A dependency graph that contains any wasm must all be imported // asynchronously. This `bootstrap.js` file does the single async import, so // that no one else needs to worry about it again. import(\"./index.js\") .catch(e => console.error(\"Error importing `index.js`:\", e));"},{"path":"/game/life-game/index.html","content":"#fps { white-space: pre; font-family: monospace; }"},{"path":"/game/push-box/bootstrap.js","content":"// A dependency graph that contains any wasm must all be imported // asynchronously. This `bootstrap.js` file does the single async import, so // that no one else needs to worry about it again. import(\"./index.js\") .catch(e => console.error(\"Error importing `index.js`:\", e));"},{"path":"/game/life-game/index.js","content":"import init from \"./pkg/rust_game_booiris.js\"; import { Universe, Cell, wasm } from \"./pkg/rust_game_booiris.js\"; const run = () => { const fps = new class { constructor() { this.fps = document.getElementById(\"fps\"); this.frames = []; this.lastFrameTimeStamp = performance.now(); } render() { // Convert the delta time since the last frame render into a measure // of frames per second. const now = performance.now(); const delta = now - this.lastFrameTimeStamp; this.lastFrameTimeStamp = now; const fps = 1 / delta * 1000; // Save only the latest 100 timings. this.frames.push(fps); if (this.frames.length > 100) { this.frames.shift(); } // Find the max, min, and mean of our 100 latest timings. let min = Infinity; let max = -Infinity; let sum = 0; for (let i = 0; i < this.frames.length; i++) { sum += this.frames[i]; min = Math.min(this.frames[i], min); max = Math.max(this.frames[i], max); } let mean = sum / this.frames.length; // Render the statistics. this.fps.textContent = ` Frames per Second: latest = ${Math.round(fps)} avg of last 100 = ${Math.round(mean)} min of last 100 = ${Math.round(min)} max of last 100 = ${Math.round(max)} `.trim(); } }; const CELL_SIZE = 10; // px const GRID_COLOR = \"#CCCCCC\"; const DEAD_COLOR = \"#FFFFFF\"; const ALIVE_COLOR = \"#022222\"; const universe = Universe.new(); const width = universe.width(); const height = universe.height(); // Give the canvas room for all of our cells and a 1px border // around each of them. const canvas = document.getElementById(\"game-of-life-canvas\"); canvas.height = (CELL_SIZE + 1) * height + 1; canvas.width = (CELL_SIZE + 1) * width + 1; const ctx = canvas.getContext(\"2d\"); canvas.addEventListener(\"click\", (event) => { const boundingRect = canvas.getBoundingClientRect(); const scaleX = canvas.width / boundingRect.width; const scaleY = canvas.height / boundingRect.height; const canvasLeft = (event.clientX - boundingRect.left) * scaleX; const canvasTop = (event.clientY - boundingRect.top) * scaleY; const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1); const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1); universe.toggle_cell(row, col); drawGrid(); drawCells(); }); let animationId = null; const isPaused = () => { return animationId === null; }; const playPauseButton = document.getElementById(\"play-pause\"); const reStartButton = document.getElementById(\"restart\"); const play = () => { playPauseButton.textContent = \"⏸\"; reStartButton.textContent = \"❌\"; renderLoop(); }; const pause = () => { reStartButton.textContent = \"🔥\"; playPauseButton.textContent = \"▶\"; cancelAnimationFrame(animationId); animationId = null; }; playPauseButton.addEventListener(\"click\", (event) => { if (isPaused()) { play(); } else { pause(); } }); reStartButton.addEventListener(\"click\", (event) => { if ((animationId === null)) { universe.restart(); drawGrid(); drawCells(); } }); const renderLoop = () => { fps.render(); universe.tick(); drawGrid(); drawCells(); // setTimeout(() => { // animationId = requestAnimationFrame(renderLoop); // }, 100); animationId = requestAnimationFrame(renderLoop); }; const drawGrid = () => { ctx.beginPath(); ctx.lineWidth = 1 / window.devicePixelRatio; ctx.strokeStyle = GRID_COLOR; // Vertical lines. for (let i = 0; i { const cellsPtr = universe.cells(); const cells = new Uint8Array(wasm.memory.buffer, cellsPtr, width * height); ctx.beginPath(); for (let row = 0; row < height; row++) { for (let col = 0; col < width; col++) { const idx = getIndex(row, col); ctx.fillStyle = cells[idx] === Cell.Dead ? DEAD_COLOR : ALIVE_COLOR; ctx.fillRect( col * (CELL_SIZE + 1) + 1, row * (CELL_SIZE + 1) + 1, CELL_SIZE, CELL_SIZE ); } } ctx.stroke(); }; drawGrid(); drawCells(); // requestAnimationFrame(renderLoop); pause(); }; init().then(run);"},{"path":"/game/push-box/index.js","content":"import init from \"./pkg/push_box.js\"; import { Game, Cell, wasm } from \"./pkg/push_box.js\"; const run = () => { const CELL_SIZE = 50; // px const LINE_SIZE = 4 const LINE_COLOR = \"#EEEEEE\"; const BACK_COLOR = \"#022222\"; const game = Game.new(); const height = game.height(); const width = game.width(); const person = new Image(); person.src = \"./img/spy.svg\" const key = new Image(); key.src = \"./img/key.svg\" const aim = new Image(); aim.src = \"./img/strongbox.svg\" const wall = new Image(); wall.src = \"./img/brick-wall.svg\" const canvas = document.getElementById(\"game-canvas\"); canvas.height = (CELL_SIZE + LINE_SIZE) * height + LINE_SIZE; canvas.width = (CELL_SIZE + LINE_SIZE) * width + LINE_SIZE; let trueHeight = canvas.height let trueWidth = canvas.width const ctx = canvas.getContext(\"2d\"); ctx.canvas.style.imageRendering = 'auto' let devicePixelRatio = window.devicePixelRatio || 1 let backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1 let ratio = devicePixelRatio / backingStoreRatio canvas.width = canvas.width * ratio canvas.height = canvas.height * ratio ctx.scale(ratio, ratio); canvas.style.width = `${trueWidth}px` canvas.style.height = `${trueHeight}px` let iter = 0 const renderLoop = () => { while (true) { if (game.game_over()) { if (iter % 500 == 0) { console.log(iter + 2 + \" begin!\") } iter += 1; game.restart() } if (iter > 5000) { console.log(\"end!!!!\") break } game.tick(); if (iter % 500 == 0) { drawGrid(); drawMap(); game.set_is_log(false) setTimeout(() => { requestAnimationFrame(renderLoop); }, 100); break } else { game.set_is_log(false) } } }; const drawGrid = () => { ctx.fillStyle = BACK_COLOR; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.lineWidth = LINE_SIZE; ctx.strokeStyle = LINE_COLOR; // Vertical lines. for (let i = 0; i { ctx.drawImage(img, 7 + (CELL_SIZE + LINE_SIZE) * x, 7 + (CELL_SIZE + LINE_SIZE) * y, CELL_SIZE - 5, CELL_SIZE - 5) } const drawMap = () => { const roomPtr = game.room(); const room = new Uint8Array(wasm.memory.buffer, roomPtr, width * height); for (let row = 0; row < height; row++) { for (let col = 0; col < width; col++) { const idx = getIndex(row, col); if (room[idx] == Cell.Empty) { continue; } else if (room[idx] == Cell.Person) { drawItem(person, row, col) } else if (room[idx] == Cell.Key) { drawItem(key, row, col) } else if (room[idx] == Cell.Aim) { drawItem(aim, row, col) } else if (room[idx] == Cell.Wall) { drawItem(wall, row, col) } } } } drawGrid(); drawMap(); renderLoop(); }; init().then(run);"},{"path":"/game/push-box/index.html","content":""},{"path":"/game/snake/bootstrap.js","content":"// A dependency graph that contains any wasm must all be imported // asynchronously. This `bootstrap.js` file does the single async import, so // that no one else needs to worry about it again. import(\"./index.js\") .catch(e => console.error(\"Error importing `index.js`:\", e));"},{"path":"/game/snake/draw.js","content":"import { BackEnd, wasm } from \"./test.js\"; const CELL_SIZE = 22; // px let WindowHandle; let Height, Width, Screen; let Ctx; function initDraw(data) { WindowHandle = BackEnd.new(data); Height = WindowHandle.height(); Width = WindowHandle.width(); const screenPtr = WindowHandle.screen(); Screen = new Uint8Array(wasm.memory.buffer, screenPtr, Width * Height * 3); const canvas = document.getElementById(\"canvas\"); canvas.height = CELL_SIZE * Height; canvas.width = CELL_SIZE * Width; Ctx = canvas.getContext(\"2d\"); return; } const getIndex = (row, col, width) => { return row * width * 3 + col * 3; } const draw = () => { Ctx.beginPath(); for (let row = 0; row < Height; row++) { for (let col = 0; col < Width; col++) { const idx = getIndex(row, col, Width); const r = Screen[idx]; const g = Screen[idx + 1]; const b = Screen[idx + 2]; Ctx.fillStyle = `rgb(${r}, ${g}, ${b})`; Ctx.fillRect( col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE ); } } Ctx.stroke(); } const drawRun = () => { draw(); const renderLoop = () => { WindowHandle.run() draw(); setTimeout(() => { requestAnimationFrame(renderLoop); }, 20); } renderLoop(); } export default initDraw; export { draw, drawRun };"},{"path":"/game/snake/foo.js","content":"// foo.js export async function read_file(path) { let resp = await fetch(path); let buffer = await resp.arrayBuffer(); const data = new Uint8Array(buffer); return data; }"},{"path":"/game/snake/index.html.html","content":"Trunk Template"},{"path":"/game/snake/index.js","content":"import { read_file } from \"./foo.js\"; import init from \"./test.js\"; import initDraw, { drawRun } from \"./draw.js\"; const run = (data) => { initDraw(data) drawRun() } await init(); let data = await read_file(\"./snake.nes\"); run(data);"},{"path":"/game/snake/index.html","content":""},{"path":"/game/snake/test.js","content":"let wasm; const heap = new Array(128).fill(undefined); heap.push(undefined, null, true, false); function getObject(idx) { return heap[idx]; } let heap_next = heap.length; function dropObject(idx) { if (idx < 132) return; heap[idx] = heap_next; heap_next = idx; } function takeObject(idx) { const ret = getObject(idx); dropObject(idx); return ret; } function addHeapObject(obj) { if (heap_next === heap.length) heap.push(heap.length + 1); const idx = heap_next; heap_next = heap[idx]; heap[idx] = obj; return idx; } function debugString(val) { // primitive types const type = typeof val; if (type == 'number' || type == 'boolean' || val == null) { return `${val}`; } if (type == 'string') { return `\"${val}\"`; } if (type == 'symbol') { const description = val.description; if (description == null) { return 'Symbol'; } else { return `Symbol(${description})`; } } if (type == 'function') { const name = val.name; if (typeof name == 'string' && name.length > 0) { return `Function(${name})`; } else { return 'Function'; } } // objects if (Array.isArray(val)) { const length = val.length; let debug = '['; if (length > 0) { debug += debugString(val[0]); } for(let i = 1; i < length; i++) { debug += ', ' + debugString(val[i]); } debug += ']'; return debug; } // Test for built-in const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val)); let className; if (builtInMatches.length > 1) { className = builtInMatches[1]; } else { // Failed to match the standard '[object ClassName]' return toString.call(val); } if (className == 'Object') { // we're a user defined class or Object // JSON.stringify avoids problems with cycles, and is generally much // easier than looping through ownProperties of `val`. try { return 'Object(' + JSON.stringify(val) + ')'; } catch (_) { return 'Object'; } } // errors if (val instanceof Error) { return `${val.name}: ${val.message} ${val.stack}`; } // TODO we could test for more things here, like `Set`s and `Map`s. return className; } let WASM_VECTOR_LEN = 0; let cachedUint8Memory0 = null; function getUint8Memory0() { if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) { cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer); } return cachedUint8Memory0; } const cachedTextEncoder = new TextEncoder('utf-8'); const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) { return cachedTextEncoder.encodeInto(arg, view); } : function (arg, view) { const buf = cachedTextEncoder.encode(arg); view.set(buf); return { read: arg.length, written: buf.length }; }); function passStringToWasm0(arg, malloc, realloc) { if (realloc === undefined) { const buf = cachedTextEncoder.encode(arg); const ptr = malloc(buf.length); getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf); WASM_VECTOR_LEN = buf.length; return ptr; } let len = arg.length; let ptr = malloc(len); const mem = getUint8Memory0(); let offset = 0; for (; offset < len; offset++) { const code = arg.charCodeAt(offset); if (code > 0x7F) break; mem[ptr + offset] = code; } if (offset !== len) { if (offset !== 0) { arg = arg.slice(offset); } ptr = realloc(ptr, len, len = offset + arg.length * 3); const view = getUint8Memory0().subarray(ptr + offset, ptr + len); const ret = encodeString(arg, view); offset += ret.written; } WASM_VECTOR_LEN = offset; return ptr; } let cachedInt32Memory0 = null; function getInt32Memory0() { if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) { cachedInt32Memory0 = new Int32Array(wasm.memory.buffer); } return cachedInt32Memory0; } const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }); cachedTextDecoder.decode(); function getStringFromWasm0(ptr, len) { return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len)); } function makeMutClosure(arg0, arg1, dtor, f) { const state = { a: arg0, b: arg1, cnt: 1, dtor }; const real = (...args) => { // First up with a closure we increment the internal reference // count. This ensures that the Rust closure environment won't // be deallocated while we're invoking it. state.cnt++; const a = state.a; state.a = 0; try { return f(a, state.b, ...args); } finally { if (--state.cnt === 0) { wasm.__wbindgen_export_2.get(state.dtor)(a, state.b); } else { state.a = a; } } }; real.original = state; return real; } function __wbg_adapter_14(arg0, arg1, arg2) { wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hf273e620554bcd11(arg0, arg1, addHeapObject(arg2)); } function passArray8ToWasm0(arg, malloc) { const ptr = malloc(arg.length * 1); getUint8Memory0().set(arg, ptr / 1); WASM_VECTOR_LEN = arg.length; return ptr; } function isLikeNone(x) { return x === undefined || x === null; } function handleError(f, args) { try { return f.apply(this, args); } catch (e) { wasm.__wbindgen_exn_store(addHeapObject(e)); } } function getArrayU8FromWasm0(ptr, len) { return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len); } /** */ export class BackEnd { static __wrap(ptr) { const obj = Object.create(BackEnd.prototype); obj.ptr = ptr; return obj; } __destroy_into_raw() { const ptr = this.ptr; this.ptr = 0; return ptr; } free() { const ptr = this.__destroy_into_raw(); wasm.__wbg_backend_free(ptr); } /** * @param {Uint8Array} data * @returns {BackEnd} */ static new(data) { const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc); const len0 = WASM_VECTOR_LEN; const ret = wasm.backend_new(ptr0, len0); return BackEnd.__wrap(ret); } /** * @returns {number} */ width() { const ret = wasm.backend_width(this.ptr); return ret >>> 0; } /** * @returns {number} */ height() { const ret = wasm.backend_height(this.ptr); return ret >>> 0; } /** * @returns {number} */ screen() { const ret = wasm.backend_screen(this.ptr); return ret; } /** */ run() { wasm.backend_run(this.ptr); } } async function load(module, imports) { if (typeof Response === 'function' && module instanceof Response) { if (typeof WebAssembly.instantiateStreaming === 'function') { try { return await WebAssembly.instantiateStreaming(module, imports); } catch (e) { if (module.headers.get('Content-Type') != 'application/wasm') { console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error: \", e); } else { throw e; } } } const bytes = await module.arrayBuffer(); return await WebAssembly.instantiate(bytes, imports); } else { const instance = await WebAssembly.instantiate(module, imports); if (instance instanceof WebAssembly.Instance) { return { instance, module }; } else { return instance; } } } function getImports() { const imports = {}; imports.wbg = {}; imports.wbg.__wbindgen_object_drop_ref = function(arg0) { takeObject(arg0); }; imports.wbg.__wbg_instanceof_Window_e266f02eee43b570 = function(arg0) { let result; try { result = getObject(arg0) instanceof Window; } catch { result = false; } const ret = result; return ret; }; imports.wbg.__wbg_document_950215a728589a2d = function(arg0) { const ret = getObject(arg0).document; return isLikeNone(ret) ? 0 : addHeapObject(ret); }; imports.wbg.__wbindgen_object_clone_ref = function(arg0) { const ret = getObject(arg0); return addHeapObject(ret); }; imports.wbg.__wbg_addEventListener_615d4590d38da1c9 = function() { return handleError(function (arg0, arg1, arg2, arg3) { getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3)); }, arguments) }; imports.wbg.__wbg_key_f0decac219aa904b = function(arg0, arg1) { const ret = getObject(arg1).key; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_new_abda76e883ba8a5f = function() { const ret = new Error(); return addHeapObject(ret); }; imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) { const ret = getObject(arg1).stack; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) { try { console.error(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) { getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2)); }; imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) { getObject(arg0).getRandomValues(getObject(arg1)); }; imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () { const ret = self.self; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) { const ret = getObject(arg0).crypto; return addHeapObject(ret); }; imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) { const ret = getObject(arg0).msCrypto; return addHeapObject(ret); }; imports.wbg.__wbindgen_is_undefined = function(arg0) { const ret = getObject(arg0) === undefined; return ret; }; imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() { const ret = module; return addHeapObject(ret); }; imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) { const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2)); return addHeapObject(ret); }; imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) { const ret = getObject(arg0).getRandomValues; return addHeapObject(ret); }; imports.wbg.__wbg_newnoargs_2b8b6bd7753c76ba = function(arg0, arg1) { const ret = new Function(getStringFromWasm0(arg0, arg1)); return addHeapObject(ret); }; imports.wbg.__wbg_call_95d1ea488d03e4e8 = function() { return handleError(function (arg0, arg1) { const ret = getObject(arg0).call(getObject(arg1)); return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_self_e7c1f827057f6584 = function() { return handleError(function () { const ret = self.self; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_window_a09ec664e14b1b81 = function() { return handleError(function () { const ret = window.window; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_globalThis_87cbb8506fecf3a9 = function() { return handleError(function () { const ret = globalThis.globalThis; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_global_c85a9259e621f3db = function() { return handleError(function () { const ret = global.global; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_buffer_cf65c07de34b9a08 = function(arg0) { const ret = getObject(arg0).buffer; return addHeapObject(ret); }; imports.wbg.__wbg_new_537b7341ce90bb31 = function(arg0) { const ret = new Uint8Array(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_set_17499e8aa4003ebd = function(arg0, arg1, arg2) { getObject(arg0).set(getObject(arg1), arg2 >>> 0); }; imports.wbg.__wbg_length_27a2afe8ab42b09f = function(arg0) { const ret = getObject(arg0).length; return ret; }; imports.wbg.__wbg_newwithlength_b56c882b57805732 = function(arg0) { const ret = new Uint8Array(arg0 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_subarray_7526649b91a252a6 = function(arg0, arg1, arg2) { const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbindgen_debug_string = function(arg0, arg1) { const ret = debugString(getObject(arg1)); const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbindgen_throw = function(arg0, arg1) { throw new Error(getStringFromWasm0(arg0, arg1)); }; imports.wbg.__wbindgen_memory = function() { const ret = wasm.memory; return addHeapObject(ret); }; imports.wbg.__wbindgen_closure_wrapper63 = function(arg0, arg1, arg2) { const ret = makeMutClosure(arg0, arg1, 12, __wbg_adapter_14); return addHeapObject(ret); }; return imports; } function initMemory(imports, maybe_memory) { } function finalizeInit(instance, module) { wasm = instance.exports; init.__wbindgen_wasm_module = module; cachedInt32Memory0 = null; cachedUint8Memory0 = null; return wasm; } function initSync(module) { const imports = getImports(); initMemory(imports); if (!(module instanceof WebAssembly.Module)) { module = new WebAssembly.Module(module); } const instance = new WebAssembly.Instance(module, imports); return finalizeInit(instance, module); } async function init(input) { if (typeof input === 'undefined') { input = new URL('test_bg.wasm', import.meta.url); } const imports = getImports(); if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) { input = fetch(input); } initMemory(imports); const { instance, module } = await load(await input, imports); return finalizeInit(instance, module); } export { initSync } export default init; export { wasm }"},{"title":"1.2 链表","path":"/wiki/redis/1.2 链表.html","content":"TODO 1"},{"title":"1.1 SDS(动态字符串)","path":"/wiki/redis/1.1 SDS(动态字符串).html","content":"SDS介绍 Redis自己构建了一种名为简单动态字符串(simple dynamic string, SDS) 的抽象类型，并将其作为Redis的默认字符串表示。 SDS定义 在 Redis7.0 中 定义的代码位于 src/sds.h 中，定义如下。 123456789101112131415161718192021222324252627282930/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */struct __attribute__ ((__packed__)) sdshdr5 &#123; unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; // 柔性数组&#125;;struct __attribute__ ((__packed__)) sdshdr8 &#123; uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; // 柔性数组&#125;;struct __attribute__ ((__packed__)) sdshdr16 &#123; uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; // 柔性数组&#125;;struct __attribute__ ((__packed__)) sdshdr32 &#123; uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; // 柔性数组&#125;;struct __attribute__ ((__packed__)) sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; // 柔性数组&#125;; 根据字符串长度不同，用来存放它的sds类型也不同。 其中 len 表示使用的字符串长度，alloc 表示分配的总空间的长度，flags 表示当前结构体类型，因为只有五种类型，所以只使用低三位，有如下枚举值。 12345#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4 结构前加上了 __attribute__ ((__packed__)) 取消编译器的内存对齐[1]。从图中可以看出，不同的数据类型有不同的对齐方式，flags 与 buf 存在填充数据，如果没有取消内存对齐， (char*)buf - 1 无法直接获取数据类型的 flags。 SDS的内存分配方式详见 1.8 内存分配。 接口定义 字符串属性接口 12345678910// len 属性相关static inline size_t sdslen(const sds s) ;static inline size_t sdsavail(const sds s);static inline void sdssetlen(sds s, size_t newlen) ;static inline void sdsinclen(sds s, size_t inc);// alloc 属性相关/* sdsalloc() = sdsavail() + sdslen() */static inline size_t sdsalloc(const sds s);static inline void sdssetalloc(sds s, size_t newlen); sdslen 接口 sdslen 函数返回字符串的当前长度。 12345678910111213141516static inline size_t sdslen(const sds s) &#123; unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) &#123; case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)-&gt;len; case SDS_TYPE_16: return SDS_HDR(16,s)-&gt;len; case SDS_TYPE_32: return SDS_HDR(32,s)-&gt;len; case SDS_TYPE_64: return SDS_HDR(64,s)-&gt;len; &#125; return 0;&#125; sds 由 typedef char* sds; 定义。可以看到，sds 实际上就是指向 sds 结构体的 buf 属性的指针。由于取消了内存对齐，flags 和 buf 中不含有填充数据，(char *)buf - 1 就是 flags的值。根据 flags 的值判断字符串 1#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) sdsavail 接口 12345678910111213141516171819202122232425static inline size_t sdsavail(const sds s) &#123; unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; return 0; &#125; case SDS_TYPE_8: &#123; SDS_HDR_VAR(8,s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_16: &#123; SDS_HDR_VAR(16,s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_32: &#123; SDS_HDR_VAR(32,s); return sh-&gt;alloc - sh-&gt;len; &#125; case SDS_TYPE_64: &#123; SDS_HDR_VAR(64,s); return sh-&gt;alloc - sh-&gt;len; &#125; &#125; return 0;&#125; sdssetlen 接口 1234567891011121314151617181920212223static inline void sdssetlen(sds s, size_t newlen) &#123; unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char*)s)-1; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); &#125; break; case SDS_TYPE_8: SDS_HDR(8,s)-&gt;len = newlen; break; case SDS_TYPE_16: SDS_HDR(16,s)-&gt;len = newlen; break; case SDS_TYPE_32: SDS_HDR(32,s)-&gt;len = newlen; break; case SDS_TYPE_64: SDS_HDR(64,s)-&gt;len = newlen; break; &#125;&#125; sdsinclen 接口 123456789101112131415161718192021222324static inline void sdsinclen(sds s, size_t inc) &#123; unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) &#123; case SDS_TYPE_5: &#123; unsigned char *fp = ((unsigned char*)s)-1; unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc; *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS); &#125; break; case SDS_TYPE_8: SDS_HDR(8,s)-&gt;len += inc; break; case SDS_TYPE_16: SDS_HDR(16,s)-&gt;len += inc; break; case SDS_TYPE_32: SDS_HDR(32,s)-&gt;len += inc; break; case SDS_TYPE_64: SDS_HDR(64,s)-&gt;len += inc; break; &#125;&#125; 参考链接 c - Redis 源码解读——sds_个人文章 - SegmentFault 思否 redis源码解读(一):基础数据结构之SDS_czrzchao的博客-CSDN博客 TODO: 定义##操作符 如果没有预定义对齐值，那么结构体或者类的自身对齐值等于其成员中自身对齐值最大的那个值。 ↩︎"},{"title":"1.3 字典","path":"/wiki/redis/1.3 字典.html","content":"TODO"},{"title":"1.4 跳表","path":"/wiki/redis/1.4 跳表.html","content":"TODO"},{"title":"1.5 整数集合","path":"/wiki/redis/1.5 整数集合.html","content":"TODO"},{"title":"1.7 对象","path":"/wiki/redis/1.7 对象.html","content":"TODO"},{"title":"1.8 内存分配","path":"/wiki/redis/1.8 内存分配.html","content":"TODO"},{"title":"1.6 压缩列表","path":"/wiki/redis/1.6 压缩列表.html","content":"TODO"},{"title":"目录","path":"/wiki/redis/catalog.html","content":"参考 《Redis设计与实现》 第一章：数据对象 1.1 SDS(动态字符串) 1.2 链表 1.3 字典 1.4 跳表 1.5 整数集合 1.6 压缩列表 1.7 对象 1.8 内存分配 第二章： RDB 持久化"},{"title":"开始","path":"/wiki/redis/开始.html","content":"参考 《Redis设计与实现》 redis 7.0 代码结构"},{"title":"1051-Height Checker","path":"/wiki/leetcode/1051-Height Checker.html","content":"题意 A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed). Return the number of indices where heights[i] != expected[i]. 题解 排序原数组，对应位置不同的计数加一，返回最终不同元素的计数。 12345678910111213141516171819202122232425#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int heightChecker(vector&lt;int&gt; &amp;heights) &#123; vector&lt;int&gt; temp(heights); sort(heights.begin(), heights.end()); int res = 0; for (int i = 0; i &lt; heights.size(); i++) &#123; if (heights[i] != temp[i]) res++; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"1089-Duplicate Zeros","path":"/wiki/leetcode/1089-Duplicate Zeros.html","content":"题意 给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。 注意：请不要在超过该数组长度的位置写入元素。 要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西，空间复杂度为 O(1)O(1)O(1)。 题解 使用双指针，通过维护两个双指针模拟栈。 12345678910111213141516171819202122232425262728293031#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: void duplicateZeros(vector&lt;int&gt; &amp;arr) &#123; int now = 0, top = 0; while (top &lt; arr.size()) &#123; if (arr[now] == 0) top++; now++, top++; &#125; while (now &gt; 0) &#123; now--, top--; if (arr[now] == 0) &#123; if (top &lt; arr.size()) arr[top] = 0; top--; &#125; arr[top] = arr[now]; &#125; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"1157-Online Majority Element In Subarray","path":"/wiki/leetcode/1157-Online Majority Element In Subarray.html","content":"题意 设计一个数据结构，有效地找到给定子数组的 多数元素 。 子数组的 多数元素 是在子数组中出现 threshold 次数或次数以上的元素。 实现 MajorityChecker 类: MajorityChecker(int[] arr) 会用给定的数组 arr 对 MajorityChecker 初始化。 int query(int left, int right, int threshold) 返回子数组中的元素 arr[left…right] 至少出现 threshold 次数，如果不存在这样的元素则返回 -1。 题解 线段树+摩尔投票 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#![allow(dead_code, unused_imports, unused_macros)]use std::cmp::*;use std::collections::*;use std::f32::consts::E;use std::ops::AddAssign;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;#[derive(Clone, Copy)]pub struct Node &#123; num: i32, cnt: i32,&#125;impl Node &#123; #[inline] fn new(num: i32, cnt: i32) -&gt; Self &#123; Node &#123; num, cnt &#125; &#125;&#125;impl AddAssign for Node &#123; fn add_assign(&amp;mut self, rhs: Self) &#123; if self.num == rhs.num &#123; self.cnt += rhs.cnt; &#125; else if self.cnt &gt;= rhs.cnt &#123; self.cnt -= rhs.cnt; &#125; else &#123; self.num = rhs.num; self.cnt = rhs.cnt - self.cnt; &#125; &#125;&#125;pub struct SegTree &#123; tree: Vec&lt;Node&gt;, val: Vec&lt;i32&gt;, len: usize,&#125;impl SegTree &#123; #[inline] pub fn new(arr: Vec&lt;i32&gt;) -&gt; Self &#123; let len = arr.len(); SegTree &#123; tree: vec![Node::new(0, 0); len * 4 + 1], val: arr, len, &#125; &#125; pub fn build(&amp;mut self, id: usize, l: usize, r: usize) &#123; if l == r &#123; self.tree[id].num = self.val[l]; self.tree[id].cnt = 1; return; &#125; let mid = (l + r) / 2; self.build(id * 2 + 1, l, mid); self.build(id * 2 + 2, mid + 1, r); let temp = self.tree[id * 2 + 1]; self.tree[id] += temp; let temp = self.tree[id * 2 + 2]; self.tree[id] += temp; &#125; pub fn query(&amp;self, id: usize, l: usize, r: usize, ql: usize, qr: usize, ans: &amp;mut Node) &#123; if l &gt; qr || r &lt; ql &#123; return; &#125; if ql &lt;= l &amp;&amp; r &lt;= qr &#123; *ans += self.tree[id]; return; &#125; let mid = (l + r) / 2; self.query(id * 2 + 1, l, mid, ql, qr, ans); self.query(id * 2 + 2, mid + 1, r, ql, qr, ans); &#125;&#125;struct MajorityChecker &#123; seg_tree: SegTree, loc: HashMap&lt;i32, Vec&lt;usize&gt;&gt;,&#125;/** * `&amp;self` means the method takes an immutable reference. * If you need a mutable reference, change it to `&amp;mut self` instead. */impl MajorityChecker &#123; fn new(arr: Vec&lt;i32&gt;) -&gt; Self &#123; let mut loc = HashMap::new(); for (i, v) in arr.iter().enumerate() &#123; loc.entry(*v).or_insert(vec![]).push(i); &#125; let mut seg_tree = SegTree::new(arr); seg_tree.build(0, 0, seg_tree.len - 1); MajorityChecker &#123; seg_tree, loc &#125; &#125; fn query(&amp;self, left: i32, right: i32, threshold: i32) -&gt; i32 &#123; let mut ans = Node::new(0, 0); self.seg_tree.query( 0, 0, self.seg_tree.len - 1, left as usize, right as usize, &amp;mut ans, ); let key = self.loc.get(&amp;ans.num); if key.is_none() &#123; return -1; &#125; let key = key.unwrap(); let cnt = key.partition_point(|x| *x &lt;= right as usize) - key.partition_point(|x| *x &lt; left as usize); if cnt &gt;= threshold as usize &#123; ans.num &#125; else &#123; -1 &#125; &#125;&#125;/** * Your MajorityChecker object will be instantiated and called as such: * let obj = MajorityChecker::new(arr); * let ret_1: i32 = obj.query(left, right, threshold); */#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; let arr = [1, 1, 2, 2, 1, 1]; let obj = MajorityChecker::new(arr.into()); let ini = [[0, 5, 4], [0, 3, 3], [2, 3, 2]]; for x in ini &#123; println!(&quot;res:&#123;&#125;&quot;, obj.query(x[0], x[1], x[2])); &#125;&#125; 树套树","tags":[null,null,null]},{"title":"1302-Deepest Leaves Sum","path":"/wiki/leetcode/1302-Deepest Leaves Sum.html","content":"题意 给出一个二叉树，计算最深一层的节点和。 题解 dfs，如果当前的层数大于最大层数，则更新最大层数，并且重置节点和。当当前层数等于最大层数的时候，将当前节点值加入节点和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#[allow(dead_code)]#[allow(unused_imports)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;// Definition for a binary tree node.#[cfg(feature = &quot;local&quot;)]#[derive(Debug, PartialEq, Eq)]pub struct TreeNode &#123; pub val: i32, pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,&#125;#[cfg(feature = &quot;local&quot;)]impl TreeNode &#123; #[inline] pub fn new(val: i32) -&gt; Self &#123; TreeNode &#123; val, left: None, right: None, &#125; &#125;&#125;fn dfs(now: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, depth: i32, maxdepth: &amp;mut i32, key: &amp;mut i32) &#123; if let Some(ref x) = now &#123; if depth &gt; *maxdepth &#123; *maxdepth = depth; *key = 0; &#125; if depth == *maxdepth &#123; *key += x.borrow().val; &#125; dfs(x.borrow_mut().left.take(), depth + 1, maxdepth, key); dfs(x.borrow_mut().right.take(), depth + 1, maxdepth, key); &#125;&#125;use std::cell::RefCell;use std::rc::Rc;impl Solution &#123; pub fn deepest_leaves_sum(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; i32 &#123; let mut maxdepth = 0; let mut key = 0; dfs(root, 0, &amp;mut maxdepth, &amp;mut key); key &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; println!(&quot;res:&quot;);&#125;"},{"title":"1403-Minimum Subsequence in Non-Increasing Order","path":"/wiki/leetcode/1403-Minimum Subsequence in Non-Increasing Order.html","content":"题意 给出一个数组，将数组分为两个部分，其中一个部分A和严格大于另一部分和，要求A部分尽可能短，如果先相同长度A的和尽可能大。 题解 从大到小排序数组，不断取出当前最大的数直到取出的数的和大于剩下的数的和。取出的数集即为答案。 123456789101112131415161718192021222324252627282930313233343536373839#[allow(dead_code)]#[allow(unused_imports)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;impl Solution &#123; pub fn min_subsequence(mut nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123; nums.sort_unstable(); nums.reverse(); let mut sum = nums.iter().sum(); let mut res = vec![]; let mut now = 0; for num in nums.iter() &#123; now += *num; sum -= *num; res.push(*num); if now &gt; sum &#123; break; &#125; &#125; res &#125;&#125;#[cfg(test)]pub fn main() &#123; println!(&quot;res:&#123;:?&#125;&quot;, Solution::min_subsequence(vec![4, 3, 10, 9, 8]));&#125;","tags":[null]},{"title":"1728-Cat and Mouse II","path":"/wiki/leetcode/1728-Cat and Mouse II.html","content":"题意 A game is played by a cat and a mouse named Cat and Mouse. The environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food. Players are represented by the characters ‘C’(Cat),‘M’(Mouse). Floors are represented by the character ‘.’ and can be walked on. Walls are represented by the character ‘#’ and cannot be walked on. Food is represented by the character ‘F’ and can be walked on. There is only one of each character ‘C’, ‘M’, and ‘F’ in grid. Mouse and Cat play according to the following rules: Mouse moves first, then they take turns to move. During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid. catJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length. Staying in the same position is allowed. Mouse can jump over Cat. The game can end in 4 ways: If Cat occupies the same position as Mouse, Cat wins. If Cat reaches the food first, Cat wins. If Mouse reaches the food first, Mouse wins. If Mouse cannot get to the food within 1000 turns, Cat wins. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false. 题解1（伪） 博弈+记忆化搜索剪枝。 如果轮到玩家1行动，搜索当前玩家所有可行的行动，如果有可以获胜的行动，那么玩家1一定会采用这个行动，所以此层博弈返回玩家1获胜。如果玩家1下一步的所有行动都不能获胜，那么玩家1必败，所以此层博弈返回玩家1失败。玩家2的情况类似。 使用 dfs 搜索博弈树，使用一个状态数组保存搜索状态，然而，最大步数为 1000。所有的状态有 1000层 ×\\times× 玩家1可能的位置 8*8=64 ×\\times× 玩家2可能的位置 8*8=64。总状态有 1000×64×64=4e61000 \\times 64 \\times 64 = 4e61000×64×64=4e6 ，在 TLE 的边缘。不出意外，提交会出现 TLE。玄学设置最大层数为 256，就卡过去了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int cj, mj; vector&lt;string&gt; grid; int n, m; int vis[260][64][64]; int dir[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;; int dfs(int x1, int y1, int x2, int y2, int depth, int player) &#123; if (x1 == x2 &amp;&amp; y1 == y2) return 2; if (depth &gt;= 256) return 2; if (grid[x1][y1] == &#x27;F&#x27;) return 1; if (grid[x2][y2] == &#x27;F&#x27;) return 2; int pos1 = x1 * m + y1; int pos2 = x2 * m + y2; if (vis[depth][pos1][pos2] != 0) &#123; return vis[depth][pos1][pos2]; &#125; // cout &lt;&lt; player &lt;&lt; &quot; &quot; &lt;&lt; x1 &lt;&lt; &quot; &quot; &lt;&lt; y1 &lt;&lt; &quot; &quot; &lt;&lt; x2 &lt;&lt; &quot; &quot; &lt;&lt; y2 &lt;&lt; &quot; &quot;; int res = 0; if (player == 1) &#123; for (int j = 0; j &lt; 4; j++) &#123; for (int i = 1; i &lt;= mj; i++) &#123; int nx = x1 + dir[j][0] * i, ny = y1 + dir[j][1] * i; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) break; if (grid[nx][ny] == &#x27;#&#x27;) break; int flag = dfs(nx, ny, x2, y2, depth + 1, 2); if (flag == 1) res = 1; &#125; &#125; int flag = dfs(x1, y1, x2, y2, depth + 1, 2); if (flag == 1) res = 1; if (res == 0) res = 2; &#125; else &#123; for (int j = 0; j &lt; 4; j++) &#123; for (int i = 1; i &lt;= cj; i++) &#123; int nx = x2 + dir[j][0] * i, ny = y2 + dir[j][1] * i; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) break; if (grid[nx][ny] == &#x27;#&#x27;) break; int flag = dfs(x1, y1, nx, ny, depth + 1, 1); if (flag == 2) res = 2; &#125; &#125; int flag = dfs(x1, y1, x2, y2, depth + 1, 1); if (flag == 2) res = 2; if (res == 0) res = 1; &#125; vis[depth][pos1][pos2] = res; return res; &#125; bool canMouseWin(vector&lt;string&gt; _grid, int _catJump, int _mouseJump) &#123; cj = _catJump; mj = _mouseJump; grid = _grid; n = grid.size(); m = grid[0].size(); int mx, my, cx, cy; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == &#x27;C&#x27;) cx = i, cy = j; if (grid[i][j] == &#x27;M&#x27;) mx = i, my = j; &#125; &#125; return dfs(mx, my, cx, cy, 0, 1) == 1 ? true : false; &#125;&#125;;#ifdef LOCALint main() &#123; // ios::sync_with_stdio(false); // cin.tie(0); Solution s; // .M... // ..#.. // #..#. // C#.#. // ...#F vector&lt;string&gt; a = &#123;&quot;.M...&quot;, &quot;..#..&quot;, &quot;#..#.&quot;, &quot;C#.#.&quot;, &quot;...#F&quot;&#125;; cout &lt;&lt; s.canMouseWin(a, 3, 1) &lt;&lt; &quot; &quot;;&#125;#endif 题解2 拓扑排序 #todo [ ] TODO: 拓扑排序","tags":[null,null]},{"title":"1823-Find the Winner of the Circular Game","path":"/wiki/leetcode/1823-Find the Winner of the Circular Game.html","content":"题意 约瑟夫环问题，从 1 开始，数 k 个数，最后一个人出去，再接着数，直到剩下最后一个人，求最后一个人对应的位置。 下面是 5 个人，每次数 2 个的情况。 题解 对于最后一个人，每次操作与下一次操作差 k， 递归解决即可，注意下标从 1 开始，注意一下边界条件。 1234567891011121314151617181920212223#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int findTheWinner(int n, int k) &#123; if (n == 1) return 1; int pre = findTheWinner(n - 1, k); int res = (pre + k) % n; return res == 0 ? n : res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0); Solution s; cout &lt;&lt; s.findTheWinner(5, 2) &lt;&lt; &quot; &quot;;&#125;#endif","tags":[null]},{"title":"442-Find All Duplicates in an Array","path":"/wiki/leetcode/442-Find All Duplicates in an Array.html","content":"题意 给出一个长度为 n 的数组，每个数组元素的值为 [1,n], 数组中存在出现一次和出现两次的元素，要求在 O(n)O(n)O(n) 时间和 O(1)O(1)O(1) 空间返回出现两次的元素。 题解 1234567891011121314151617181920212223242526#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt; &amp;nums) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i++) &#123; while (nums[i] != nums[nums[i] - 1]) swap(nums[i], nums[nums[i] - 1]); &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] - 1 != i) res.push_back(nums[i] - 1); &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"433-Minimum Genetic Mutation","path":"/wiki/leetcode/433-Minimum Genetic Mutation.html","content":"题意 给出初始字符串、目标字符串和一组中间字符串，有如下规则。 每次改变只能改变字符串中的一位字符。 改变后的字符串必须在中间字符串中。 为初始字符串变化为目标字符串所需要的次数。 题解 根据规则在中间字符串内建图，对于中间字符串内两个不同的字符串 a, b，如果他们相差一位字符，则连上一条双向边。最后以初始字符串作为源点和以目标字符串为汇点建图。 最后根据建好的图 bfs 一遍即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: unordered_map&lt;string, int&gt; id; vector&lt;string&gt; mp; vector&lt;int&gt; p[15]; bool vis[15]; int minMutation(string start, string end, vector&lt;string&gt; &amp;bank) &#123; mp = bank; for (int i = 1; i &lt;= bank.size(); i++) &#123; id[bank[i - 1]] = i; &#125; int n = bank.size() + 1; for (int i = 0; i &lt; bank.size(); i++) &#123; for (int j = 0; j &lt; bank.size(); j++) &#123; if (i == j) continue; int flag = 0; for (int k = 0; k &lt; bank[i].size(); k++) &#123; if (bank[i][k] != bank[j][k]) flag++; &#125; if (flag == 1) &#123; p[id[bank[i]]].push_back(id[bank[j]]); p[id[bank[j]]].push_back(id[bank[i]]); &#125; &#125; int flag = 0; for (int k = 0; k &lt; bank[i].size(); k++) &#123; if (start[k] != bank[i][k]) flag++; &#125; if (flag == 1) &#123; p[0].push_back(id[bank[i]]); p[id[bank[i]]].push_back(0); &#125; flag = 0; for (int k = 0; k &lt; bank[i].size(); k++) &#123; if (end[k] != bank[i][k]) flag++; &#125; if (flag == 0) &#123; p[n].push_back(id[bank[i]]); p[id[bank[i]]].push_back(n); &#125; &#125; queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(0, -1); vis[0] = 1; while (!q.empty()) &#123; auto now = q.front(); q.pop(); if (now.first == n) &#123; return now.second; &#125; for (int i = 0; i &lt; p[now.first].size(); i++) &#123; int nxt = p[now.first][i]; if (vis[nxt]) continue; vis[nxt] = 1; q.emplace(nxt, now.second + 1); &#125; &#125; return -1; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"449-Serialize and Deserialize BST","path":"/wiki/leetcode/449-Serialize and Deserialize BST.html","content":"题意 将一个搜索树序列化为字符串，然后将字符串反序列化为一棵树。 序列化： 按照自己的规则将一组数据结构用字符串表示。 题解 没看到是搜索树，直接用层序遍历序列化，记录每一层的节点数据，空节点用特殊字符表示即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123; public: // Encodes a tree to a single string. string serialize(TreeNode *root) &#123; if (root == nullptr) return &quot;&quot;; string res = &quot;&quot;; queue&lt;pair&lt;TreeNode *, char&gt;&gt; q; q.emplace(root, &#x27;N&#x27;); while (!q.empty()) &#123; int len = q.size(); while (len--) &#123; auto qf = q.front(); q.pop(); auto now = qf.first; if (now == nullptr) &#123; res += qf.second; continue; &#125; stringstream ss; ss &lt;&lt; now-&gt;val; string temp; ss &gt;&gt; temp; res += temp + qf.second; if (now-&gt;left != nullptr) q.emplace(now-&gt;left, &#x27;L&#x27;); else q.emplace(nullptr, &#x27;#&#x27;); if (now-&gt;right != nullptr) q.emplace(now-&gt;right, &#x27;R&#x27;); else q.emplace(nullptr, &#x27;%&#x27;); &#125; res += &#x27;$&#x27;; &#125; return res; &#125; // Decodes your encoded data to tree. TreeNode *deserialize(string data) &#123; // cout&lt;&lt;data&lt;&lt;&quot; &quot;; if (data == &quot;&quot;) return nullptr; int index = 0; string temp = &quot;&quot;; while (data[index] &gt;= &#x27;0&#x27; &amp;&amp; data[index] &lt;= &#x27;9&#x27;) &#123; temp += data[index]; index++; &#125; index++; stringstream tt; tt &lt;&lt; temp; int root_v; tt &gt;&gt; root_v; TreeNode *root = new TreeNode(root_v); queue&lt;TreeNode *&gt; q; q.emplace(nullptr); q.emplace(root); TreeNode *now = root; while (index &lt; data.size()) &#123; if (data[index] == &#x27;$&#x27;) &#123; while (!q.empty() &amp;&amp; q.front() != nullptr) &#123; q.pop(); &#125; q.pop(); q.emplace(nullptr); index++; continue; &#125; else if (data[index] == &#x27;#&#x27;) &#123; index++; continue; &#125; else if (data[index] == &#x27;%&#x27;) &#123; index++; q.pop(); continue; &#125; string temp = &quot;&quot;; while (data[index] &gt;= &#x27;0&#x27; &amp;&amp; data[index] &lt;= &#x27;9&#x27;) &#123; temp += data[index]; index++; &#125; int now_val; stringstream ss; ss &lt;&lt; temp; ss &gt;&gt; now_val; if (data[index] == &#x27;L&#x27;) &#123; q.front()-&gt;left = new TreeNode(now_val); q.emplace(q.front()-&gt;left); &#125; else &#123; q.front()-&gt;right = new TreeNode(now_val); q.emplace(q.front()-&gt;right); q.pop(); &#125; index++; &#125; return root; &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec* ser = new Codec();// Codec* deser = new Codec();// string tree = ser-&gt;serialize(root);// TreeNode* ans = deser-&gt;deserialize(tree);// return ans;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"497-Random Point in Non-overlapping Rectangles","path":"/wiki/leetcode/497-Random Point in Non-overlapping Rectangles.html","content":"题意 给出多个在平面上且不相交的多个长方形，要求等概率从这些长方形范围内选出一个点（包含长方形的边），返回点的二维坐标。 题解 题目中的长方形数量小于100，每个长方形长和宽的长度不大于2000，所以每个长方形最多有 2000×2000=4e62000\\times2000=4e62000×2000=4e6 个点，总共最多 4e6×100=4e84e6\\times 100 = 4e84e6×100=4e8 个点。所以首先为每个点编号，然后等概率选取一个点，根据点的编号判断该点在哪个长方形中，然后根据点的编号与长方形左下角点编号的差距计算偏移，然后求出选取点的坐标。 1234567891011121314151617181920212223242526272829303132333435363738394041#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;int&gt; key; int maxn = 0; vector&lt;vector&lt;int&gt;&gt; rect; Solution(vector&lt;vector&lt;int&gt;&gt; &amp;rects) : rect(rects) &#123; for (auto &amp;x : rects) &#123; key.push_back(maxn); //Give points numbers maxn += (x[2] - x[0] + 1) * (x[3] - x[1] + 1); &#125; &#125; vector&lt;int&gt; pick() &#123; int now = rand() % maxn; int index = 0; while (index &lt; key.size() &amp;&amp; key[index] &lt;= now) index++; index--; // get which rectangle the point is in now -= key[index]; // calculate offset int len = rect[index][3] - rect[index][1] + 1; return &#123;rect[index][0] + now / len, rect[index][1] + now % len&#125;; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(rects); * vector&lt;int&gt; param_1 = obj-&gt;pick(); */#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"498-Diagonal Traverse","path":"/wiki/leetcode/498-Diagonal Traverse.html","content":"题意 按对角线遍历数组。 题解 只有两种方向，一种斜向上 x-1,y+1；一种斜向下 x+1,y-1。对于拐角处，有几种情况。 在对角处改变方向，这时需要根据在左下角还是右上角的情况做出不同处理。 在左边和上面改变方向，左边对应 y 小于 0 ，上面对应 x 小于 0 ，这时只需要将 x 或 y重置为0，然后改变方向。 在右边和下面改变方向，右边对应 y 等于 m ，下边对应 x 等于 n，这是除了将 y 改变为 m-1 ，或将 x 改变为 n-1 ，还需要将对应 x 加 2或者 y 加 2。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt; &amp;mat) &#123; int n = mat.size(); int m = mat[0].size(); vector&lt;int&gt; res; int dir = 1; int nowx = 0, nowy = 0; for (int i = 0; i &lt; m * n; i++) &#123; res.push_back(mat[nowx][nowy]); nowx -= dir, nowy += dir; if (nowx &lt; 0 &amp;&amp; nowy &gt;= m) &#123; nowx = 1; nowy = m - 1; dir = -1; &#125; else if (nowx &gt;= n &amp;&amp; nowy &lt; 0) &#123; nowx = n - 1; nowy = 1; dir = 1; &#125; else if (nowx &lt; 0) &#123; nowx = 0; dir = -1; &#125; else if (nowx &gt;= n) &#123; nowx = n - 1; nowy += 2; dir = 1; &#125; else if (nowy &lt; 0) &#123; nowy = 0; dir = 1; &#125; else if (nowy &gt;= m) &#123; nowy = m - 1; nowx += 2; dir = -1; &#125; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"513-Find Bottom Left Tree Value","path":"/wiki/leetcode/513-Find Bottom Left Tree Value.html","content":"题意 找到树中最左下的节点。 题解 层序遍历树，每次取每一层最左边的节点，最后的值即为最左下的节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123; public: int findBottomLeftValue(TreeNode *root) &#123; int res; queue&lt;TreeNode *&gt; q; q.push(root); while (!q.empty()) &#123; int len = q.size(); res = q.front()-&gt;val; while (len--) &#123; auto now = q.front(); q.pop(); if (now-&gt;left != nullptr) q.push(now-&gt;left); if (now-&gt;right != nullptr) q.push(now-&gt;right); &#125; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"508-Most Frequent Subtree Sum","path":"/wiki/leetcode/508-Most Frequent Subtree Sum.html","content":"题意 求树中频率最高的子树和的数字。 题解 深度优先搜索树，返回当前子树和，然后更新子树和的频率，如果当前子树和大于最大频率，则更新答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution &#123; public: vector&lt;int&gt; res; int maxcnt = 0; unordered_map&lt;int, int&gt; mp; int dfs(TreeNode *now) &#123; if (now == nullptr) return 0; int l, r; l = dfs(now-&gt;left); r = dfs(now-&gt;right); int sum = now-&gt;val + l + r; mp[sum]++; if (mp[sum] &gt; maxcnt) &#123; maxcnt = mp[sum]; res.clear(); &#125; if (mp[sum] == maxcnt) &#123; res.push_back(sum); &#125; return sum; &#125; vector&lt;int&gt; findFrequentTreeSum(TreeNode *root) &#123; dfs(root); return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"646. Maximum Length of Pair Chain","path":"/wiki/leetcode/646. Maximum Length of Pair Chain.html","content":"题意 给定一个数对集合，找出能够形成的最长数对链的长度。 当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 题解 类似最长上升子序列，创建一个数组维护每一个序列长度对应的最小末尾。对于二维数对的情况，可以先对其按第一个元素排序，然后对第二个元素进行dp。 123456789101112131415161718192021222324252627282930313233343536373839#[allow(dead_code)]#[allow(unused_imports)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;impl Solution &#123; pub fn find_longest_chain(mut pairs: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 &#123; let mut key = vec![]; pairs.sort_unstable(); for x in pairs &#123; let (s, e) = (x[0], x[1]); let index = key.partition_point(|x| x &lt; &amp;s); let index = key.get_mut(index); match index &#123; Some(x) =&gt; *x = min(*x, e), _ =&gt; key.push(e), &#125; &#125; key.len() as i32 &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; let temp = vec![vec![1, 2], vec![7, 8], vec![4, 5]]; println!(&quot;res:&#123;&#125;&quot;, Solution::find_longest_chain(temp));&#125;"},{"title":"713-Subarray Product Less Than K","path":"/wiki/leetcode/713-Subarray Product Less Than K.html","content":"题意 求数列字串积小于 k 的字串个数。 题解 枚举左节点，对于每一个左节点 i，找到满足字串积小于 k 的最长字串的右节点 high，那么每一个左节点有效的字串个数为 high - i +1。 对于两个左节点 i,ji , ji,j。 如果 i&lt;ji&lt;ji&lt;j，那么它们的最长右节点一定有 highi&lt;=highjhigh_i &lt;= high_jhighi​&lt;=highj​ 。枚举左节点时 high 是单调递增的，所以时间复杂度为 O(n)O(n)O(n)。 123456789101112131415161718192021222324252627282930313233#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int numSubarrayProductLessThanK(vector&lt;int&gt; &amp;nums, int k) &#123; int high = 0; int now = 1; int n = nums.size(); int res = 0; for (int i = 0; i &lt; n; i++) &#123; while (high &lt; n &amp;&amp; now * nums[high] &lt; k) &#123; now *= nums[high++]; &#125; if (high &gt; i) &#123; res += high - i; now /= nums[i]; &#125; else &#123; now = 1; high = i + 1; &#125; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"827. Making A Large Island","path":"/wiki/leetcode/827. Making A Large Island.html","content":"题意 给你一个大小为n x n二进制矩阵 grid 。最多只能将一格0变成1 。 返回执行此操作后，grid 中最大的岛屿面积是多少？ 岛屿由一组上、下、左、右四个方向相连的 1 形成。 题解 首先 dfs 染色，得到每个颜色的格子数量。然后枚举整个地图，对于每一个点，遍历它的上下左右的点所在的颜色区域，最后求和得到相连的区域大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#![allow(dead_code, unused_imports, unused_macros)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;const DIR: [[i32; 2]; 4] = [[0, 1], [1, 0], [-1, 0], [0, -1]];fn dfs( color: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, vis: &amp;mut Vec&lt;Vec&lt;bool&gt;&gt;, cnt: &amp;mut HashMap&lt;i32, i32&gt;, grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, p: (usize, usize), nowc: i32,) &#123; color[p.0][p.1] = nowc; vis[p.0][p.1] = true; cnt.entry(nowc).and_modify(|c| *c += 1).or_insert(1); let n = grid.len() as i32; for x in DIR &#123; let nx = p.0 as i32 + x[0]; let ny = p.1 as i32 + x[1]; if nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; !vis[nx as usize][ny as usize] &amp;&amp; grid[nx as usize][ny as usize] == 1 &#123; dfs(color, vis, cnt, grid, (nx as usize, ny as usize), nowc); &#125; &#125;&#125;impl Solution &#123; pub fn largest_island(grid: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 &#123; let mut cnt = HashMap::&lt;i32, i32&gt;::new(); cnt.insert(0, 0); let mut res = 0; let mut color = vec![vec![0; grid[0].len()]; grid.len()]; let mut vis = vec![vec![false; grid[0].len()]; grid.len()]; let mut now = 1; let n = grid.len() as i32; for i in 0..grid.len() &#123; for j in 0..grid.len() &#123; if grid[i][j] == 1 &amp;&amp; !vis[i][j] &#123; dfs(&amp;mut color, &amp;mut vis, &amp;mut cnt, &amp;grid, (i, j), now); now += 1; &#125; &#125; &#125; for i in 0..grid.len() &#123; for j in 0..grid.len() &#123; let mut temp = HashSet::new(); for d in DIR &#123; let nx = i as i32 + d[0]; let ny = j as i32 + d[1]; if nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &#123; temp.insert(color[nx as usize][ny as usize]); &#125; &#125; let mut sum = 0; if grid[i][j] == 0 &#123; sum = 1; &#125; for x in &amp;temp &#123; sum += cnt.get(x).unwrap(); &#125; res = max(res, sum); &#125; &#125; res &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; let a = vec![vec![0, 0], vec![1, 0]]; println!(&quot;res:&#123;&#125;&quot;, Solution::largest_island(a));&#125;"},{"title":"857. Minimum Cost to Hire K Workers","path":"/wiki/leetcode/857. Minimum Cost to Hire K Workers.html","content":"题意 有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。 现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资： 对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。 工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#![allow(dead_code, unused_imports, unused_macros)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;impl Solution &#123; pub fn mincost_to_hire_workers(quality: Vec&lt;i32&gt;, wage: Vec&lt;i32&gt;, k: i32) -&gt; f64 &#123; let mut key = quality .iter() .zip(wage.iter()) .map(|(&amp;x, &amp;y)| vec![x, y]) .collect::&lt;Vec&lt;_&gt;&gt;(); key.sort_unstable_by(|x, y| (x[1] * y[0]).cmp(&amp;(x[0] * y[1]))); let mut q = BinaryHeap::new(); let mut sum = 0; for i in 0..(k - 1) as usize &#123; q.push(key[i][0]); sum += key[i][0]; &#125; let mut res: f64 = 1000000000.0; for i in (k - 1) as usize..key.len() &#123; let temp = sum + key[i][0]; res = res.min(temp as f64 / key[i][0] as f64 * key[i][1] as f64); if let Some(x) = q.peek() &#123; if key[i][0] &lt; *x &#123; sum -= *x; q.pop(); q.push(key[i][0]); sum += key[i][0]; &#125; &#125; &#125; res &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; let a = vec![3, 1, 10, 10, 1]; let b = vec![4, 8, 2, 2, 7]; println!(&quot;res:&#123;&#125;&quot;, Solution::mincost_to_hire_workers(a, b, 3));&#125;","tags":[null,null]},{"title":"890-Find and Replace Pattern","path":"/wiki/leetcode/890-Find and Replace Pattern.html","content":"题意 给定一组目标字符串和原字符串，规定一种变换，原字符串中所有相同的字母可以变换为另一种字母。限制为每种字母只能变换一种字母，不同的字母不能变换成相同的字母。如&quot;abb&quot;可以变换为&quot;cdd&quot;，不能变换成&quot;cde&quot;或&quot;ccc&quot;。 题解 遍历目标字符串中的所有字符，如果长度和原字符串不相等直接跳过，然后遍历原字符串，如果当前字符不存在映射，就对应到目标字符串对应位置的字符，如果存在映射但与当前对应位置字符不相等直接跳过，如果有多个字符对应同一个字符，跳过当前的目标字符串，将所有符合条件的目标字符串放入答案中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;string&gt; findAndReplacePattern(vector&lt;string&gt; &amp;words, string pattern) &#123; int key[30]; bool vis[30]; vector&lt;string&gt; res; for (auto &amp;x : words) &#123; if (x.size() != pattern.size()) continue; memset(key, 0, sizeof key); memset(vis, 0, sizeof vis); bool flag = 1; for (int i = 0; i &lt; pattern.size(); i++) &#123; if (key[pattern[i] - &#x27;a&#x27;] == 0) &#123; if (vis[x[i] - &#x27;a&#x27;]) &#123; flag = 0; break; &#125; vis[x[i] - &#x27;a&#x27;] = 1; key[pattern[i] - &#x27;a&#x27;] = x[i]; &#125; if (key[pattern[i] - &#x27;a&#x27;] != x[i]) &#123; flag = 0; break; &#125; &#125; if (flag) &#123; res.push_back(x); &#125; &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"926-Flip String to Monotone Increasing","path":"/wiki/leetcode/926-Flip String to Monotone Increasing.html","content":"题意 给定一串01串，能够对其每一位进行翻转，即0变1，1变0。要求最终得到一个不下降的01串，例如000111111，求最小翻转次数。 题解 使用前缀和统计每一位左边0和1，和右边0和1的个数，枚举每一位 i 作为0到1上升的边缘。i 左边全为0，右边全为1，所以翻转次数为 i 左边1的个数加上 i 右边0的个数，最后求出最小值。 123456789101112131415161718192021222324252627282930313233343536#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: int key0[100005], key1[100005]; int minFlipsMonoIncr(string s) &#123; int cnt0 = 0; int index = 0; for (auto &amp;x : s) &#123; key0[index + 1] += key0[index], key1[index + 1] += key1[index]; if (x == &#x27;0&#x27;) &#123; cnt0++; key0[index + 1]++; &#125; else &#123; key1[index + 1]++; &#125; index++; &#125; int res = INT_MAX; for (int i = 0; i &lt;= s.size(); i++) &#123; res = min(res, key1[i] + cnt0 - key0[i]); &#125; return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"933-Number of Recent Calls","path":"/wiki/leetcode/933-Number of Recent Calls.html","content":"题意 流式输入时间戳为 t 的请求，对于每一次输入，返回 [t-3000,t] 内请求的个数。 题解 使用队列维护，将小于 t-3000 的数出队，再将 t 入队，返回当前队列元素个数。 1234567891011121314151617181920212223242526272829303132#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class RecentCounter &#123; public: queue&lt;int&gt; q; RecentCounter() &#123; &#125; int ping(int t) &#123; int low = t - 3000; while (!q.empty() &amp;&amp; low &gt; q.front()) &#123; q.pop(); &#125; q.push(t); return q.size(); &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * RecentCounter* obj = new RecentCounter(); * int param_1 = obj-&gt;ping(t); */#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif"},{"title":"937-Reorder Data in Log Files","path":"/wiki/leetcode/937-Reorder Data in Log Files.html","content":"题意 给定字符串数组，按规则对数组进行排序，规则如下： 每个字符串第一个单词为键，后面的为数据，存在两种数据，一种只包含小写字母，一种只包含数字。 所有小写字母数据在数字数据前面。 对于小写字母数据，按照字典序进行排序，如果数据相同，按照键的字典序排序。 对于数字数据，保持顺序和原数组相对顺序相同即可。 题解 按照规则模拟即可 1234567891011121314151617181920212223242526272829303132333435363738394041#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;string&gt; reorderLogFiles(vector&lt;string&gt; &amp;logs) &#123; vector&lt;int&gt; dig; vector&lt;pair&lt;string, string&gt;&gt; word; for (int i = 0; i &lt; logs.size(); i++) &#123; int now = 0; string key = &quot;&quot;; while (logs[i][now] != &#x27; &#x27;) key += logs[i][now], now++; if (logs[i][now + 1] &gt;= &#x27;0&#x27; &amp;&amp; logs[i][now + 1] &lt;= &#x27;9&#x27;) &#123; dig.push_back(i); &#125; else &#123; word.emplace_back(key, logs[i].substr(now)); &#125; &#125; sort(word.begin(), word.end(), [](const auto &amp;x, const auto &amp;y) &#123; if (x.second == y.second) return x.first &lt; y.first; return x.second &lt; y.second; &#125;); vector&lt;string&gt; res; for (auto &amp;x : word) &#123; res.emplace_back(x.first + x.second); &#125; for (auto &amp;x : dig) res.push_back((logs[x])); return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"942-DI String Match","path":"/wiki/leetcode/942-DI String Match.html","content":"题意 给出一组字符串，由 ‘D’ 和 ‘I’ 组成。这个字符串对应着一个由元素范围为 [0,n] 无重数组的关系： 当 s[i] == ‘I’, a[i] &lt; a[i+1]。 当 s[i] == ‘D’, a[i] &gt; a[i+1]。 举例： [3, 2, 0 ,1] 对应的字符串为 ‘DDI’。 给出关系，要求还原任意符合要求的数组。 题解 贪心地构造数组，设置当前最大值和当前最小值，当前字符为 ‘I’ 时，插入当前最小值，最小值加1，字符为 ‘D’ 时类似。 上面过程保证了构造的数组元素关系符合给出的字符串。 1234567891011121314151617181920212223242526#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: vector&lt;int&gt; diStringMatch(string s) &#123; int low = 0, high = s.size(); vector&lt;int&gt; res; for (auto &amp;x : s) &#123; if (x == &#x27;I&#x27;) res.emplace_back(low++); else res.emplace_back(high--); &#125; res.emplace_back(low); return res; &#125;&#125;;#ifdef LOCALint main() &#123; ios::sync_with_stdio(false); cin.tie(0);&#125;#endif","tags":[null]},{"title":"one way lcci","path":"/wiki/leetcode/one way lcci.html","content":"题意 给出原字符串和目标字符串，有三种操作： 原字符串改变一个字符。 原字符串删除一个字符。 原字符串添加一个字符。 最多可以做一次操作，问能否将原字符串变为目标字符串。 题解 首先原字符串添加一个字符串相当于目标字符串删除一个字符，所以当原字符串的长度小于目标字符串时交换一下原字符串和目标字符串即可，所以只剩下两种操作需要讨论。 原字符串改变一个字符： 首先原字符串和目标字符串长度必须相等，然后遍历一下，如果不同的字符超过一个说明不能改变。 原字符串删除一个字符： 遍历字符串，如果不相等就跳过，需要删除这个字符，如果出现两次不同的情况，说明不能改变。 1234567891011121314151617181920212223242526272829303132333435363738394041#define LOCAL#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3ftypedef long long ll;class Solution &#123; public: bool oneEditAway(string first, string second) &#123; if (first == second) return true; if (abs((int)first.size() - (int)second.size()) &gt; 1) return false; if (first.size() == second.size()) &#123; int cnt = 0; for (int i = 0; i &lt; first.size(); i++) &#123; if (first[i] != second[i]) &#123; cnt++; if (cnt &gt; 1) return false; &#125; &#125; &#125; else &#123; if (first.size() &lt; second.size()) swap(first, second); bool flag = 0; int now = second.size() - 1; for (int i = first.size() - 1; i &gt;= 0; i--) &#123; if (now == -1 &amp;&amp; i == 0) return true; if (first[i] != second[now]) &#123; if (flag) return false; flag = 1; &#125; else now--; &#125; &#125; return true; &#125;&#125;;"},{"title":"面试题 17.19. Missing Two LCCI","path":"/wiki/leetcode/面试题 17.19. Missing Two LCCI.html","content":"题意 You are given an array with all the numbers from 1 to N appearing exactly once, except for two number that is missing. How can you find the missing number in O(N) time and 0(1) space? 题解 原地哈希 数学 位运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#![allow(dead_code, unused_imports, unused_macros)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;#[cfg(feature = &quot;local&quot;)]struct Solution;macro_rules! hashmap &#123; ($( $key: expr =&gt; $val: expr ),*) =&gt; &#123;&#123; let mut map = ::std::collections::HashMap::new(); $( map.insert($key, $val); )* map &#125;&#125;&#125;// impl Solution &#123;// pub fn missing_two(mut nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;// nums.push(-1);// nums.push(-1);// let mut res = vec![];// for i in 0..nums.len() &#123;// while nums[i] != -1 &amp;&amp; nums[i] - 1 != i as i32 &#123;// let temp = nums[i] as usize - 1;// nums.swap(i, temp);// &#125;// &#125;// for i in 0..nums.len() &#123;// if nums[i] == -1 &#123;// res.push(i as i32 + 1);// &#125;// &#125;// res// &#125;// &#125;// impl Solution &#123;// pub fn missing_two(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;// let sum = nums.iter().sum::&lt;i32&gt;();// let n = nums.len() as i32 + 2;// let sum_two = n * (n + 1) / 2 - sum;// let key = sum_two / 2;// let sum_low = nums.iter().filter(|&amp;&amp;x| x &lt;= key).sum::&lt;i32&gt;();// let one = key * (key + 1) / 2 - sum_low;// // println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, sum_two, sum_low, sum);// vec![one, sum_two - one]// &#125;// &#125;impl Solution &#123; pub fn missing_two(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123; let nums = &amp;nums; let n = nums.len() as i32 + 2; let mut key = 0; (1..=n).into_iter().for_each(|x| key ^= x); nums.into_iter().for_each(|x| key ^= x); let diff = key &amp; -key; let mut one = 0; (1..=n).into_iter().for_each(|x| &#123; if x &amp; diff != 0 &#123; one ^= x &#125; &#125;); nums.into_iter().for_each(|x| &#123; if x &amp; diff != 0 &#123; one ^= x &#125; &#125;); vec![one, key ^ one] &#125;&#125;#[cfg(feature = &quot;local&quot;)]pub fn main() &#123; println!(&quot;res:&#123;:?&#125;&quot;, Solution::missing_two(vec![1]));&#125;","tags":[null,null,null]},{"title":"目录","path":"/wiki/rust_code/index.html","content":"rust 源码分析 (1) 概述 rust 源码分析 (2)-core-内存模块 rust 源码分析 (3)-std-alloc模块 rust 源码分析 (4)-std-backtrace模块 rust 源码分析 (5)-std-collection rust 源码分析 (6)-std-collection-HashMap","tags":[null]},{"title":"rust 源码分析 (1): 概述","path":"/wiki/rust_code/rust 源码分析 (1) 概述.html","content":"rust 源码版本: 1.72.0 rust 源码结构 代码结构如下 123456789101112131415161718192021222324.├── Cargo.lock├── Cargo.toml├── CODE_OF_CONDUCT.md├── compiler├── config.example.toml├── configure├── CONTRIBUTING.md├── COPYRIGHT├── library├── LICENSE-APACHE├── LICENSE-MIT├── LICENSES├── README.md├── RELEASES.md├── rustfmt.toml├── rust-toolchain├── src├── target├── tests├── triagebot.toml├── x├── x.ps1└── x.py 其中需要关注的是 compiler 、library 、src 这三个文件夹。 compiler 文件夹包含了 rust 的编译器源代码，这里的代码实现了 Rust 语言的语法分析、类型检查、代码优化和代码生成等功能。 library 包含了标准库的源代码，提供了许多常用的数据结构、函数和特性。 src 文件夹中的 README 说明了该文件夹的用途，里面包含了 构建系统、rustdoc、cargo 等工具的源码。 This directory contains some source code for the Rust project, including: The bootstrapping build system Various submodules for tools, like cargo, tidy, etc. rust 标准库 参考 std - Rust library 里包含两个关键的文件夹 core 、std ，可以发现他们导出的模块有部分重叠，下面是他们的一些关键区别。 Core 模块 (core)： core 模块是 Rust 的核心标准库，它包含了 Rust 语言的基本构建块和最基本的数据类型。 这个模块是无依赖的，意味着它不依赖于操作系统或外部库。这使得 Rust 的核心功能可以在各种平台上使用。 core 模块中的功能通常被认为是“无标准库”环境下的 Rust，因为它不包括与操作系统交互、文件 I/O 等高级功能。 该模块通常用于编写嵌入式系统、操作系统内核、WebAssembly 等不需要标准库的环境中的代码。 Std 模块 (std)： std 模块是 Rust 的标准库，它构建在 core 模块之上，并提供了更多的功能和功能性。 这个模块依赖于操作系统和外部库，因此包括与文件系统、多线程、网络编程、输入输出等相关的功能。 std 模块通常用于编写大多数 Rust 应用程序，包括命令行工具、网络服务器、桌面应用程序等。 它提供了标准的 Rust 抽象和类型，如 Vec、String、HashMap 等。 总之， core 是 Rust 的核心标准库，提供了基本的 Rust 语言构建块，而 std 是构建在 core 之上的标准库，提供了更多的高级功能和与外部环境的交互。 rust 编译器 #todo [ ] 编译器 rust 相关工程 #todo [ ] rust project","tags":[null]},{"title":"rust 源码分析 (2)-core: 内存模块","path":"/wiki/rust_code/rust 源码分析 (2)-core-内存模块.html","content":"rust 源码版本: 1.72.0 概述 rust 指针 文件位置: library/core/src/ptr 文件结构 12345678./├── alignment.rs├── const_ptr.rs├── metadata.rs├── mod.rs├── mut_ptr.rs├── non_null.rs└── unique.rs mod metadata #todo [ ] 太抽象了，还是看看远方的std库吧","tags":[null]},{"title":"rust 源码分析 (3)-std-alloc模块","path":"/wiki/rust_code/rust 源码分析 (3)-std-alloc模块.html","content":"rust 源码版本: 1.72.0 文件位置 library/std/src/alloc.rs","tags":[null]},{"title":"rust 源码分析 (4)-std-backtrace模块","path":"/wiki/rust_code/rust 源码分析 (4)-std-backtrace模块.html","content":"rust 源码版本: 1.72.0","tags":[null]},{"title":"rust 源码分析 (5)-std-collection","path":"/wiki/rust_code/rust 源码分析 (5)-std-collection.html","content":"rust 源码版本: 1.72.0 文件位置 library/std/src/collections/mod.rs 介绍 参考 std::collections - Rust rust 标准库实现了一些常见的数据结构: 数组 Vec 双端数组 VecDeque 链表 LinkedList 哈希map HashMap 按键排序map BTreeMap 哈希set HashSet 按键排序set BTreeSet 优先队列 BinaryHeap Tips Performance Sequences : get(i) insert(i) remove(i) append split_off(i) [Vec] O(1) O(n-i)* O(n-i) O(m)* O(n-i) [VecDeque] O(1) O(min(i, n-i))* O(min(i, n-i)) O(m)* O(min(i, n-i)) [LinkedList] O(min(i, n-i)) O(min(i, n-i)) O(min(i, n-i)) O(1) O(min(i, n-i)) Map : get insert remove range append [HashMap] O(1)~ O(1)~* O(1)~ N/A N/A [BTreeMap] O(log(n)) O(log(n)) O(log(n)) O(log(n)) O(n+m) 其中带 * 的为均摊复杂度，带 ~ 为期望复杂度。 Capacity Management 使用 with_capacity 方法预先分配容器内存。 使用 reserve 方法扩容。 使用 shrink_to_fit 缩容。 Iterators 通常用 iter 、 iter_mut 、into_iter 迭代容器。","tags":[null]},{"title":"rust 源码分析 (6)-std-collection-HashMap","path":"/wiki/rust_code/rust 源码分析 (6)-std-collection-HashMap.html","content":"rust 源码版本: 1.78.0 文件位置 library/std/src/collections/hash/map.rs HashMap 和 HashSet 位于 std 库中， 而其余的容器则在 alloc 库中，由 std 库重导出。 原因参考 Move HashMap to liballoc · Issue #27242 · rust-lang/rust · GitHub hashbrown itself is #[no_std] since it uses a non-HashDOS-safe hasher. The std shim is what adds the SipHash hasher which depends on randomness and TLS. 可能是哈希的实现方法依赖于系统的随机数发生器，所以 HashMap 和 HashSet 需要放到 std 库中。 实现 type 123pub struct HashMap&lt;K, V, S = RandomState&gt; &#123; base: base::HashMap&lt;K, V, S&gt;,&#125; 其中 K、V 、S 分别表示键类型、值类型和哈希函数。std 的 hashMap 实际上的底层实现实际上是 GitHub - rust-lang/hashbrown 。 由于 hashMap 内基本为 hashbrown 的封装，所以其中的常规函数和迭代器就省略不讲，下面讲一下其中有趣的地方。 issue HashMap的默认哈希函数为 SipHash ，用的是 SipHash-1-3 。 下面这这段代码来自 rust/library/std/src/hash/random.rs，为默认哈希函数的实现。 12345678910111213141516171819202122pub fn new() -&gt; RandomState &#123; // Historically this function did not cache keys from the OS and instead // simply always called `rand::thread_rng().gen()` twice. In #31356 it // was discovered, however, that because we re-seed the thread-local RNG // from the OS periodically that this can cause excessive slowdown when // many hash maps are created on a thread. To solve this performance // trap we cache the first set of randomly generated keys per-thread. // // Later in #36481 it was discovered that exposing a deterministic // iteration order allows a form of DOS attack. To counter that we // increment one of the seeds on every RandomState creation, giving // every corresponding HashMap a different iteration order. thread_local!(static KEYS: Cell&lt;(u64, u64)&gt; = &#123; Cell::new(sys::hashmap_random_keys()) &#125;); KEYS.with(|keys| &#123; let (k0, k1) = keys.get(); keys.set((k0.wrapping_add(1), k1)); RandomState &#123; k0, k1 &#125; &#125;)&#125; 哈希函数参数的初始化从注释中能看出有点说法，最初参数是在初始化随机数生成器后，调用两次随机数生成器分别生成k0，k1 两个参数，最初的代码为: 1234 pub fn new() -&gt; RandomState &#123; let mut r = rand::thread_rng(); RandomState &#123; k0: r.gen(), k1: r.gen() &#125;&#125; rand 代码位于 rust/src/libstd/rand/mod.rs randomState 代码位于 rust/src/libstd/collections/hash/map.rs 在 #27243 和 #31356 中提出，每个线程使用固定的随机数种子对于初始化速度有显著的提升(64倍)，最终在 #33318 中这个改动被合入，代码为: 1234567891011pub fn new() -&gt; RandomState &#123; thread_local!(static KEYS: (u64, u64) = &#123; let r = rand::OsRng::new(); let mut r = r.expect(&quot;failed to create an OS RNG&quot;); (r.gen(), r.gen()) &#125;); KEYS.with(|&amp;(k0, k1)| &#123; RandomState &#123; k0: k0, k1: k1 &#125; &#125;)&#125; 这个 mr 的做法为为每个线程生成两个随机种子，之后的同一线程初始化的 HashMap 都使用固定的随机种子(这个操作有点骚气)。然后在 #36481 中潜在的问题被逮住了，这种做法会被 Hash DoS attack。具体是这样的 由于每个线程中创建的 hashMap 使用同一个随机种子，考虑如下代码 1234let first_map: HashMap&lt;u64, _&gt; = (0..900000).map(|i| (i, ())).collect();let second_map: HashMap&lt;u64, _&gt; = (900000..1800000).map(|i| (i, ())).collect();let mut merged = first_map;merged.extend(second_map); 修复: #38368 #37470 variance 为了让生命周期更为智能， rust 引入了子类型和变异性(subtyping and variance)，具体来说可以参考以下两个链接。 子类型化和变异性 - Rust 秘典（死灵书） Subtyping and Variance - The Rustonomicon 可以看出 HashMap 的各种迭代器对于生命周期是协变的。 12345678910111213141516171819202122232425262728293031323334353637fn assert_covariance() &#123; fn map_key&lt;&#x27;new&gt;(v: HashMap&lt;&amp;&#x27;static str, u8&gt;) -&gt; HashMap&lt;&amp;&#x27;new str, u8&gt; &#123; v &#125; fn map_val&lt;&#x27;new&gt;(v: HashMap&lt;u8, &amp;&#x27;static str&gt;) -&gt; HashMap&lt;u8, &amp;&#x27;new str&gt; &#123; v &#125; fn iter_key&lt;&#x27;a, &#x27;new&gt;(v: Iter&lt;&#x27;a, &amp;&#x27;static str, u8&gt;) -&gt; Iter&lt;&#x27;a, &amp;&#x27;new str, u8&gt; &#123; v &#125; fn iter_val&lt;&#x27;a, &#x27;new&gt;(v: Iter&lt;&#x27;a, u8, &amp;&#x27;static str&gt;) -&gt; Iter&lt;&#x27;a, u8, &amp;&#x27;new str&gt; &#123; v &#125; fn into_iter_key&lt;&#x27;new&gt;(v: IntoIter&lt;&amp;&#x27;static str, u8&gt;) -&gt; IntoIter&lt;&amp;&#x27;new str, u8&gt; &#123; v &#125; fn into_iter_val&lt;&#x27;new&gt;(v: IntoIter&lt;u8, &amp;&#x27;static str&gt;) -&gt; IntoIter&lt;u8, &amp;&#x27;new str&gt; &#123; v &#125; fn keys_key&lt;&#x27;a, &#x27;new&gt;(v: Keys&lt;&#x27;a, &amp;&#x27;static str, u8&gt;) -&gt; Keys&lt;&#x27;a, &amp;&#x27;new str, u8&gt; &#123; v &#125; fn keys_val&lt;&#x27;a, &#x27;new&gt;(v: Keys&lt;&#x27;a, u8, &amp;&#x27;static str&gt;) -&gt; Keys&lt;&#x27;a, u8, &amp;&#x27;new str&gt; &#123; v &#125; fn values_key&lt;&#x27;a, &#x27;new&gt;(v: Values&lt;&#x27;a, &amp;&#x27;static str, u8&gt;) -&gt; Values&lt;&#x27;a, &amp;&#x27;new str, u8&gt; &#123; v &#125; fn values_val&lt;&#x27;a, &#x27;new&gt;(v: Values&lt;&#x27;a, u8, &amp;&#x27;static str&gt;) -&gt; Values&lt;&#x27;a, u8, &amp;&#x27;new str&gt; &#123; v &#125; fn drain&lt;&#x27;new&gt;( d: Drain&lt;&#x27;static, &amp;&#x27;static str, &amp;&#x27;static str&gt;, ) -&gt; Drain&lt;&#x27;new, &amp;&#x27;new str, &amp;&#x27;new str&gt; &#123; d &#125;&#125;","tags":[null]},{"path":"/game/life-game/pkg/package.json","content":"{\"name\":\"rust-game-booiris\",\"collaborators\":[\"booiris \"],\"version\":\"0.1.0\",\"files\":[\"rust_game_booiris_bg.wasm\",\"rust_game_booiris.js\",\"rust_game_booiris.d.ts\"],\"module\":\"rust_game_booiris.js\",\"types\":\"rust_game_booiris.d.ts\",\"sideEffects\":false}"},{"path":"/game/life-game/pkg/README.html","content":"wasm-pack-template A template for kick starting a Rust and WebAssembly project using wasm-pack. Tutorial | Chat Built with 🦀🕸 by The Rust and WebAssembly Working Group About 📚 Read this template tutorial! 📚 This template is designed for compiling Rust libraries into WebAssembly and publishing the resulting package to NPM. Be sure to check out other wasm-pack tutorials online for other templates and usages of wasm-pack. 🚴 Usage 🐑 Use cargo generate to Clone this Template Learn more about cargo generate here. 12cargo generate --git https://github.com/rustwasm/wasm-pack-template.git --name my-projectcd my-project 🛠️ Build with wasm-pack build 1wasm-pack build 🔬 Test in Headless Browsers with wasm-pack test 1wasm-pack test --headless --firefox 🎁 Publish to NPM with wasm-pack publish 1wasm-pack publish 🔋 Batteries Included wasm-bindgen for communicating between WebAssembly and JavaScript. console_error_panic_hook for logging panic messages to the developer console. wee_alloc, an allocator optimized for small code size. LICENSE-APACHE and LICENSE-MIT: most Rust projects are licensed this way, so these are included for you License Licensed under either of Apache License, Version 2.0, (LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0) MIT license (LICENSE-MIT or http://opensource.org/licenses/MIT) at your option. Contribution Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions."},{"path":"/game/life-game/pkg/rust_game_booiris.js","content":"let wasm; const heap = new Array(32).fill(undefined); heap.push(undefined, null, true, false); function getObject(idx) { return heap[idx]; } let heap_next = heap.length; function dropObject(idx) { if (idx < 36) return; heap[idx] = heap_next; heap_next = idx; } function takeObject(idx) { const ret = getObject(idx); dropObject(idx); return ret; } const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }); cachedTextDecoder.decode(); let cachedUint8Memory0 = new Uint8Array(); function getUint8Memory0() { if (cachedUint8Memory0.byteLength === 0) { cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer); } return cachedUint8Memory0; } function getStringFromWasm0(ptr, len) { return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len)); } function addHeapObject(obj) { if (heap_next === heap.length) heap.push(heap.length + 1); const idx = heap_next; heap_next = heap[idx]; heap[idx] = obj; return idx; } let WASM_VECTOR_LEN = 0; const cachedTextEncoder = new TextEncoder('utf-8'); const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) { return cachedTextEncoder.encodeInto(arg, view); } : function (arg, view) { const buf = cachedTextEncoder.encode(arg); view.set(buf); return { read: arg.length, written: buf.length }; }); function passStringToWasm0(arg, malloc, realloc) { if (realloc === undefined) { const buf = cachedTextEncoder.encode(arg); const ptr = malloc(buf.length); getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf); WASM_VECTOR_LEN = buf.length; return ptr; } let len = arg.length; let ptr = malloc(len); const mem = getUint8Memory0(); let offset = 0; for (; offset < len; offset++) { const code = arg.charCodeAt(offset); if (code > 0x7F) break; mem[ptr + offset] = code; } if (offset !== len) { if (offset !== 0) { arg = arg.slice(offset); } ptr = realloc(ptr, len, len = offset + arg.length * 3); const view = getUint8Memory0().subarray(ptr + offset, ptr + len); const ret = encodeString(arg, view); offset += ret.written; } WASM_VECTOR_LEN = offset; return ptr; } let cachedInt32Memory0 = new Int32Array(); function getInt32Memory0() { if (cachedInt32Memory0.byteLength === 0) { cachedInt32Memory0 = new Int32Array(wasm.memory.buffer); } return cachedInt32Memory0; } function notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; } /** */ export const Cell = Object.freeze({ Dead:0,\"0\":\"Dead\",Alive:1,\"1\":\"Alive\", }); /** */ export class Universe { static __wrap(ptr) { const obj = Object.create(Universe.prototype); obj.ptr = ptr; return obj; } __destroy_into_raw() { const ptr = this.ptr; this.ptr = 0; return ptr; } free() { const ptr = this.__destroy_into_raw(); wasm.__wbg_universe_free(ptr); } /** */ tick() { wasm.universe_tick(this.ptr); } /** * @returns {Universe} */ static new() { const ret = wasm.universe_new(); return Universe.__wrap(ret); } /** * @returns {number} */ width() { const ret = wasm.universe_width(this.ptr); return ret >>> 0; } /** * @returns {number} */ height() { const ret = wasm.universe_height(this.ptr); return ret >>> 0; } /** * @param {number} width */ set_width(width) { wasm.universe_set_width(this.ptr, width); } /** * @param {number} height */ set_height(height) { wasm.universe_set_height(this.ptr, height); } /** * @returns {number} */ cells() { const ret = wasm.universe_cells(this.ptr); return ret; } /** * @param {number} row * @param {number} column */ toggle_cell(row, column) { wasm.universe_toggle_cell(this.ptr, row, column); } /** */ restart() { wasm.universe_restart(this.ptr); } } async function load(module, imports) { if (typeof Response === 'function' && module instanceof Response) { if (typeof WebAssembly.instantiateStreaming === 'function') { try { return await WebAssembly.instantiateStreaming(module, imports); } catch (e) { if (module.headers.get('Content-Type') != 'application/wasm') { console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error: \", e); } else { throw e; } } } const bytes = await module.arrayBuffer(); return await WebAssembly.instantiate(bytes, imports); } else { const instance = await WebAssembly.instantiate(module, imports); if (instance instanceof WebAssembly.Instance) { return { instance, module }; } else { return instance; } } } function getImports() { const imports = {}; imports.wbg = {}; imports.wbg.__wbg_new_abda76e883ba8a5f = function() { const ret = new Error(); return addHeapObject(ret); }; imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) { const ret = getObject(arg1).stack; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) { try { console.error(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbindgen_object_drop_ref = function(arg0) { takeObject(arg0); }; imports.wbg.__wbg_random_656f2ae924b2540e = typeof Math.random == 'function' ? Math.random : notDefined('Math.random'); imports.wbg.__wbindgen_throw = function(arg0, arg1) { throw new Error(getStringFromWasm0(arg0, arg1)); }; return imports; } function initMemory(imports, maybe_memory) { } function finalizeInit(instance, module) { wasm = instance.exports; init.__wbindgen_wasm_module = module; cachedInt32Memory0 = new Int32Array(); cachedUint8Memory0 = new Uint8Array(); return wasm; } function initSync(module) { const imports = getImports(); initMemory(imports); if (!(module instanceof WebAssembly.Module)) { module = new WebAssembly.Module(module); } const instance = new WebAssembly.Instance(module, imports); return finalizeInit(instance, module); } async function init(input) { if (typeof input === 'undefined') { input = new URL('rust_game_booiris_bg.wasm', import.meta.url); } const imports = getImports(); if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) { input = fetch(input); } initMemory(imports); const { instance, module } = await load(await input, imports); return finalizeInit(instance, module); } export { initSync } export default init; export { wasm }"},{"path":"/game/push-box/pkg/README.html","content":"wasm-pack-template A template for kick starting a Rust and WebAssembly project using wasm-pack. Tutorial | Chat Built with 🦀🕸 by The Rust and WebAssembly Working Group About 📚 Read this template tutorial! 📚 This template is designed for compiling Rust libraries into WebAssembly and publishing the resulting package to NPM. Be sure to check out other wasm-pack tutorials online for other templates and usages of wasm-pack. 🚴 Usage 🐑 Use cargo generate to Clone this Template Learn more about cargo generate here. 12cargo generate --git https://github.com/rustwasm/wasm-pack-template.git --name my-projectcd my-project 🛠️ Build with wasm-pack build 1wasm-pack build 🔬 Test in Headless Browsers with wasm-pack test 1wasm-pack test --headless --firefox 🎁 Publish to NPM with wasm-pack publish 1wasm-pack publish 🔋 Batteries Included wasm-bindgen for communicating between WebAssembly and JavaScript. console_error_panic_hook for logging panic messages to the developer console. wee_alloc, an allocator optimized for small code size. LICENSE-APACHE and LICENSE-MIT: most Rust projects are licensed this way, so these are included for you License Licensed under either of Apache License, Version 2.0, (LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0) MIT license (LICENSE-MIT or http://opensource.org/licenses/MIT) at your option. Contribution Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions."},{"path":"/game/push-box/pkg/package.json","content":"{\"name\":\"push-box\",\"collaborators\":[\"booiris \"],\"version\":\"0.1.0\",\"files\":[\"push_box_bg.wasm\",\"push_box.js\",\"push_box.d.ts\"],\"module\":\"push_box.js\",\"types\":\"push_box.d.ts\",\"sideEffects\":false}"},{"path":"/game/push-box/pkg/rust_game_booiris.js","content":"export { wasm }"},{"path":"/game/push-box/pkg/push_box.js","content":"let wasm; const heap = new Array(32).fill(undefined); heap.push(undefined, null, true, false); function getObject(idx) { return heap[idx]; } let heap_next = heap.length; function dropObject(idx) { if (idx < 36) return; heap[idx] = heap_next; heap_next = idx; } function takeObject(idx) { const ret = getObject(idx); dropObject(idx); return ret; } const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }); cachedTextDecoder.decode(); let cachedUint8Memory0 = new Uint8Array(); function getUint8Memory0() { if (cachedUint8Memory0.byteLength === 0) { cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer); } return cachedUint8Memory0; } function getStringFromWasm0(ptr, len) { return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len)); } function addHeapObject(obj) { if (heap_next === heap.length) heap.push(heap.length + 1); const idx = heap_next; heap_next = heap[idx]; heap[idx] = obj; return idx; } let WASM_VECTOR_LEN = 0; const cachedTextEncoder = new TextEncoder('utf-8'); const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) { return cachedTextEncoder.encodeInto(arg, view); } : function (arg, view) { const buf = cachedTextEncoder.encode(arg); view.set(buf); return { read: arg.length, written: buf.length }; }); function passStringToWasm0(arg, malloc, realloc) { if (realloc === undefined) { const buf = cachedTextEncoder.encode(arg); const ptr = malloc(buf.length); getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf); WASM_VECTOR_LEN = buf.length; return ptr; } let len = arg.length; let ptr = malloc(len); const mem = getUint8Memory0(); let offset = 0; for (; offset < len; offset++) { const code = arg.charCodeAt(offset); if (code > 0x7F) break; mem[ptr + offset] = code; } if (offset !== len) { if (offset !== 0) { arg = arg.slice(offset); } ptr = realloc(ptr, len, len = offset + arg.length * 3); const view = getUint8Memory0().subarray(ptr + offset, ptr + len); const ret = encodeString(arg, view); offset += ret.written; } WASM_VECTOR_LEN = offset; return ptr; } let cachedInt32Memory0 = new Int32Array(); function getInt32Memory0() { if (cachedInt32Memory0.byteLength === 0) { cachedInt32Memory0 = new Int32Array(wasm.memory.buffer); } return cachedInt32Memory0; } function handleError(f, args) { try { return f.apply(this, args); } catch (e) { wasm.__wbindgen_exn_store(addHeapObject(e)); } } function getArrayU8FromWasm0(ptr, len) { return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len); } /** */ export const Cell = Object.freeze({ Empty:0,\"0\":\"Empty\",Person:1,\"1\":\"Person\",Key:2,\"2\":\"Key\",Aim:3,\"3\":\"Aim\",Wall:4,\"4\":\"Wall\", }); /** */ export class Game { static __wrap(ptr) { const obj = Object.create(Game.prototype); obj.ptr = ptr; return obj; } __destroy_into_raw() { const ptr = this.ptr; this.ptr = 0; return ptr; } free() { const ptr = this.__destroy_into_raw(); wasm.__wbg_game_free(ptr); } /** */ tick() { wasm.game_tick(this.ptr); } /** * @returns {Game} */ static new() { const ret = wasm.game_new(); return Game.__wrap(ret); } /** * @returns {number} */ width() { const ret = wasm.game_width(this.ptr); return ret >>> 0; } /** * @returns {number} */ height() { const ret = wasm.game_height(this.ptr); return ret >>> 0; } /** * @returns {number} */ room() { const ret = wasm.game_room(this.ptr); return ret; } /** * @returns {boolean} */ game_over() { const ret = wasm.game_game_over(this.ptr); return ret !== 0; } /** */ restart() { wasm.game_restart(this.ptr); } /** * @param {boolean} v */ set_is_log(v) { wasm.game_set_is_log(this.ptr, v); } } async function load(module, imports) { if (typeof Response === 'function' && module instanceof Response) { if (typeof WebAssembly.instantiateStreaming === 'function') { try { return await WebAssembly.instantiateStreaming(module, imports); } catch (e) { if (module.headers.get('Content-Type') != 'application/wasm') { console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error: \", e); } else { throw e; } } } const bytes = await module.arrayBuffer(); return await WebAssembly.instantiate(bytes, imports); } else { const instance = await WebAssembly.instantiate(module, imports); if (instance instanceof WebAssembly.Instance) { return { instance, module }; } else { return instance; } } } function getImports() { const imports = {}; imports.wbg = {}; imports.wbg.__wbindgen_object_drop_ref = function(arg0) { takeObject(arg0); }; imports.wbg.__wbindgen_string_new = function(arg0, arg1) { const ret = getStringFromWasm0(arg0, arg1); return addHeapObject(ret); }; imports.wbg.__wbg_new_abda76e883ba8a5f = function() { const ret = new Error(); return addHeapObject(ret); }; imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) { const ret = getObject(arg1).stack; const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc); const len0 = WASM_VECTOR_LEN; getInt32Memory0()[arg0 / 4 + 1] = len0; getInt32Memory0()[arg0 / 4 + 0] = ptr0; }; imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) { try { console.error(getStringFromWasm0(arg0, arg1)); } finally { wasm.__wbindgen_free(arg0, arg1); } }; imports.wbg.__wbg_log_4b5638ad60bdc54a = function(arg0) { console.log(getObject(arg0)); }; imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) { getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2)); }; imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) { getObject(arg0).getRandomValues(getObject(arg1)); }; imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () { const ret = self.self; return addHeapObject(ret); }, arguments) }; imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) { const ret = getObject(arg0).crypto; return addHeapObject(ret); }; imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) { const ret = getObject(arg0).msCrypto; return addHeapObject(ret); }; imports.wbg.__wbindgen_is_undefined = function(arg0) { const ret = getObject(arg0) === undefined; return ret; }; imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) { const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2)); return addHeapObject(ret); }; imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) { const ret = getObject(arg0).getRandomValues; return addHeapObject(ret); }; imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() { const ret = module; return addHeapObject(ret); }; imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) { const ret = getObject(arg0).buffer; return addHeapObject(ret); }; imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) { const ret = new Uint8Array(getObject(arg0)); return addHeapObject(ret); }; imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) { getObject(arg0).set(getObject(arg1), arg2 >>> 0); }; imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) { const ret = getObject(arg0).length; return ret; }; imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) { const ret = new Uint8Array(arg0 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) { const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0); return addHeapObject(ret); }; imports.wbg.__wbindgen_throw = function(arg0, arg1) { throw new Error(getStringFromWasm0(arg0, arg1)); }; imports.wbg.__wbindgen_memory = function() { const ret = wasm.memory; return addHeapObject(ret); }; return imports; } function initMemory(imports, maybe_memory) { } function finalizeInit(instance, module) { wasm = instance.exports; init.__wbindgen_wasm_module = module; cachedInt32Memory0 = new Int32Array(); cachedUint8Memory0 = new Uint8Array(); return wasm; } function initSync(module) { const imports = getImports(); initMemory(imports); if (!(module instanceof WebAssembly.Module)) { module = new WebAssembly.Module(module); } const instance = new WebAssembly.Instance(module, imports); return finalizeInit(instance, module); } async function init(input) { if (typeof input === 'undefined') { input = new URL('push_box_bg.wasm', import.meta.url); } const imports = getImports(); if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) { input = fetch(input); } initMemory(imports); const { instance, module } = await load(await input, imports); return finalizeInit(instance, module); } export { initSync } export default init; export { wasm }"}]